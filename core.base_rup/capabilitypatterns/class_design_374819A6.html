<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Дескриптор задачи: Проектирование классов</title>
<meta content="TaskDescriptor" name="uma.type">
<meta content="class_design" name="uma.name">
<meta content="Проектирование классов" name="uma.presentationName">
<meta content="_xrlnMEocEdqrjq4i3fchvA" name="uma.guid">
<meta content="TaskDescriptor" name="element_type">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ActivityTreeTable.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ProcessElementPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/processElementData.js"></script><script language="JavaScript" type="text/javascript">
					var defaultQueryStr = '?proc={002674F9-6511-4D15-8623-B761D8C48986}&path={002674F9-6511-4D15-8623-B761D8C48986},{FB3EB753-A979-4849-B57B-97F39271F82B},_xrlnMEocEdqrjq4i3fchvA';
					var backPath = './../../';
					var imgPath = './../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo, defaultQueryStr, true, true, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top">
<div id="page-guid" value="_xrlnMEocEdqrjq4i3fchvA"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Дескриптор задачи: Проектирование классов</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../images/taskdes_lg_dgm32.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Эта задача определяет способ проектирования структуры классов подсистемы или компонента.</td>
</tr>
<tr>
<td>На основе задачи метода: <a href="./../../core.base_rup/tasks/class_design_98F20FF9.html" guid="{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}">Проектирование классов</a></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Роли</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Главный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_designer_D022ADCE.html" guid="_oAYVQTbYEdqdbfmtFQj8qA">Проектировщик</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Дополнительно:
								</span></td><td class="sectionTableCell"><span class="sectionTableCellHeading">Помощь:
								</span></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Входы</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Обязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_B47A47A8.html" guid="_mju5QL9dEdqBwpaAk4N49g">Класс анализа</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_45E0F882.html" guid="_m-5LQL9dEdqBwpaAk4N49g">Класс анализа</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Необязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_supplementary_specification_F9C7C5E1.html" guid="_oAeb4jbYEdqdbfmtFQj8qA">Дополнительные спецификации</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_465A5F1.html" guid="_oAeb4zbYEdqdbfmtFQj8qA">Модель проекта</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_user_interface_prototype_C73ECF8B.html" guid="_CPBHEhi2Edq_uI8xTPML6g">Прототип интерфейса</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_storyboard_328ACCE3.html" guid="_xrrt0EocEdqrjq4i3fchvA">Раскадровка</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_project_specific_guidelines_286E840C.html" guid="_CPHNtxi2Edq_uI8xTPML6g">Рекомендации по проекту</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">Внешний:
								</span>
<ul>
<li>Нет</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Выходы</th><td colspan="3" class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_465A5F1.html" guid="_oAeb4zbYEdqdbfmtFQj8qA">Модель проекта</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Шаги</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr>
<td class="sectionTableCell">
<div class="stepHeading"> Использование механизмов и шаблонов проекта </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_patterns__using" name="XE_patterns__using"></a><a id="XE_mechanisms__using" name="XE_mechanisms__using"></a><a id="Use Design Patterns and Mechanisms" name="Use Design Patterns and Mechanisms"></a>
<p>
    Используйте механизмы и шаблоны проекта, подходящие для класса или проектируемой функции, в соответствии с
    рекомендациями по проектированию.
</p>
<p>
    Включение шаблона и/или механизма эффективно выполняет ряд последовательных действий в этой задаче (добавление новых
    классов, атрибутов и взаимосвязей), но в соответствии с правилами, определенными этим шаблоном или механизмом.
</p>
<p>
    Заметьте, что шаблоны и механизмы обычно включаются по мере развития проекта, а не только в начале этой задачи. Они
    также часто применяются к набору классов, а не только к одному классу.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Создание начальных классов проекта </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_class__creating_design_classes_initially" name="XE_class__creating_design_classes_initially"></a><a id="Create Initial Design Classes" name="Create Initial Design Classes"></a>
<p>
    Создайте один или несколько начальных классов проекта для класса анализа, данного на входе этой задачи, и назначьте
    зависимости трассировки. Созданные на этом шаге классы проекта будут уточнены, откорректированы, разбиты или объединены
    в последующих шагах, когда будут определены различные свойства проекта, такие как операции, методы и конечные автоматы,
    которые описывают способ проектирования класса анализа.
</p>
<p>
    В зависимости от типа класса анализа (пограничный, сущностный или управляющий), существуют определенные стратегии
    создания начальных классов проекта.
</p>
<h4>
    <a id="XE_boundary_class__designing" name="XE_boundary_class__designing"></a><a id="Designing boundary classes" name="Designing boundary classes">Проектирование пограничных классов</a>
</h4>
<p>
    Пограничные классы представляют интерфейсы или пользователям, или другим системам.
</p>
<p>
    Обычно, пограничные классы, которые представляют интерфейсы другим системам, моделируются как подсистемы, потому что
    они часто имеют сложное внутреннее поведение. Если поведение интерфейса является простым (например, интерфейс реализует
    только лишь переход к существующему API внешней системы), то интерфейс моно представить с помощью одного или нескольких
    классов проекта. Если вы выбираете такой подход, то используйте один класс проекта для каждого протокола, интерфейса
    или API, и опишите специальные требования к стандартам, использованным в классе.
</p>
<p>
    Пограничные классы, которые представляют интерфейс пользователям, обычно следуют правилу: один класс на каждое окно или
    форму пользовательского интерфейса. Следовательно, ответственность пограничных классов может быть определена на высоком
    уровне, и должна быть уточнена и детализирована на этом шаге. Дополнительные модели или прототипы пользовательского
    интерфейса могут служить на этом шаге другим источников входа.
</p>
<p>
    Проект пограничных классов зависит от доступных средств разработки пользовательского интерфейса (UI). С помощью
    современной технологии пользовательский интерфейс обычно конструируется визуально непосредственно в средстве
    разработки. При этом автоматически создаются классы пользовательского интерфейса, которые относятся к проекту
    управляющих и сущностных классов. Если среда разработки пользовательского интерфейса автоматически создает
    поддерживающие классы, которые необходимы для его реализации, то эти классы не нужно учитывать в проекте. Необходимо
    проектировать только то, что среда разработки не создает сама.
</p>
<h4>
    <a id="XE_entity_class__designing" name="XE_entity_class__designing"></a><a id="Designing Entity Classes" name="Designing Entity Classes">Проектирование сущностных классов</a>
</h4>
<p>
    В процессе анализа, сущностные классы представляют управляемые блоки информации. Они часто являются пассивными и
    постоянными, а также могут быть идентифицированы и связаны с механизмами анализа для хранилища. Подробности
    проектирования механизма хранилища на основе базы данных описаны в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/database_design_8552DD3.html" guid="{2E74A414-49F5-4F27-BFCB-AA2DAC675F58}">Задача:
    Проектирование базы данных</a>. Из соображений производительности некоторые постоянные классы могут быть подвергнуты
    рефакторингу, что приведет к изменению Модели проекта, что обсуждается в разделах <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">Роль:
    Проектировщик базы данных</a> и <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Роль: Проектировщик</a>.
</p>
<p>
    Подробное обсуждение проблем проектирования постоянных классов представлено ниже под заголовком <a href="#Define Persistent Classes">Определение постоянных классов</a>.
</p>
<h4>
    <a id="XE_control_class__designing" name="XE_control_class__designing"></a><a id="Designing Control Classes" name="Designing Control Classes">Проектирование управляющих классов</a>
</h4>
<p>
    Управляющие объекты ответственны за управление потоком вариантов использования, и, следовательно, они координируют
    большую часть их действий. Управляющие объекты инкапсулируют логику, которая не относится напрямую к пользовательскому
    интерфейсу (пограничным объектам) или проектированию данных (сущностным объектам). Эта логика является тем, что иногда
    называется <b>логикой приложения</b> или <b>бизнес-логикой</b>.
</p>
<p>
    Обратите внимание на следующие проблемы при проектировании управляющих классов:
</p>
<ul>
    <li>
        <b>Сложность</b> - Простое управление или координацию поведения можно реализовать посредством пограничных или
        сущностных классов. Однако, по мере возрастания сложности приложения, возникают серьезные препятствия для такого
        подхода, например:
    </li>
</ul>
<blockquote>
    <ul>
        <li>
            координация поведения вариантов использования становится встроенной в пользовательский интерфейс, что усложняет
            изменение системы
        </li>
        <li>
            один и тот же пользовательский интерфейс не может без трудностей использоваться в различных реализациях
            вариантов использования
        </li>
        <li>
            пользовательский интерфейс становится обременен дополнительной функциональностью, снижающей его быстродействие
        </li>
        <li>
            сущностные объекты становятся обременены поведением, характерным для варианта использования, что снижает их
            универсальность
        </li>
    </ul>
</blockquote>
<blockquote>
    <p>
        Для того чтобы избежать этих проблем, введены управляющие классы, которые обеспечивают поведение, относящееся к
        координации потока событий.
    </p>
</blockquote>
<ul>
    <li>
        <b>Возможность изменения</b> - Если вероятность изменения потока событий низка, или затраты являются
        незначительными, то использование дополнительных управляющих классов может оказаться неоправданным.
    </li>
    <li>
        <b>Распределение и производительность</b> - Необходимость выполнять части приложения на разных узлах или в разных
        пространствах обработки, вынуждает специализировать элементы модели проекта. Эта специализация часто осуществляется
        путем добавления управляющих объектов и распределенного поведения из пограничных и сущностных классов в управляющие
        классы. При таком подходе, пограничные классы предоставляют исключительно функции пользовательского интерфейса,
        сущностные классы обеспечивают исключительно обработку данных, а управляющие классы обеспечивают все остальное.
    </li>
    <li>
        <b>Управление транзакциями</b> - Управление транзакциями - это основная координирующая деятельность. При отсутствии
        структуры управления транзакциями взаимодействие одного или нескольких классов <b>администратора транзакций</b>
        может обеспечить целостность транзакций.
    </li>
</ul>
<p>
    В следующих двух случаях, если управляющий класс представляет отдельную нить управления, то для ее моделирования может
    больше подойти использование активного класса. В системах реального времени использование <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Рабочий продукт: Капсула</a> является предпочтительным подходом в
    моделировании.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение постоянных классов </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_persistent_class__identifying" name="XE_persistent_class__identifying"></a><a id="XE_entity_class__define_persistent_classes" name="XE_entity_class__define_persistent_classes"></a><a id="Define Persistent Classes" name="Define Persistent Classes"></a>
<p>
    Классы, которым необходимо сохранять свое состояние на постоянном носителе, называются постоянными. Сохранять свое
    состояние может быть необходимо для постоянной записи информации класса, для резервного копирования на случай неполадки
    в системе или для изменения информации. Постоянный класс может иметь как постоянные, так и временные экземпляры.
    Название постоянного класса означает только то, что некоторые его экземпляры могут быть постоянными.
</p>
<p>
    Механизмы проекта соответствуют механизмам хранилища, найденным в процессе анализа. Например, в зависимости от того,
    что требуется классу, механизм хранилища может быть реализован с помощью одного из следующих механизмов проекта:
</p>
<ul>
    <li>
        Хранение в памяти
    </li>
    <li>
        Флэш-карта
    </li>
    <li>
        Двоичный файл
    </li>
    <li>
        Система управления базами данных (DBMS)
    </li>
</ul>
<p>
    Постоянные объекты могут происходить не только от сущностных классов. Постоянным объектам может также потребоваться
    общее управление нефункциональными требованиями. Например, постоянным объектам может потребоваться сохранение
    информации для управления процессом или сохранение информации о состоянии между транзакциями.
</p>
<p>
    Определение постоянных классов помогает известить <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">Роль:
    Проектировщик базы данных</a> о том, что требуется уделить специальное внимание характеристикам физического хранения
    класса. Это также извещает <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_software_architect_DB0BF177.html" guid="{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}">Роль:
    Разработчик программного обеспечения</a>, что класс должен быть постоянным, и <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Роль:
    Проектировщик</a> должен обеспечить механизм хранилища, требуемый постоянным экземплярам класса.
</p>
<p>
    Для обеспечения скоординированной стратегии хранилища <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">Роль:
    Проектировщик базы данных</a> должен преобразовать постоянные классы в базу данных с помощью структуры хранилища. Если
    в проекте разрабатывается структура хранилища, то ее разработчик должен также понимать требования к хранилищу классов
    проекта. Для того чтобы предоставить этим людям необходимую информацию, в этом месте достаточно указать, что класс
    является постоянным, или, более точно, что его экземпляры являются постоянными.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение видимости класса</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Class Visibility" name="Define Class Visibility"></a>
<p>
    Для каждого класса определите его видимость в пакете, в котором он расположен. На класс <i>public</i> можно ссылаться
    снаружи содержащего его пакета. На класс <i>private</i> (или на класс, видимость которого - это <i>implementation</i>)
    может ссылаться только класс того же пакета.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение операций</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_operation__defining_on_classes" name="XE_operation__defining_on_classes"></a><a id="Define Operations" name="Define Operations"></a>
<ul>
    <li>
        <a href="#Identifying operations">Определение операций</a>
    </li>
    <li>
        <a href="#Naming and describing the operations">Именование и описание операций</a>
    </li>
    <li>
        <a href="#Defining operation visibility">Определение видимости операций</a>
    </li>
    <li>
        <a href="#Defining class operations">Определение операций класса</a>
    </li>
</ul>
<h4>
    <a id="Identifying operations" name="Identifying operations">Определение операций</a>
</h4>
<p>
    Для определения операций в классах проекта:
</p>
<ul>
    <li>
        Изучите обязанности каждого соответствующего класса анализа, и создайте для каждой из них операцию. Используйте
        описание обязанности как начальное описание операции.
    </li>
    <li>
        Изучите реализации вариантов использования в классе <i>participates</i>, чтобы понять, как в них используются
        операции. Расширьте операции, по одной реализации варианта использования за один раз, уточняя операции, их
        описания, типы возврата и параметры. Относящиеся к классам требования к реализации каждого варианта использования
        описаны в текстовом виде в Потоке событий реализации варианта использования.
    </li>
    <li>
        Изучите вариант использования Особые требования, чтобы не упустить неявные требования в операции, которая может
        быть выполнена здесь.
    </li>
</ul>
<p>
    Операции должны поддерживать сообщения, которые появляются на диаграммах схемы связей, потому что поведение класса
    описывается сценариями - временными спецификациями сообщения, которые еще не назначены операциям. На рисунке 1 показан
    пример диаграммы схемы связей.
</p>
<p align="center">
    <img src="./../../core.base_rup/guidances/guidelines/resources/seqdiag1.gif" width="672" height="417"     alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext" align="center">
    Рисунок 1: Форма сообщений, основа определения операций
</p>
<p>
    Реализации вариантов использования не могут представить достаточный объем информации для определения всех операций. Для
    поиска оставшихся операций, обратите внимание на следующее:
</p>
<ul>
    <li>
        Существует ли способ инициализировать новый экземпляр класса, подсоединив его к экземплярам других классов, с
        которыми он связан?
    </li>
    <li>
        Нужно ли осуществлять проверку, эквивалентны ли два экземпляра класса ?
    </li>
    <li>
        Нужно ли создавать копию экземпляра класса?
    </li>
    <li>
        Требуют ли используемые в классе механизмы каких-либо операций? Например, механизм <i>сбора мусора</i> может
        требовать, чтобы объект имел возможность удалить все свои ссылки на другие объекты для освобождения неиспользуемых
        ресурсов.
    </li>
</ul>
<p>
    Не определяйте операций, которые только лишь получают и устанавливают значения атрибутов public (см. <a href="#Define Attributes">Определение атрибутов</a> и <a href="#Define Associations">Определение связей</a>).
    Обычно они создаются средствами генерации кода, и их не нужно определять явно.
</p>
<h4>
    <a id="XE_operation__naming" name="XE_operation__naming"></a><a id="Naming and describing the operations" name="Naming and describing the operations">Именование и описание операций</a>
</h4>
<p>
    При именовании операций, типов возврата, параметров и их типов придерживайтесь соглашения об именах языка реализации.
    Они описаны в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рекомендации по проекту</a>.
</p>
<p>
    Для каждой операции необходимо определить следующее:
</p>
<ul>
    <li>
        <b>Имя операции</b> - имя должно быть коротким и наглядно описывать результат операции. 
        <ul>
            <li>
                Имена операций должны соответствовать синтаксису языка реализации. Пример: <b>find_location</b> применимо
                для C++ или Visual Basic, но не для Smalltalk (в котором не используются знаки подчеркивания). Имя,
                подходящее для всех - это <b>findLocation</b>.
            </li>
            <li>
                Избегайте имен, выражающих способ выполнения операции. Например, <b>Employee.wages()</b> - это лучше, чем
                <b>Employee.calculateWages()</b>, так как второе говорит о выполняемом вычислении. Операция может просто
                возвращать значение в базу данных.
            </li>
            <li>
                Имя операции должно ясно обозначать ее цель. Избегайте неопределенных имен, таких как <b>getData</b>,
                которые не описывают возвращаемый результат. Используйте имена, которые точно обозначают ожидаемый
                результат, например, <b>getAddress</b>. Еще лучше, если имя операции просто совпадает с именем свойства,
                которое оно получает или устанавливает. Если она имеет параметр, значит она устанавливает свойство. Если
                параметр отсутствует, значит она получает свойство. Пример: операция <b>address</b> возвращает адрес
                <b>Customer</b>, в то время как <b>address(aString)</b> устанавливает или изменяет адрес <b>Customer</b>.
                Сигнатура операции неявно предполагает, <i>получает</i> ли или <i>устанавливает</i> значение операция.
            </li>
            <li>
                Концептуально эквивалентные операции должны иметь одинаковые имена, даже если их определяют разные классы,
                если они реализованы совершенно различными способами, или если они имеют разное число параметров. Например,
                операция, создающая объект, должна иметь одинаковое имя во всех классах.
            </li>
            <li>
                Если операции в нескольких классах имеют одинаковую сигнатуру, они должны возвращать результаты одинакового
                вида, соответствующие получающему объекту. Это является примером <b>полиморфизма</b>, который означает, что
                разные объекты должны отвечать на одно сообщение одинаково. Пример: операция <b>name</b> должна возвращать
                имя объекта, независимо от того, как имя хранится или порождается. Следование этому принципу упрощает
                понимание модели.
            </li>
        </ul>
    </li>
    <li>
        <b>Тип возврата</b> - Тип возврата должен быть классом объекта, возвращаемого операцией.
    </li>
    <li>
        <b>Короткое описание</b> - Имя операции часто неясно описывает, что она делает. Дайте операции короткое описание из
        пары предложений с точки зрения ее <b>пользователя</b>.
    </li>
    <li>
        <b>Параметры</b> - Для каждого параметра создайте короткое выразительное имя и его короткое описание. При создании
        параметров помните, что меньшее их количество означает более высокую возможность их повторного использования.
        Небольшое количество параметров облегчает понимание операции и, следовательно, увеличивает вероятность обнаружения
        подобных операций. Может понадобиться разделить операцию с большим количеством параметров на несколько операций.
        Операция должна быть понятна тем, кто ее будет использовать. Короткое описание должно включать в себя: 
        <ul>
            <li>
                смысл параметров, который не ясен из их имен
            </li>
            <li>
                передается ли параметр <b>по значению</b> или <b>по ссылке</b>
            </li>
            <li>
                параметры, которые должны иметь значения
            </li>
            <li>
                параметры, которые могут быть необязательны, и их значения по умолчанию
            </li>
            <li>
                допустимые диапазоны значений параметров, если они применяются
            </li>
            <li>
                что делает операция
            </li>
            <li>
                какие параметры <b>по ссылке</b> изменяются операцией
            </li>
        </ul>
    </li>
</ul>
<p align="left">
    Определив операции, снабдите диаграммы схем связей информацией о том, какие операции вызываются для каждого сообщения.
</p>
<p align="left">
    Более подробная информация содержится в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_class_E98280BF.html#Class Operations" guid="2.914882084937444E-305">Рекомендации по рабочему продукту: Класс проекта</a>.
</p>
<h4 align="left">
    <a id="Defining operation visibility" name="Defining operation visibility">Определение видимости операций</a>
</h4>
<p align="left">
    Для каждой операции определите ее видимость из числа следующих вариантов:
</p>
<ul>
    <li>
        <b>Public</b> - операция видима элементам модели, отличным от самого класса.
    </li>
    <li>
        <b>Implementation</b> - операция видима только внутри самого класса.
    </li>
    <li>
        <b>Protected</b> - операция видима только самому классу, его подклассам и <i>друзьям</i> класса (зависит от языка).
    </li>
    <li>
        <b>Private</b> - операция видима только самому классу и <i>друзьям</i> класса.
    </li>
</ul>
<p>
    Выберите наиболее ограниченную видимость из тех, которые могут обеспечить выполнение целей операции. Для этого
    определите на диаграммах схем связей, приходит ли каждое сообщение из внешнего класса по отношению к пакету получателя
    (требует видимости <b>public</b>), из класса внутри пакета (требует видимости <b>implementation</b>), из подкласса
    (требует видимости <b>protected</b>), из самого класса или его друга (требует видимости <b>private</b>).
</p>
<h4>
    <a id="Defining class operations" name="Defining class operations">Определение операций класса</a>
</h4>
<p>
    Главным образом, операции являются операциями экземпляра, то есть, они выполняются в экземплярах классов. Однако, в
    некоторых случаях, операция применяется ко всем экземплярам класса, и поэтому является операцией <b>области видимости
    класса</b>. Получатель операции класса фактически является экземпляром <b>метакласса</b> (т.е. описания самого класса),
    а не определенного экземпляра класса. Примером операции класса является сообщение, создающее новый экземпляр, которое
    возвращает <b>все экземпляры</b> класса.
</p>
<p>
    Строка операции, которая имеет область видимости класса, подчеркивается.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение методов </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_method__defining_on_class" name="XE_method__defining_on_class"></a><a id="Define Methods" name="Define Methods"></a>
<p>
    Метод задает реализацию операции. Во многих случаях, когда поведение операции полностью определяется ее именем,
    описанием и параметрами, методы реализуются непосредственно в языках программирования. Когда реализация операции
    требует использования специального алгоритма или более подробной информации, чем та, которая представлена в ее
    описании, необходимо отдельное описание <b>метода</b>. <b>Метод</b> описывает то, как операция работает, а не только
    что она делает.
</p>
<p>
    Метод должен описывать, как:
</p>
<ul>
    <li>
        операции будут реализованы
    </li>
    <li>
        атрибуты будут реализованы и использованы для реализации операций
    </li>
    <li>
        взаимосвязи будут реализованы и использованы для реализации операций
    </li>
</ul>
<p>
    Требования меняются от случая к случаю, однако, спецификации метода класса всегда определяют:
</p>
<ul>
    <li>
        что будет сделано в соответствии с требованиями
    </li>
    <li>
        какие другие объекты и их операции будут использованы
    </li>
</ul>
<p>
    Более специальные требования могут относится к:
</p>
<ul>
    <li>
        тому, как параметры будут реализованы
    </li>
    <li>
        тому, какие специальные алгоритмы будут использованы
    </li>
</ul>
<p>
    Важным источником информации для этого являются диаграммы схем связей. Из них понятно, какие операции других объектов
    будут использованы при выполнении данной операции. Спецификация того, какие операции других объектов будут
    использованы, необходима для полной реализации операции. Создание полной спецификации метода требует определения
    связанных операций и проверку соответствующих диаграмм схем связей.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение состояний </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_state__defining_on_classes" name="XE_state__defining_on_classes"></a><a id="Define States" name="Define States"></a> 
<p>
    Для некоторых операций поведение зависит от состояния объекта получателя. Конечный автомат - это средство описания
    возможных состояний объекта и событий, которые переводят объект из одного состояния в другое (см. <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">Прием: Диаграмма состояний)</a>. Конечные автоматы наиболее полезны для описания
    активных классов. Использование конечных автоматов особенно важно для определения поведения <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Рабочий продукт: Капсула</a>.
</p>
<p>
    Пример простого конечного автомата показан на Рисунке 2.
</p>
<p align="center">
    <img src="./../../core.base_rup/tasks/resources/statedg.gif" width="439" height="363" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Рисунок 2: Простая диаграмма состояний для дозатора топлива
</p>
<p>
    Каждое событие изменения состояния может быть связано с операцией. В зависимости от состояния объекта, операция может
    иметь разное поведение, и события перехода описывают, как это происходит.
</p>
<p>
    В описание <b>метода</b> для связанной операции должна быть добавлена информация, характерная для состояния, которая
    обозначает поведение операции для каждого состояния. Состояния часто бывают представлены с помощью <b>атрибутов</b>, а
    диаграммы состояний служат входом на шаге определения атрибута.
</p>
<p>
    Более подробная информация находится в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">Прием:
    Диаграмма состояний</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение атрибутов</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_attribute_on_object__defining_on_classes" name="XE_attribute_on_object__defining_on_classes"></a><a id="Define Attributes" name="Define Attributes"></a><a id="Define Attributes" name="Define Attributes"></a>
<p>
    В процессе определения <b>методов</b> и определения <b>состояний</b> определяются атрибуты, необходимые классу для
    выполнения его операций. Атрибуты обеспечивают информацию для экземпляра класса, и они часто представляют состояние
    экземпляра класса. Сам класс поддерживает любую информацию посредством своих <b>атрибутов</b>. Для каждого атрибута
    определите:
</p>
<ul>
    <li>
        его <b>имя</b>, которое должно соответствовать соглашению об именах и языка реализации, и проекта
    </li>
    <li>
        его <b>тип</b>, являющийся элементарным типом данных, поддерживаемым языком реализации
    </li>
    <li>
        его <b>начальное значение или значение по умолчанию</b>, которое устанавливается при создании нового экземпляра
        класса
    </li>
    <li>
        его <b>видимость</b>, принимающую одно из следующих значений: 
        <ul>
            <li>
                <b>Public</b>: атрибут видим и внутри, и снаружи пакета, который содержит класс
            </li>
            <li>
                <b>Protected</b> : атрибут видим только самому классу, его подклассам и друзьям класса (зависит от языка)
            </li>
            <li>
                <b>Private</b> : атрибут видим только самому классу и друзьям класса
            </li>
            <li>
                <b>Implementation</b> : атрибут видим только самому классу
            </li>
        </ul>
    </li>
    <li>
        для постоянных <b>постоянных классов</b>, является ли атрибут постоянным (по умолчанию) или временным. Даже если
        сам класс является постоянным, не все его атрибуты должны быть постоянными.
    </li>
</ul>
<p>
    Проверьте, все ли атрибуты необходимы. Наличие атрибута должно быть оправдано. Часто из-за невнимательности атрибуты,
    добавленные ранее, продолжают существовать, даже если они больше не нужны. Лишние атрибуты, помноженные на тысячи или
    миллионы экземпляров, могут пагубно повлиять на производительность и ресурсы системы.
</p>
<p>
    Более подробная информация об атрибутах находится в разделе, названном <i>Атрибуты</i>, в <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_class_E98280BF.html" guid="2.914882084937444E-305">Рекомендации по рабочему продукту: Класс проекта</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение зависимостей </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Dependencies" name="Define Dependencies"></a>
<p>
    В каждом случае, когда требуется обеспечить связь между объектами, ответьте на следующие вопросы:
</p>
<ul>
    <li>
        Должна ли ссылка на получателя передаваться в качестве параметра в операцию? Если да, то установите
        <b>зависимость</b> между классами отправителя и получателя на диаграмме классов, содержащей эти два класса. Также,
        если для взаимодействий используется формат <b>диаграммы связи</b>, то укажите видимость ссылки и установите для
        нее значение <b>параметр</b>.
    </li>
    <li>
        Является ли получатель глобальным? Если да, то установите <b>зависимость</b> между классами отправителя и
        получателя на диаграмме классов, содержащей эти два класса. Также, если для взаимодействий используется формат
        <b>диаграммы связи</b>, то укажите видимость ссылки и установите для нее значение <b>глобальная</b>.
    </li>
    <li>
        Является ли получатель временным объектом, создаваемым и уничтожаемым в самой операции? Если да, то установите
        <b>зависимость</b> между классами отправителя и получателя на диаграмме классов, содержащей эти два класса. Также,
        если для взаимодействий используется формат <b>диаграммы связи</b>, то укажите видимость ссылки и установите для
        нее значение <b>локальная</b>.
    </li>
</ul>
<p>
    Заметьте, что моделируемые таким образом ссылки являются временными ссылками, которые существуют ограниченный период
    времени в определенном контексте кооперации. В этом смысле, они являются экземплярами роли связи в кооперации. Однако,
    взаимосвязь в модели класса (то есть, независимая от контекста) должна являться зависимостью, как это указано выше. Как
    указано в [<a class="elementLinkWithUserText" href="./../../core.base_rup/customcategories/references_56F06DFD.html#RUM98" guid="7.755968586980351E-308">RUM98</a>] в определении <b>временной связи</b>: "Все такие ссылки возможно моделировать
    как связи, но тогда условия связи должны быть указаны явно, и они теряют в своей точности в ограничивающих комбинациях
    объектов". В такой ситуации, моделирование зависимости менее важно, чем моделирование взаимосвязи в кооперации, потому
    что зависимость не описывает взаимосвязь полностью, а только указывает на ее существование.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение связей </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Associations" name="Define Associations"></a><a id="Define Attributes and Relationships" name="Define Attributes and Relationships"></a>
<p>
    Связи предоставляют механизм коммуникации между объектами. Они обеспечивают объекты каналом, по которому могут
    передаваться сообщения. Они также документируют зависимости между классами, выделяя то, как изменения в одном классе
    могут повлиять на другие классы.
</p>
<p>
    Просмотрите описания <b>методов</b> для каждой операции, чтобы понять, как экземпляры класса связаны и взаимодействуют
    между собой. Для того чтобы послать сообщение в другой объект, данный объект должен иметь ссылку на получателя
    сообщения. Диаграмма связи (альтернативное представление диаграммы схемы связей) показывает связи объекта в терминах
    ссылок, как показано на Рисунке 3.
</p>
<p align="center">
    <img src="./../../core.base_rup/tasks/resources/collabd.gif" width="610" height="493" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Рисунок 3: В диаграммы связи
</p>
<h4>
    <a id="Defining associations and aggregations" name="Defining associations and aggregations">Определение связей и
    объединений</a>
</h4>
<p>
    Оставшиеся сообщения задают взаимосвязь между экземплярами двух классов или с помощью <b>связи</b>, или с помощью
    <b>объединения</b>. Для выбора подходящего представления изучите разделы <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/association_98710829.html" guid="5.540135518285335E-305">Прием: Связь</a> и <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/aggregation_A53E33AB.html" guid="1.1538495077622037E-304">Прием: Объединение</a>. Для обеих этих связей установите на диаграмме связи видимость
    <b>поле</b>. Другие задачи:
</p>
<ul>
    <li>
        Установите свойство Инициатива для связей и объединений. Это можно сделать, принимая во внимание, что свойство
        Инициатива требуется для создания экземпляров их ссылок на диаграмме взаимодействий. Так как по умолчанию значение
        свойства Инициатива равно <b>true</b>, необходимо только найти связи (и объединения), для которых роли всех
        объектов класса на другом конце ссылки в этой связи не требуют этого свойства. В таких случаях, установите значение
        свойства Инициатива равным <b>false</b> для роли класса.
    </li>
    <li>
        Если в самой связи существуют атрибуты, создайте класс проекта для представления класса связи с соответствующими
        атрибутами. Поместите этот класс между двумя другими классами и установите связи с соответствующей множественностью
        между классом связи и двумя другими классами.
    </li>
    <li>
        Укажите, должны ли <i>концы связи</i> быть <b>упорядоченными</b> или нет. В этом случае связь объектов должна иметь
        упорядочение.
    </li>
    <li>
        Если на связанный (или объединенный) класс ссылается только текущий класс, решите, должен ли он быть вложенным.
        Преимущества вложения классов состоят в более быстром обмене сообщениями и простоте модели проекта. Недостатки
        включают в себя статическое выделение памяти для вложенного класса, независимо от того, существуют ли его
        экземпляры или нет, невозможность определения объекта отдельно от включающего класса, невозможность ссылки на
        экземпляры вложенного класса снаружи включающего класса.
    </li>
</ul>
<p>
    Связи и объединения удобнее всего определять на диаграмме классов, на которой изображены связанные классы. Диаграмма
    классов должна <b>принадлежать</b> пакету, который содержит связанные классы. На Рисунке 4 показан пример диаграммы
    классов, изображающей связи и объединения.
</p>
<p align="center">
    <img src="./../../core.base_rup/tasks/resources/classdg.gif" width="469" height="396" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Рисунок 4: Пример диаграммы классов, показывающей связи, объединения и обобщения между классами.
</p>
<h4>
    <a id="Handling Subscribe-Associations between Analysis Classes" name="Handling Subscribe-Associations between Analysis Classes">Управления связями-подписками между классами
    анализа</a>
</h4>
<p>
    Связи-подписки между <b>классами анализа</b> используются для определения зависимостей событий между классами. В Модели
    проекта необходимо управлять этими зависимостями событий явно, или с помощью доступных структур описателей событий, или
    с помощью проектирования и построения своей собственной структуры описателей событий. В некоторых языках
    программирования, таких как Visual Basic, это можно сделать непосредственно: вы определяете соответствующие события и
    управляете ими. В других языках, можно использовать некоторую дополнительную библиотеку для многократно используемых
    функций, чтобы управлять подписками и событиями. Если требуемую функциональность невозможно приобрести, ее необходимо
    спроектировать и реализовать. См. также раздел <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/subscribe-association_1AB75163.html" guid="1.401846671640991E-305">Прием:
    Связь-подписка</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение внутренней структуры </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Internal Structure" name="Define Internal Structure"></a>
<p>
    Некоторые классы могут представлять сложные абстракции и иметь сложную структуру. При моделировании класса
    проектировщик может представить его внутренние элементы и их взаимосвязи, для того чтобы они были реализованы внутри
    класса соответствующим образом.
</p>
<p>
    В UML 2.0 классы определяются как <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/termdefinitions/structured_class_4BB99B12.html" guid="_yW3E4NnmEdmO6L4XMImrsA">структурные
    классы</a>, способные иметь внутреннюю структуру и порты. Таким образом, классы могут быть разложены на набор связанных
    компонентов, которые, в свою очередь, могут быть разложены. Класс может быть инкапсулирован принудительными связями
    снаружи для передачи через порты в соответствии с объявленными интерфейсами.
</p>
<p>
    Когда вы обнаружите класс со сложной структурой, создайте для него составную структурную диаграмму. Смоделируйте
    компоненты, выполняющие определенные роли в поведении класса. Установите связи между компонентами с помощью
    коннекторов. Используйте порты с объявленными интерфейсами, если вы хотите позволить другим клиентам этого класса иметь
    доступ к определенным частям функциональности, предложенной классом. Также используйте порты для полной изоляции
    внутренних компонентов класса от среды.
</p>
<p>
    Более подробная информация и примеры составных структурных диаграмм находятся в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">Концепция: Структурные классы</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определение обобщений </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Generalizations" name="Define Generalizations"></a>
<p>
    Классы могут быть организованы в иерархию обобщений, отражающую общее поведение и общую структуру. Может быть определен
    <b>суперкласс</b>, от которого <b>подклассы</b> наследуют как поведение, так и структуру. Обобщение - это удобное
    обозначение, которое позволяет определять общую структуру и поведение в одном месте, и применять его при повторяющемся
    поведении и структуре. Более подробная информация об отношениях обобщения находится в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/generalization_94751549.html" guid="1.839540980397304E-305">Прием: Обобщение</a>.
</p>
<p>
    Когда вы обнаружите обобщение, создайте общий суперкласс, содержащий общие атрибуты, связи, объединения и операции.
    Удалите общее поведение из классов, которые станут подклассами этого общего суперкласса. Определите <b>отношение
    обобщения</b> между подклассом и суперклассом.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Обработка конфликтов вариантов использования</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_concurrency_conflicts__identifying" name="XE_concurrency_conflicts__identifying"></a><a id="Resolve Use-Case Collisions" name="Resolve Use-Case Collisions"></a>
<p>
    Цель этого шага состоит в предотвращении конфликтов параллелизма, возникающих в ситуации, когда два или несколько
    вариантов использования потенциально могут одновременно получить доступ к экземплярам класса проекта противоречивым
    образом.
</p>
<p>
    Одной из трудностей разработки вариантов использования один за другим в процессе проектирования является возможность
    одновременного вызова двумя или несколькими вариантами использования операций объектов проекта потенциально
    противоречивым образом. В таких случаях, конфликты параллелизма должны быть установлены и разрешены явно.
</p>
<p>
    Если используется синхронный обмен сообщениями, то выполнение операции заблокирует последующие вызовы объектов до ее
    завершения. Синхронный обмен сообщениями предполагает порядок обработки сообщений первый-пришел-первый-обслужен. Это
    может разрешить конфликт параллелизма, особенно в случаях, когда все сообщения имеют одинаковый приоритет, или когда
    все сообщения принадлежат одной нити выполнения. В случаях, когда к одному объекту имеют доступ разные нити управления
    (представленные активными классами), должны использоваться явные механизмы предотвращения или разрешения конфликтов
    параллелизма.
</p>
<p class="reactive">
    В системах реального времени, где нити представлены с помощью <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Рабочий
    продукт: Капсула</a>, эта проблема также может быть решена для множественного параллельного доступа к пассивным
    объектам, поскольку сами капсулы предоставляют механизм очередей и для управления параллельным доступом осуществляют
    семантику выполнять-до-завершения. Рекомендуется инкапсулировать пассивные объекты в капсулы, что позволяет избежать
    проблемы параллельного доступа с помощью семантики самих капсул.
</p>
<p>
    Разные операции одного и того же объекта могут быть вызваны одновременно различными нитями управления без конфликта
    параллелизма. Имя и адрес клиента могут быть изменены параллельно без конфликта. Только когда две разные нити
    управления пытаются изменить одно и то же свойство объекта, возникает конфликт.
</p>
<p>
    Для каждого объекта, к которому могут параллельно получить доступ различные нити управления, определите разделы
    исходного кода, которые должны быть защищены от одновременного доступа. На фазе Уточнения определение определенных
    сегментов кода будет невозможна. Далее, выберите или спроектируйте подходящие механизмы управления доступом для
    предотвращения одновременного доступа. Примерами таких механизмов являются организация очереди сообщений с целью
    сделать доступ последовательным, использование семафоров или маркеров с целью разрешить доступ только одной нити в один
    момент времени, или другие варианты механизмов блокировки. Выбор механизма сильно зависит от реализации и обычно
    меняется в зависимости от языка программирования и операционной среды. Рекомендации по выбору механизмов параллелизма
    можно найти в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рекомендации, относящиеся к проекту</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Общее управление нефункциональными требованиями </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_nonfunctional_requirements__handling_of" name="XE_nonfunctional_requirements__handling_of"></a><a id="Handle Non-Functional Requirements" name="Handle Non-Functional Requirements"></a> 
<p>
    Классы проекта уточняются для общего управления нефункциональными требованиями. Важным входом этого шага являются
    нефункциональные требования к классу анализа, которые уже могут быть указаны в специальных требованиях и обязанностях.
    Такие требования часто задаются в терминах архитектурных механизмов (анализа), которые необходимы для реализации
    класса. На этом шаге класс уточняется для включения механизмов проекта, соответствующих этим механизмам анализа.
</p>
<p>
    Доступные механизмы проекта идентифицируются и характеризуются разработчиком программного обеспечения. Для каждого
    требуемого механизма укажите как можно больше параметров, задавая диапазоны, там где это необходимо. Более подробная
    информация о механизмах проекта находится в разделах <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}">Задача:
    Определение механизмов проекта</a>, <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/analysis_mechanisms_36135B43.html" guid="9.76539014099254E-305">Концепция:
    Механизмы анализа</a> и <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/design_and_implementation_mechanisms_A37EAC7D.html" guid="6.131233324119695E-305">Концепция: Механизмы проекта и реализации</a>.
</p>
<p>
    Есть несколько общих рекомендаций по проекту и механизмам, которые необходимо принять во внимание при проектировании
    классов. Они касаются того, как:
</p>
<ul>
    <li>
        использовать существующие продукты и компоненты
    </li>
    <li>
        адаптировать к языку программирования
    </li>
    <li>
        распределить объекты
    </li>
    <li>
        достигнуть приемлемой производительности
    </li>
    <li>
        достигнуть определенного уровня защиты
    </li>
    <li>
        управлять ошибками
    </li>
</ul></td>
</tr>
</table>
</div>
<div class="stepHeading"> Оценка результатов </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Evaluate Your Results" name="Evaluate Your Results"></a> 
<p>
    На этом этапе проверьте, направлена ли ваша работа над моделью проекта в нужном направлении. Не обязательно
    просматривать все подробности модели, но необходимо рассмотреть следующее:
</p>
<ul>
    <li>
        <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/design_model_18BE347C.html" guid="1.4639852935143625E-305">Модель проекта</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/design_class_436B6210.html" guid="1.1028389988231071E-306">справочная таблица для классов проекта</a>
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Свойства</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Несколько вхождений" abbr="Несколько вхождений">Несколько вхождений</th><td align="left" class="sectionTableCell" headers="property_Несколько вхождений"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Управляется событиями" abbr="Управляется событиями">Управляется событиями</th><td align="left" class="sectionTableCell" headers="property_Управляется событиями"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Выполняющийся" abbr="Выполняющийся">Выполняющийся</th><td align="left" class="sectionTableCell" headers="property_Выполняющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Необязательный" abbr="Необязательный">Необязательный</th><td align="left" class="sectionTableCell" headers="property_Необязательный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Запланированный" abbr="Запланированный">Запланированный</th><td align="left" class="sectionTableCell" headers="property_Запланированный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Повторяющийся" abbr="Повторяющийся">Повторяющийся</th><td align="left" class="sectionTableCell" headers="property_Повторяющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
					contentPage.onload();
					contentPage.processPage.fixDescriptorLinks();
				</script>
</html>
