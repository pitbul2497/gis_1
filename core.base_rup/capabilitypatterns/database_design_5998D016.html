<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Дескриптор задачи: Проектирование базы данных</title>
<meta content="TaskDescriptor" name="uma.type">
<meta content="database_design" name="uma.name">
<meta content="Проектирование базы данных" name="uma.presentationName">
<meta content="_2Bsr0EocEdqrjq4i3fchvA" name="uma.guid">
<meta content="TaskDescriptor" name="element_type">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ActivityTreeTable.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ProcessElementPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/processElementData.js"></script><script language="JavaScript" type="text/javascript">
					var defaultQueryStr = '?proc={002674F9-6511-4D15-8623-B761D8C48986}&path={002674F9-6511-4D15-8623-B761D8C48986},{FB3EB753-A979-4849-B57B-97F39271F82B},_2Bsr0EocEdqrjq4i3fchvA';
					var backPath = './../../';
					var imgPath = './../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo, defaultQueryStr, true, true, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top">
<div id="page-guid" value="_2Bsr0EocEdqrjq4i3fchvA"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Дескриптор задачи: Проектирование базы данных</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../images/taskdes_lg_dgm32.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Эта задача объясняет способ проектирования базы данных для реализации хранилища в приложении.</td>
</tr>
<tr>
<td>На основе задачи метода: <a href="./../../core.base_rup/tasks/database_design_8552DD3.html" guid="{2E74A414-49F5-4F27-BFCB-AA2DAC675F58}">Проектирование базы данных</a></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Роли</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Главный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_database_designer_B5A44B1E.html" guid="_pOsigTbYEdqdbfmtFQj8qA">Проектировщик базы данных</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Дополнительно:
								</span></td><td class="sectionTableCell"><span class="sectionTableCellHeading">Помощь:
								</span></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Входы</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Обязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_class_E1A6A499.html" guid="_Day3gL7XEdqboqO8QqaIwQ">Проектирование класса</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Необязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_supplementary_specification_F9C7C5E1.html" guid="_oAeb4jbYEdqdbfmtFQj8qA">Дополнительные спецификации</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_B47A47A8.html" guid="_mju5QL9dEdqBwpaAk4N49g">Класс анализа</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_45E0F882.html" guid="_m-5LQL9dEdqBwpaAk4N49g">Класс анализа</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_data_model_A43D5F34.html" guid="_pOsigjbYEdqdbfmtFQj8qA">Модель данных</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_465A5F1.html" guid="_oAeb4zbYEdqdbfmtFQj8qA">Модель проекта</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_project_specific_guidelines_286E840C.html" guid="_CPHNtxi2Edq_uI8xTPML6g">Рекомендации по проекту</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">Внешний:
								</span>
<ul>
<li>Нет</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Выходы</th><td colspan="3" class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_data_model_A43D5F34.html" guid="_pOsigjbYEdqdbfmtFQj8qA">Модель данных</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Шаги</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr>
<td class="sectionTableCell">
<div class="stepHeading"> Разработка логической модели данных (необязательно) </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Develop Logical Data Model" name="Develop Logical Data Model"></a>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Определите логическую модель проекта базы данных.
            </td>
        </tr>
    </table>
</div>
<p>
    Логическая модель данных предназначена для идеализированного представления ключевых логических сущностей данных и их
    взаимосвязей, независимых от реализации с помощью конкретного программного обеспечения и базы данных. В общем случае,
    это является третьей нормальной формой (см. <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/normalization_47199FE9.html" guid="3.183357382287462E-306">Концепция:
    Нормализация</a>), т.е. формой моделирования данных, которая минимизирует избыточность и обеспечивает отсутствие
    транзитивных зависимостей. Такая модель относится к представлению базы данных во время сбора данных, а не к
    приложениям, использующим данные, и их производительности. Заметьте, что Логическая модель данных считается частью <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_data_model_65B46980.html" guid="{9DCF1723-1A21-4F48-BEDE-DBC543489682}">Рабочий продукт: Модель данных</a>, а не отдельным рабочим продуктом RUP.
    Однако, часто бывает важно определять Логические модели данных для:
</p>
<ul>
    <li>
        проектов, в которых база данных и приложение разрабатываются разными коллективами.
    </li>
    <li>
        проектов, содержащих несколько приложений, которые используют общую базу данных.
    </li>
</ul>
<p>
    Создание Логической модели данных можно начать с нуля, используя элементы модели, описанные в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/data_model_80FB2539.html" guid="3.4196799396281445E-306">Рекомендации по рабочему продукту: Модель данных</a>, или можно начать с помощью
    сущностей для каждого постоянного класса в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_analysis_model_76C3B70C.html" guid="{98EA224C-36F6-46E6-AB36-2999382B58B3}">Модели
    анализа</a> или <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Модели проекта</a>.
</p>
<p>
    Можно не создавать отдельной Логической модели данных, особенно при проектировании базы данных, которая обслуживает
    единственное приложение. В этом случае, <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">Проектировщик базы данных</a> разрабатывает Физическую модель данных на
    основании набора постоянных классов и их связей в Модели проекта.
</p>
<p>
    При каждом из этих подходов важно, чтобы <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">Проектировщик базы данных</a> и <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Проектировщик</a>
    сотрудничали в процессе анализа и проектирования, идентифицируя классы в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Рабочий
    продукт: Модель проекта</a>, которые должны сохранять информацию в базе данных. Как описано в шаге под названием
    "Определение постоянных классов" в <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/class_design_98F20FF9.html" guid="{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}">Задача:
    Проектирование класса</a>, проектировщик базы данных совместно с разработчиком идентифицируют те <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_class_B33BD5E5.html" guid="{952A9CE9-D5A3-43AC-980D-0B9298F3872E}">классы проекта</a> в Модели проекта, которые считаются постоянными и
    потенциально могут стать таблицами базы данных.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Разработка проекта физической базы данных </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Develop Physical Data Model" name="Develop Physical Data Model"></a>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Определить подробный проект физической базы данных.
            </td>
        </tr>
    </table>
</div>
<p>
    Проект физической базы данных включает в себя элементы модели (такие как таблицы, представления и хранимые процедуры),
    которые представляют подробную физическую структуру базы данных, и элементы модели (такие как схемы и табличные
    пространства), которые представляют лежащий в основе базы данных механизм хранения данных. &nbsp; Вместе эти элементы
    модели заключают в себе Физическую модель данных базы данных. &nbsp; Эта Физическая модель данных содержится в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_data_model_65B46980.html" guid="{9DCF1723-1A21-4F48-BEDE-DBC543489682}">Рабочий продукт: Модель данных</a>, а не является отдельным рабочим
    продуктом модели.
</p>
<p>
    Подробные шаги по разработке проекта физической базы данных состоят в следующем:
</p>
<ul>
    <li>
        <a href="#Define Domains">Определение доменов</a>.
    </li>
    <li>
        <a href="#Transform Persistent Design Elements to the Physical Data Model">Создание начальных
        элементов проекта физической базы данных</a>.
    </li>
    <li>
        <a href="#Define Reference Tables and Default Values">Определение справочных таблиц</a>.
    </li>
    <li>
        <a href="#Create Primary Key and Unique Key Constraints">Создание первичного ключа ограничений
        уникальности</a>.
    </li>
    <li>
        <a href="#Define Data and Referential Integrity Enforcement Rules">Определение данных и правил
        ссылочной целостности</a>.
    </li>
    <li>
        <a href="#Optimize the Data Model for Performance">Денормализация проекта базы данных для оптимизации
        производительности</a>.
    </li>
    <li>
        <a href="#Optimize Data Access">Оптимизация доступа к данным</a>.
    </li>
    <li>
        <a href="#Define Storage Characteristics">Определение параметров хранения</a>.
    </li>
    <li>
        <a href="#Distribute Class behavior to the Database">Проектирование хранимых процедур для реализации
        поведения класса в базе данных</a>.
    </li>
</ul>
<h4>
    <a id="Define Domains" name="Define Domains">Определение доменов</a>
</h4>
<table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)" bordercolorlight="#808080" bordercolordark="#808080">
    <tr>
        <td width="5%">
            <b>Цель</b>
        </td>
        <td width="95%">
            Определить многоразовые пользовательские типы.&nbsp;
        </td>
    </tr>
</table>
<p>
    Проектировщик базы данных может использовать домены для введения стандартных типов в проект базы данных. Домены
    являются пользовательскими типами данных, которые могут принимать столбцы таблиц. &nbsp; Домены имеют свойства столбца
    без имени. &nbsp;
</p>
<h4>
    <a id="Transform Persistent Design Elements to the Physical Data Model" name="Transform Persistent Design Elements to the Physical Data Model">Создание начальных элементов проекта физической
    базы данных</a>
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Создать начальные таблицы базы данных и их взаимосвязи.
            </td>
        </tr>
    </table>
</div>
<p>
    Проектировщик базы данных создает элементы Физической модели данных с помощью таблиц и столбцов таблиц, как это описано
    в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/data_model_80FB2539.html" guid="3.4196799396281445E-306">Рекомендации по рабочему продукту: Модель данных</a>.&nbsp;
</p>
<p>
    Если создана Логическая модель данных, то ее логические сущности могут использоваться в качестве основы для начального
    набора таблиц.
</p>
<p>
    В качестве альтернативы, проектировщик базы данных может начать разработку Физической модели данных с использования
    постоянных классов Модели проекта в качестве исходной точки для таблиц Физической модели данных. &nbsp; Проектировщик
    базы данных моделирует постоянные классы и их атрибуты как&nbsp; таблицы и столбцы соответственно. &nbsp; Проектировщик
    базы данных должен также определить взаимосвязи между таблицами на основании связей между постоянными классами Модели
    проекта. &nbsp; Описание того, как элементы Модели проекта и их взаимосвязи соотносятся элементами Модели данных и их
    взаимосвязями, предоставлено в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/forward-engineering_relational_databases_53C0441E.html" guid="5.250868507423771E-305">Рекомендации по рабочему продукту: Прямое проектирование реляционных баз данных</a>.
</p>
<p>
    Если вы начинаете моделирование с постоянных классов, а не с нормализованной Логической модели данных, тогда необходимо
    произвести нормализацию, для того чтобы исключить избыточность данных и зависимости неключевых полей. Более подробная
    информация о нормализации базы данных в находится разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/normalization_47199FE9.html" guid="3.183357382287462E-306">Концепция:
    Нормализация</a>.
</p>
<h4>
    <a id="Define Reference Tables and Default Values" name="Define Reference Tables and Default Values">Определение
    справочных таблиц</a>.
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Определить стандартные справочные таблицы, используемые в проекте.
            </td>
        </tr>
    </table>
</div>
<p>
    Часто существуют стандартные таблицы поиска, проверочные таблицы и справочные таблицы, которые используются повсюду в
    проекте. Так как данные в этих таблицах часто используются, но редко меняются, они заслуживают особого внимания. В
    Модели проекта эти таблицы могут содержать стандартные коды продукта, коды областей и населенных пунктов, почтовые
    индексы, тарифы и другую часто используемую информацию. В финансовых системах эти таблицы могут содержать списки кодов
    стратегий, категории стратегий страхования или курсы обмена. Найдите в Модели проекта классы, которые используются
    преимущественно для чтения, предоставляя проверочную информацию для большого количества клиентов.
</p>
<p>
    Если справочная таблица мала, не стоит ее индексировать, так как индекс может фактически создать дополнительную
    нагрузку для небольших таблиц. Маленькую часто используемую таблицу лучше хранить в памяти, потому что алгоритмы
    хеширования стремятся сохранять в кэше данных таблицы, к которым часто осуществляется доступ.
</p>
<p>
    Если возможно, обеспечьте, чтобы кэш базы данных был достаточно большим для хранения в памяти всех справочных таблиц
    наряду с обычным "пространством рабочего набора" для запросов и транзакций. Часто ключ к увеличению производительности
    базы данных состоит в уменьшении дискового ввода/вывода.
</p>
<p>
    После определения структуры справочных таблиц, определите стратегию их заполнения. Так как доступ к этим таблицам
    осуществляется с самого начала работы над проектом, часто бывает необходимо определить справочные значения и загрузить
    таблицы на относительно ранних этапах выполнения приложения. В то время как проектировщик базы данных не обязан
    получать данные, он обязан определить, как и когда справочные таблицы будут обновляться.
</p>
<h4>
    <a id="Create Primary Key and Unique Key Constraints" name="Create Primary Key and Unique Key Constraints">Создание
    первичного ключа ограничений уникальности</a>
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Определить один или несколько столбцов, которые однозначно идентифицируют строку в таблице.<br />
                Определить ограничения столбцов, которые обеспечивают уникальность данных или наборов данных.
            </td>
        </tr>
    </table>
</div>
<p>
    Первичный ключ - это один или несколько столбцов, которые однозначно идентифицируют строки в таблице. Таблица имеет
    единственный первичный ключ. Часто существует "естественный" ключ, который может быть использован для однозначной
    определения строки данных (например, почтовый код в справочной таблице). Первичный ключ не должен содержать данных,
    которые могут быть изменены в бизнес-среде. Если "естественный" ключ - это значение, которое может быть изменено
    (например, имя человека), тогда проектировщику базы данных рекомендуется создать для первичного ключа отдельный
    бессмысленный столбец, значения в который не вводятся пользователем. &nbsp;Это создает структуру данных, которая легче
    адаптируется к изменениям в бизнес-структуре, правилах и среде.
</p>
<p>
    Использование в качестве первичного ключа бессмысленного столбца, значения в который вносятся не пользователем,
    является неотъемлемой концепцией в проектировании хранилищ данных. Системы, в работе которых применяются транзакции,
    часто предпочитают использовать "естественный" первичный ключ, а не бессмысленный столбец, значения в который вносятся
    не пользователем.
</p>
<p>
    Ограничение уникальности указывает на то, что данные каждой строки в столбце или в наборе столбцов являются
    уникальными. Если ограничение уникальности относится к столбцу, то данные в определенной строке этого столбца должны
    быть уникальными среди данных других строк этого же столбца. &nbsp;
</p>
<p>
    Когда ограничение уникальности определено для группы столбцов, уникальность основана на совокупности данных в этих
    столбцах. Данные в определенной строке определенного столбца не обязательно должны быть уникальными среди данных других
    строк этого же столбца. Проектировщик базы данных применяет ограничение уникальности для обеспечения уникальности
    бизнес-данных.
</p>
<h4>
    <a id="Define Data and Referential Integrity Enforcement Rules" name="Define Data and Referential Integrity Enforcement Rules">Определение данных и правил ссылочной целостности</a>
</h4>
<table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)" bordercolorlight="#808080" bordercolordark="#808080">
    <tr>
        <td width="5%">
            <b>Цель</b>
        </td>
        <td width="95%">
            Обеспечить целостность базы данных.
        </td>
    </tr>
</table>
<p>
    Правила целостности данных, которые также называются ограничениями, обеспечивают принадлежность значений данных
    определенным диапазонам. В базе данных эти диапазоны применяются там, где это возможно. (Это означает не то, что
    проверка данных не должна производиться в приложении, а то, что база данных может служить средством проверки
    "последнего звена", если приложение не работает правильно.) Там, где существуют правила проверки данных, их должны
    осуществлять ограничения базы данных.
</p>
<p>
    Внешний ключ - это один или несколько столбцов, которые соответствуют первичному ключу другой таблицы. Одна таблица
    может иметь несколько внешних ключей, которые соответствуют разным таблицам. Это соответствие или взаимосвязь между
    таблицами часто называется родительско-дочерним отношением. &nbsp;Дочерняя таблица содержит внешний ключ, который
    соответствует первичному ключу родительской таблицы. &nbsp;
</p>
<p>
    Определение ограничения по внешнему ключу также часто используется оптимизатором запросов для повышения
    производительности запроса. &nbsp; Во многих случаях правила внешнего ключа применяют справочные таблицы.
</p>
<h4>
    <a id="Optimize the Data Model for Performance" name="Optimize the Data Model for Performance">Денормализация проекта
    базы данных для оптимизации производительности</a>.
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Оптимизировать структуры данных для повышения производительности.
            </td>
        </tr>
    </table>
</div>
<p>
    В случае реляционной Модели данных, начальное преобразование обычно является простым преобразованием класс-таблица.
    Если необходимо одновременно извлекать объекты из разных классов, то RDBMS применяет операцию, которая называется
    "соединение таблиц", для того чтобы получить строки, относящиеся к интересуемым объектам. При частом доступе к данным
    операции соединения могут потребовать слишком много вычислительных ресурсов. Для уменьшения затрат на обработку
    соединения часто применяется стандартный прием под названием "денормализация".
</p>
<p>
    При денормализации столбцы из двух или нескольких разных таблиц комбинируются в одной таблице для эффективного
    предварительного соединения информации. Денормализация отражает компромисс между более затратными операциями изменения
    данных и менее затратными операциями извлечения данных. Этот прием также уменьшает производительность системы при
    обработке запросов, в которых требуются только атрибуты одного из объектов, соединенных в денормализованной таблице,
    так как каждый запрос обычно извлекает все атрибуты. Для случаев, в которых приложение требует все атрибуты, этим может
    быть достигнут значительный выигрыш в производительности.
</p>
<p>
    Денормализация более двух таблиц используется редко и увеличивает затраты на обработку операций добавления и изменения
    данных, а также несоединенных запросов. Ограничение денормализации до двух таблиц является хорошей стратегией, если нет
    весомой и убедительной причины поступить иначе.
</p>
<p>
    Денормализация может быть выведена из <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_class_B33BD5E5.html" guid="{952A9CE9-D5A3-43AC-980D-0B9298F3872E}">классов
    проекта</a>, когда классы являются вложенными. Вложенные классы могут быть преобразованы в денормализованную таблицу.
</p>
<p>
    Некоторые базы данных позволяют осуществлять операцию, подобную денормализации, в которой связанные объекты
    кластеризуются вместе на диске и извлекаются одной операцией. Эта концепция используется подобным образом: уменьшается
    время извлечения объекта с помощью уменьшения объема работы, необходимого системе для извлечения связанных объектов из
    базы данных.
</p>
<p>
    В некоторых случаях, оптимизация Модели данных может обнаружить проблемы в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Модели
    проекта</a>, включая узкие места производительности, плохое моделирование или неполноту проекта. В этом случае,
    обсудите проблемы с <a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Проектировщиком</a> класса, инициируя соответствующие изменения.
</p>
<h4>
    <a id="Optimize Data Access" name="Optimize Data Access">Оптимизация доступа к данным</a>
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Предоставить эффективный доступ к данным с помощью индексации.<br />
                Предоставить эффективный доступ к данным с помощью представлений.
            </td>
        </tr>
    </table>
</div>
<p>
    После проектирования структуры таблиц необходимо определить типы запросов, которые будут выполняться над данными. Для
    повышения скорости доступа в базе данных применяется индексация. Индексация наиболее эффективна, когда значения данных
    в индексируемом столбце относительно различны.
</p>
<p>
    Рассмотрим следующие принципы индексации:
</p>
<ul>
    <li>
        Столбец первичного ключа таблицы всегда должен быть индексированным. Столбцы первичного ключа часто используются
        как ключи поиска и для операций соединения.
    </li>
    <li>
        Таблицы, имеющие не более 100 строк и несколько столбцов, мало выигрывают от индексации. Малые таблицы легче
        хранить в кэше базы данных.
    </li>
    <li>
        Индексы также следует определить для часто исполняемых запросов или для запросов, которые должны быстро получать
        данные (в общем случае, любой поиск выполняется, пока человек может подождать). Индекс должен быть определен для
        каждого набора атрибутов, которые используются вместе как критерии поиска. Например, если система должна иметь
        возможность находить все Заказы, в которые включен определенный продукт, необходим индекс в таблице Строка заказа
        для столбца номера продукта.
    </li>
    <li>
        Обычно индексы необходимо определять только для столбцов, которые используются как идентификаторы, и которые имеют
        нечисловые данные, такие как сальдо счета, и не текстовую информацию, такую как комментарии к заказу. Значения
        столбца идентификатора обычно назначаются при создании объекта, а затем остаются неизменными на протяжении всего
        жизненного цикла объекта.
    </li>
    <li>
        Индексы над простыми числами (целыми и числовыми типами данных) намного проще и быстрее, чем индексы над строками.
        Даже большие объемы данных в запросе или большом соединении обрабатываются быстро. &nbsp; Индексы над числовыми
        столбцами обычно занимают намного меньше пространства, чем индексы над символьными столбцами.
    </li>
</ul>
<p>
    Использование индексов имеет и негативную сторону: чем больше индексов в таблице, тем дольше происходят операции
    добавления и изменения данных. Рассматривая варианты использования индексов, не забудьте о следующих предосторожностях:
</p>
<ul>
    <li>
        Не создавайте индекса для повышения скорости обработки редко выполняющегося запроса, только если он не выполняется
        в критической точке, где скорость существенна.
    </li>
    <li>
        В некоторых системах производительность операций добавления и изменения данных более важна, чем производительность
        запроса. Обычным примером являются приложения сбора данных предприятия, в котором данные собираются в реальном
        времени. В этих системах редко выполняются диалоговые запросы, а большая часть данных периодически анализируется
        пакетными приложениями, составляющими отчеты и выполняющими статистический анализ над этими данными. В системах
        сбора данных удалите все индексы для достижения максимальной производительности. Если индексы необходимы, они могут
        быть построены непосредственно перед выполнением приложений, которые выполняют анализ и пакетное составление
        отчетов, а после их завершения удалены.
    </li>
    <li>
        Всегда помните, что индексы имеют скрытые затраты на обработку. Например, они забирают время на изменение данных
        (при каждой операции вставки, изменения и удаления) и занимают дисковое пространство. Убедитесь в том, что имеет
        смысл их использовать.
    </li>
</ul>
<p>
    Многие базы данных предоставляют выбор типов индексов. Наиболее распространенными из них являются:
</p>
<ul>
    <li>
        <b>Индексы B-tree</b> - Наиболее часто используемый вид индекса, основанный на структуре данных сбалансированного
        дерева b-tree. Они полезны, когда значения ключа индекса случайно распределены и имеют сильное разнообразие.
        Однако, они имеют низкую производительность, когда индексированные данные уже упорядочены.
    </li>
    <li>
        <b>Хэшированные индексы</b> - Менее используемые индексы, значения ключа которых хешированы. Хеширование
        обеспечивает лучшую производительность, когда диапазон значений ключа индекса известен, уникален и относительно
        неизменен. Эта техника полагается на использование значения ключа для вычисления адреса интересуемых данных. Так
        как необходима предсказуемость, хэшированные индексы полезны только для таблиц поиска среднего размера, которые
        очень редко изменяются.
    </li>
</ul>
<p>
    Выбор стратегии индексации и времени создания индексов оказывает большое влияние на производительность. Загрузка
    большого количества данных должна осуществляться без индексов (этого можно достичь, <b>удалив</b> индекс перед
    загрузкой данных, а после нее создав его снова). Причина этого состоит в том, что структура индекса балансируется
    заново при добавлении каждой строки. Так как последующие строки будут изменять структуру индекса, работа по
    балансировке индекса при добавлении каждого столбца является очень затратной. Более быстрый и эффективный способ
    состоит в загрузке данных без индексов с последующим повторным созданием индексов. В некоторых базах данных
    предоставлены загрузчики больших объемов данных, чтобы это делалось автоматически.
</p>
<p>
    Другая стратегия для оптимизации скорости доступа к базе данных состоит в использовании представлений. Представления
    базы данных - это виртуальные таблицы, которые не имеют собственного независимого дискового пространства. Однако, для
    вызывающей программы (или пользователя) представление выглядит как таблица. Представление поддерживает извлечение
    данных, а также оно может быть использовано для изменения данных, в зависимости от структуры базы данных и ее
    производителя. Представление содержит данные из одной или нескольких таблиц, доступ к которым может быть осуществлен с
    помощью единственного оператора select. При выборе данных достигается выигрыш в производительности, особенно в часто
    запрашиваемых таблицах. Данные извлекаются из одного расположения - из представления, вместо поиска во многих таблицах,
    существующих в базе данных.
</p>
<p>
    Представления также играют важную роль в защите базы данных. Представление, содержащее часть таблицы, может ограничить
    доступ к промежуточным данным, которые содержатся в основной таблице.
</p>
<h4>
    <a id="Define Storage Characteristics" name="Define Storage Characteristics">Определение параметров хранения</a>
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Спроектировать выделение дискового пространства и организацию дисковых страниц в базе данных.
            </td>
        </tr>
    </table>
</div>
<p>
    Проектировщик базы данных с помощью табличных пространств определяет объем дисковой памяти, который выделяется для
    таблиц, индексов, хранимых процедур и так далее. Базе данных соответствует одно или несколько табличных пространств.
    Проектировщик базы данных должен проанализировать таблицы в Модели проекта, чтобы определить, как распределить их
    вместе с другими элементами поддержки базы данных по области памяти в базе данных.
</p>
<p>
    При определении структур табличных пространств базы данных помните, что базы данных не выполняют ввод/вывод строк,
    записей или даже целых таблиц. Вместо этого они выполняют ввод/вывод дисковых блоков. Причина этого проста: операции
    ввода/вывода блоков обычно оптимизированы в программном и аппаратном обеспечении системы. В результате, физическая
    организация таблиц и индексов в базе данных может оказать решающее влияние на производительность системы.
</p>
<p>
    При планировании выделения дискового пространства и организации дисковых страниц в базе данных примите во внимание
    следующие факторы:
</p>
<ul>
    <li>
        Плотность информации в дисковых страницах
    </li>
    <li>
        расположение дисковых страниц на диске или среди многих дисков
    </li>
    <li>
        объем выделяемой для таблиц дисковой памяти
    </li>
</ul>
<p>
    Эти факторы обсуждаются в следующих разделах.
</p>
<blockquote>
    <h5>
        <b>Плотность дисковых страниц</b>
    </h5>
    <p>
        Плотность дисковых страниц зависит от ожидаемого размера, до которого данные могут измениться со временем. В
        основном, менее плотные страницы более подходят для изменений значений или добавления новых данных, в то время как
        более заполненные страницы данных обеспечивают лучшую производительность чтения, потому что при чтении блока
        извлекается больше данных.
    </p>
    <p>
        Для упрощения управления дисками, проектировщик базы данных может сгруппировать таблицы по объему, до которого они
        стремятся измениться. Для начала можно разбить таблицы на следующие три группы:
    </p>
    <ul>
        <li>
            сильно динамические таблицы
        </li>
        <li>
            до некоторой степени динамические таблицы
        </li>
        <li>
            в основном статические таблицы
        </li>
    </ul>
    <p>
        Сильно динамические таблицы должны располагаться на дисковых страницах, содержащих много пустого пространства
        (около 30%). Отчасти динамические таблицы должны располагаться на дисковых страницах, в которых меньше пустого
        пространства (около 15%). А наиболее статические таблицы должны располагаться на дисковых страницах, в которых
        совсем немного пустого пространства (около 5%). Индексы для таблиц должны быть распределены подобным образом.
    </p>
    <h5>
        <b>Расположение дисковых страниц</b>
    </h5>
    <p>
        После распределения групп таблиц, проектировщик базы данных должен определить, куда поместить дисковые страницы.
        Цель состоит в том, чтобы попытаться сбалансировать рабочую нагрузку среди разных накопителей и уменьшить или
        устранить узкие места. Обратите внимание на следующие рекомендации:
    </p>
    <ul>
        <li>
            Никогда не помещайте на тот диск, который содержит операционную систему, ее временные файлы или устройства
            подкачки. Эти устройства и так достаточно загружены.
        </li>
        <li>
            Поместите данные, доступ к которым осуществляется одновременно, на разные диски, чтобы сбалансировать рабочую
            нагрузку. Некоторые системы поддерживают параллельные каналы ввода/вывода. В таком случае поместите данные на
            разные каналы.
        </li>
        <li>
            Поместите индексы и данные, которые они индексируют, на разные диски для распределения нагрузки.
        </li>
        <li>
            Подробная информация приведена в документации производителя базы данных.
        </li>
        <li>
            Используемые типы хранилища (например, RAID-5, RAID-10, SAN, NAS и присоединенные каналы) влияют на
            производительность базы данных. Следуйте рекомендациям поставщика хранилища по оптимизации производительности.
        </li>
    </ul>
    <p>
        Ввод/вывод базы данных обычно является ограничивающим фактором для ее производительности. Балансировка ввода/вывода
        является повторяющимся экспериментальным процессом. С помощью моделирования производительности доступа к базе
        данных во время этапа уточнения, а также соответствующих средств мониторинга физического и логического
        ввода/вывода, можно раскрыть проблемы производительности на ранней стадии, когда еще есть время для регулировки
        проекта базы данных.
    </p>
    <h5>
        <b>Распределение дискового пространства</b>
    </h5>
    <p>
        С помощью механизма проектирования хранилища оцените количество объектов, которые должны быть сохранены. Объем
        дискового пространства, требуемый для хранения объектов, отличается для разных RDBMS. &nbsp;При расчете дискового
        пространства учтите прирост объема из-за добавления данных. &nbsp; Для того чтобы оценить объем дискового
        пространства для базы данных, сначала оцените объем, который требуется для каждой таблицы, а затем вычислите общий
        объем требуемого пространства для всех таблиц. &nbsp; Из руководства администратора базы данных для данного
        продукта RDBMS определите точную формулу оценки размера. &nbsp; Ниже приведено несколько общих шагов для оценки
        требуемого пространства для таблицы:
    </p>
    <ul>
        <li>
            Вычислите средний размер строки. &nbsp; При этом вычислении нужно включать всю управляющую информацию на уровне
            записи, а также всю управляющую информацию, требуемую для столбцов переменной длины.
        </li>
        <li>
            Вычислите количество строк, которые поместятся на странице или в блоке ввода/вывода. &nbsp;Так как большая
            часть баз данных хранят только полные записи на странице или в блоке ввода/вывода, это количество должно быть
            целым числом.
        </li>
        <li>
            Вычислите количество страниц или блоков ввода/вывода, требуемое для хранения полученного числа записей в базе
            данных. &nbsp; Примерное число записей должно включать в себя все коэффициенты загрузки.
        </li>
        <li>
            Умножьте требуемое количество страниц или блоков ввода/вывода на размер страницы или блока ввода/вывода.
        </li>
        <li>
            Добавьте объем дополнительных индексов.
        </li>
        <li>
            Добавьте объем служебной информации для таблицы.
        </li>
    </ul>
    <p>
        После определения требуемого объема для таблицы:
    </p>
    <ul>
        <li>
            Вычислите суммарное пространство, требуемое для всех таблиц.
        </li>
        <li>
            Добавьте требуемый фиксированный объем пространства для управляющей информации базы данных.
        </li>
        <li>
            Добавьте пространство для протокола транзакций и контрольного журнала. &nbsp;
        </li>
    </ul>
    <p>
        В часто изменяемой среде контрольный журнал требует значительного объема дискового пространства. В документации по
        основным коммерческим системам управления базами данных обычно предоставлены подробные инструкции по расчету
        размеров. Следуйте этим инструкциям при расчете требуемого объема дискового пространства.
    </p>
</blockquote>
<h4>
    <a id="Distribute Class behavior to the Database" name="Distribute Class behavior to the Database">Проектирование
    хранимых процедур для реализации поведения класса в базе данных</a>
</h4>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Определить, должны ли использоваться хранимые процедуры или триггеры для реализации операций классов
                доступа к данным.
            </td>
        </tr>
    </table>
</div>
<p>
    Большая часть баз данных поддерживает хранимые процедуры. Хранимая процедура - это исполняемый код, который выполняется
    в рабочем пространстве системы управления базами данных. Она обеспечивает возможность выполнения на сервере действий,
    относящихся к базе данных, без передачи данных по сети. Разумное использование хранимых процедур может повысить
    производительность системы.
</p>
<p>
    Хранимые процедуры обычно принадлежат одному из следующих двух типов: собственно процедуры и триггеры. Процедуры
    выполняются приложениями явно, обычно имеют параметры и явно возвращают значение. Триггеры, с другой стороны,
    вызываются неявно при возникновении некоторых событий в базе данных (например, вставке строки, изменении строки или ее
    удалении), не имеют параметров кроме изменяемых в строке значений (поскольку они вызываются неявно), и они не
    возвращают явно никакого значения.
</p>
<p>
    В базах данных, у которых отсутствуют ограничения, триггеры часто используются для обеспечения целостности данных и
    ссылок. Кроме того, они используются тогда, когда событие должно инициировать другое событие. Триггеры также часто
    используются для обеспечения защиты с помощью проверки события триггера.
</p>
<p>
    Классы проекта в Модели проекта необходимо проверить на предмет наличия в них операций, которые должны быть реализованы
    с помощью хранимых процедур или триггеров. Для этого подходят:
</p>
<ul>
    <li>
        любые операции, которые имеют дело с постоянными данными (их создание, изменение, извлечение или удаление).
    </li>
    <li>
        любые операции, в которых в вычисление требует запроса данных (например, вычисление среднего количества или общего
        объема продукции на складе).
    </li>
    <li>
        операции, которые должны получать доступ к базе данных для проверки данных.
    </li>
</ul>
<p>
    Помните, что повышение производительности базы данных обычно означает уменьшения ввода/вывода. Поэтому, если выполнение
    вычислений на сервере DBMS уменьшает объем данных, передаваемых по сети, то вычисления должны выполняться на сервере.
</p>
<p>
    Обсудите с проектировщиком классов, как можно повысить производительность базы данных. Проектировщик изменит метод
    операции, чтобы обозначить, можно ли ее реализовать с помощью одной или нескольких хранимых процедур.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Просмотр результатов </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Review the Results" name="Review the Results"></a> 
<div align="left">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="100%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <td width="5%">
                    <b>Цель</b>
                </td>
                <td width="95%">
                    Убедиться в качестве и целостности <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_data_model_65B46980.html" guid="{9DCF1723-1A21-4F48-BEDE-DBC543489682}">Модели данных</a>.
                </td>
            </tr>
        </tbody>
    </table>
</div>
<p>
    В процессе этой задачи вы должны рассмотреть <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/data_model_D22985A5.html" guid="2.800761632096845E-305">Справочная таблица:
    Модель данных</a>, чтобы оценить полноту и качество проделанной работы. &nbsp; Кроме того, проектировщик базы данных
    должен периодически просматривать реализованную структуру базы данных, чтобы убедиться в том, что Модель данных
    отражает все изменения, внесенные непосредственно в базу данных. &nbsp; Если в проекте применяются средства
    моделирования данных, которые поддерживают синхронизацию Модели данных с физической структурой базы данных, то
    проектировщик базы данных должен периодически проверять состояние Модели данных в базе данных и вносить необходимые
    корректировки. &nbsp;
</p>
<p>
    Обнаруженные дефекты, неисправленные в данный момент, должны быть внесены в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_change_request_F2E6419.html" guid="{694A7BC8-3D20-4172-BC56-6C7BD4590BA5}">Запросы
    на изменение</a>, и впоследствии должно быть назначено лицо, ответственное за их устранение.
</p></td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Свойства</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Несколько вхождений" abbr="Несколько вхождений">Несколько вхождений</th><td align="left" class="sectionTableCell" headers="property_Несколько вхождений"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Управляется событиями" abbr="Управляется событиями">Управляется событиями</th><td align="left" class="sectionTableCell" headers="property_Управляется событиями"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Выполняющийся" abbr="Выполняющийся">Выполняющийся</th><td align="left" class="sectionTableCell" headers="property_Выполняющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Необязательный" abbr="Необязательный">Необязательный</th><td align="left" class="sectionTableCell" headers="property_Необязательный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Запланированный" abbr="Запланированный">Запланированный</th><td align="left" class="sectionTableCell" headers="property_Запланированный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Повторяющийся" abbr="Повторяющийся">Повторяющийся</th><td align="left" class="sectionTableCell" headers="property_Повторяющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
					contentPage.onload();
					contentPage.processPage.fixDescriptorLinks();
				</script>
</html>
