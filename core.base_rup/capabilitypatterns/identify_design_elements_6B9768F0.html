<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Дескриптор задачи: Определение элементов проекта</title>
<meta content="TaskDescriptor" name="uma.type">
<meta content="identify_design_elements" name="uma.name">
<meta content="Определение элементов проекта" name="uma.presentationName">
<meta content="_TBDzkEocEdqrjq4i3fchvA" name="uma.guid">
<meta content="TaskDescriptor" name="element_type">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ActivityTreeTable.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ProcessElementPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/processElementData.js"></script><script language="JavaScript" type="text/javascript">
					var defaultQueryStr = '?proc={002674F9-6511-4D15-8623-B761D8C48986}&path={002674F9-6511-4D15-8623-B761D8C48986},{F2160C54-F666-4736-9982-FC7F58F15FAD},_TBDzkEocEdqrjq4i3fchvA';
					var backPath = './../../';
					var imgPath = './../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo, defaultQueryStr, true, true, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top">
<div id="page-guid" value="_TBDzkEocEdqrjq4i3fchvA"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Дескриптор задачи: Определение элементов проекта</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../images/taskdes_lg_dgm32.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Это задание описывает способы определения подсистем, классов, интерфейсов, событий и сигналов.</td>
</tr>
<tr>
<td>На основе задачи метода: <a href="./../../core.base_rup/tasks/identify_design_elements_E884AB82.html" guid="{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}">Определение элементов проекта</a></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Роли</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Главный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_software_architect_8B6C5D41.html" guid="_COWYtRi2Edq_uI8xTPML6g">Разработчик архитектуры</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Дополнительно:
								</span></td><td class="sectionTableCell"><span class="sectionTableCellHeading">Помощь:
								</span></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Входы</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Обязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_DE193C28.html" guid="_joR0wL9dEdqBwpaAk4N49g">Класс анализа</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_5B5A476F.html" guid="_kU-isL9dEdqBwpaAk4N49g">Класс анализа</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Необязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_software_architecture_document_7A057157.html" guid="_COWYthi2Edq_uI8xTPML6g">Документ архитектуры программного обеспечения</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_supplementary_specification_4FFE3F60.html" guid="_COWYuRi2Edq_uI8xTPML6g">Дополнительные спецификации</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_model_71BF5F7C.html" guid="_ZQarczbZEdqdbfmtFQj8qA">Модель анализа</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_84A35167.html" guid="_COWYtxi2Edq_uI8xTPML6g">Модель проекта</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_project_specific_guidelines_CE84238E.html" guid="_COWYwBi2Edq_uI8xTPML6g">Рекомендации по проекту</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">Внешний:
								</span>
<ul>
<li>Нет</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Выходы</th><td colspan="3" class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_84A35167.html" guid="_COWYtxi2Edq_uI8xTPML6g">Модель проекта</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Шаги</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr>
<td class="sectionTableCell">
<div class="stepHeading"> Определить события и сигналы </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_events__identification_of" name="XE_events__identification_of"></a><a id="Identify and Specify Events" name="Identify and Specify Events"></a>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Определить внешние и внутренние события и сигналы, на которые система должна реагировать.&nbsp;
            </td>
        </tr>
    </table>
    <p>
        События - это внешние и внутренние происшествия, вызывающие какую-либо реакцию со стороны системы. События и их
        параметры могут облегчить выделение ключевых элементов проектирования, например, активных классов.
    </p>
    <p>
        Начальный список внешних событий можно составить на основе модели вариантов использования (точнее, ее части,
        которая относится к взаимодействию субъектов и вариантов использования). Список внутренних событий можно составить
        на основе сведений о выполнении варианта использования. Также возможно определить события в процессе
        проектирования.
    </p>
    <p>
        Наиболее существенные характеристики события:
    </p>
    <ul>
        <li>
            внутреннее/внешнее - Является событие внутренним или внешним?
        </li>
        <li>
            приоритет - требуется ли для обработки этого события приостанавливать другие процессы?
        </li>
        <li>
            частота - Как часто событие происходит?
        </li>
        <li>
            распределение частот - Событие происходит через регулярные интервалы времени, или наблюдаются определенные
            пики?
        </li>
        <li>
            требования к ответу - Насколько быстро система должна отреагировать на событие? (возможно, следует указать
            среднее и максимальное допустимое значение)
        </li>
        <li>
            род - Это событие является вызовом, наступлением определенного срока, сигналом либо обнаруженным изменением
            (определения содержатся в документе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/events_and_signals_734567DC.html" guid="1.800598287887014E-305">Концепция:
            События и сигналы</a>)?
        </li>
    </ul>
    <p>
        Характеристики событий используются для определения элементов проектирования, которые будут их обрабатывать. Сбор
        характеристик событий наиболее важен для реактивных (управляемых событиями) систем, но эта процедура также может
        быть полезна для других систем, например, использующих технологии параллелизма и/или асинхронную отправку
        сообщений.
    </p>
    <p>
        События асинхронной связи в модели могут быть отражены как сигналы, что позволяет выразить либо передаваемые ими
        данные, либо взаимоотношения между сигналами (например, один может являться частным случаем другого). В некоторых
        системах, особенно в реактивных, важно связать сигналы, поступающие от внешних устройств, с конкретными
        механизмами, например, с прерываниями или особыми сообщениями опроса адресов.<br />
    </p>
</div></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определить классы, активные классы и подсистемы </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Identify Classes, Active Classes and Subsystems" name="Identify Classes, Active Classes and Subsystems"></a>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Цель</b>
            </td>
            <td width="95%">
                Преобразовать <b>аналитические классы</b> в соответствующие элементы модели проектирования&nbsp;
            </td>
        </tr>
    </table><br />
</div>
<p>
    <b>Определить классы.</b> Если строение аналитического класса простое, и он представляет одиночную логическую
    абстракцию, то его можно без изменений преобразовать в <b>класс проектирования</b>. Обычно сущностные классы переходят
    в классы проектирования без существенных изменений. Сущностные классы обычно являются устойчивыми, поэтому следует
    определить, должен ли класс проектирования быть устойчивым, и отразить это в описании класса.
</p>
<p>
    В процессе определения классов их следует разделять по <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_package_8376BC8E.html" guid="{80CC5437-F481-487B-A69B-957D9D236D8D}">группам
    проектирования</a>, что облегчает задачи создания и управления конфигурациями. Дополнительная информация о составлении
    групп содержится в документе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_package_8CF100B8.html" guid="3.3691722315666536E-305">Рекомендация по
    рабочему продукту: Группа проектирования</a>.
</p>
<p>
    <b>Определить активные классы.</b> В контексте обнаруженных аналитических объектов следует учесть требования
    параллелизма: должна ли система реагировать на внешние события, и, если да, то сколько аналитических классов должны
    быть активны при осуществлении события? Внешние события в модели вариантов использования представляются в виде
    воздействий, поступающих от субъектов, которые взаимодействуют с вариантом использования. Обратитесь к реализациям
    вариантов использования, чтобы понять способ взаимодействия объектов при осуществлении события. Разделите объекты на
    автономные наборы взаимодействующих объектов. Эти наборы будут являться первоначальными вариантами групп, на основе
    которых будут создаваться активные классы.
</p>
<p>
    Если событию присущи важные атрибуты, которые необходимо отразить, то его следует промоделировать как класс на основе
    стереотипного сигнала. В системах реального времени эти наборы впоследствии потребуется преобразовать в капсулы,
    структура которых определяется строгими семантическими правилами.
</p>
<p>
    Экземпляры активных классов представляют независимые "логические" выполняющиеся потоки. Следует различать "логические"
    потоки и реально выполняющиеся потоки операционной системы (хотя на определенном этапе они будут связаны). "Логические"
    потоки - это независимые абстрактные потоки, запускаемые реализуемой системой. На данном этапе требуется разделить
    решение на независимые модули, основываясь на интуитивно понятных "стыках" системы. Такое разделение упрощает работу с
    механизмами параллелизма, так как с независимыми потоками можно работать по отдельности (если они используют различные
    пассивные классы).
</p>
<p>
    Обычно активные классы следует реализовывать в том случае, если используются механизмы параллелизма, и между
    параллельно выполняемыми потоками возможны конфликты. Активные классы используются для представления внешнего объекта,
    выполняющего какие-либо действия параллельно с другим объектом, либо для представления параллельных операций,
    происходящих в самом компьютере. Это дает возможность отслеживать параллельные действия и управлять ими.
</p>
<p>
    Другим естественным решением является использование активных классов для <b>внутреннего представления внешних
    физических устройств</b>, подключенных к компьютеру, так как работа таких устройств всегда осуществляется параллельно.
    Такие классы (в некотором смысле - "драйверы устройств") используются не только для отслеживания работы устройств и
    управления ими, но и для того, чтобы системе не приходилось работать с устройствами на физическом уровне. Это означает,
    что при изменении технологии устройств потребуется изменение только этих классов.
</p>
<p>
    Для представления логически параллельных действий также обычно используются активные классы. Эти действия представляют
    абстрактный параллельный "объект", например, финансовую транзакцию или телефонный звонок. Они не являются физическими
    сущностями (хотя имеют место в материальном мире), однако их часто полезно рассматривать таким образом. Например, может
    потребоваться временно приостановить финансовую транзакцию, чтобы избежать конфликта параллельных действий, либо
    отменить ее в связи с системной ошибкой. Эти абстрактные объекты рассматриваются как модули, поэтому полезно
    представлять их в виде объектов с собственными интерфейсами, предоставляющими соответствующие функциональные
    возможности.
</p>
<p>
    Примером объекта такого типа является <b>контроллер активного объекта</b>. Он служит для управления одним или
    несколькими активными объектами. Обычно он обеспечивает перевод объекта в требуемое состояние, управление им при
    возникновении каких-либо неполадок, например, частичных сбоев, и синхронизация его работы с другими объектами.
    Необходимость в контроллерах активных объектов обычно проявляется при создании управляющих объектов в ходе выполнения
    задачи<a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Анализ вариантов использования</a>.
</p>
<p>
    Активные классы предоставляют простой способ разрешения конфликтов параллелизма, поэтому их часто используют в качестве
    <b>хранителей общих ресурсов</b>. В этом случае один или несколько ресурсов, используемые в ходе нескольких
    параллельных процессов, встраиваются в активный класс. Поскольку такие классы являются по своей сути
    взаимоисключающими, они автоматически защищают ресурсы от конфликтов параллельного доступа.
</p>
<p>
    <b>В системах реального времени вместо активных классов следует использовать капсулы: если в соответствии с
    вышеприведенными правилами была определена потребность в активном классе, следует заменить его на капсулу.</b>
</p>
<p>
    <b>Определить подсистемы.</b> Если аналитический класс является сложным (например, его поведение невозможно представить
    одиночным классом), то такой класс следует преобразовать в проектировочную подсистему. Проектировочная подсистема
    инкапсулирует способы кооперации классов таким образом, что внутреннее строение подсистемы никоим образом не влияет на
    работу ее клиентов, даже если они пользуются службами подсистемы.
</p>
<p>
    Подсистема моделируется в виде компонента UML, общедоступными компонентами которого являются только интерфейсы.
    Интерфейс является средством инкапсуляции, скрывающим внутреннее строение подсистемы от других элементов модели.
    Подсистему следует отличать от групп, которые представляют собой не ограниченные семантическими правилами контейнеры
    элементов модели.
</p>
<p>
    Решение включить скооперированные классы в подсистему обычно следует принимать с учетом возможности реализации способов
    кооперации отдельной группой проектировщиков. Если кооперируются только классы, входящие в выделенную группу, то
    преобразование группы в подсистему способно обеспечить больший уровень инкапсуляции. Содержимое подсистемы и механизмы
    кооперации ее классов должно быть полностью скрыто за одним или несколькими интерфейсами, поэтому клиент подсистемы
    взаимодействует исключительно с интерфейсом. Проектировщику (или группе проектировщиков) подсистемы, таким образом, не
    приходится учитывать внешние зависимости; им требуется только составить описание реализации интерфейса, так как
    изменение содержимого подсистемы не влияет на внешние зависимости. При реализации большой системы с участием крупных
    независимых коллективов возможность такого разделения в сочетании с повышением строгости архитектуры при использовании
    формальных интерфейсов является серьезным аргументом в пользу подсистем. Дополнительная информация о факторах, влияющих
    на выбор в пользу подсистем, содержится в документе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html" guid="1.2314266786534317E-305">Рекомендация по
    рабочему продукту: Проектировочная подсистема</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Определите интерфейсы подсистем </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_interfaces__identifying_a_subsystem's" name="XE_interfaces__identifying_a_subsystem's"></a><a id="XE_design_subsystem__identifying_interfaces" name="XE_design_subsystem__identifying_interfaces"></a><a id="Identify Interfaces" name="Identify Interfaces"></a> 
<div align="left">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="100%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <td width="5%">
                    <b>Цель</b>
                </td>
                <td width="95%">
                    Определить элементы проектирования, которые будут представлять элементы системы.&nbsp;
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Интерфейсы задают набор операций, осуществляемых каким-либо классификатором. В модели проектирования интерфейсы в
    основном используются для определения интерфейсов подсистем. Это не значит, что их нельзя использовать для классов,
    однако обычно для одиночного класса достаточно описать общедоступные функции, которые, по сути, определяют его
    "интерфейс". Интерфейсы важны для подсистем, поскольку они позволяют разделить объявление поведения (интерфейс) от его
    реализации (классы, входящие в состав подсистемы). Такое разделение увеличивает независимость групп разработки,
    реализующих различные компоненты системы, сохраняя строгую определенность в способах взаимодействия этих компонентов.
</p>
<p>
    <b>Для каждой подсистемы определите набор потенциальных интерфейсов.</b>. Используя группы, выделенные на предыдущем
    этапе, определите, какую функцию необходимо активировать при начале взаимодействия классов. Для того чтобы более точно
    определить эту функцию, выясните, какая информация поступает от клиента и какую информацию следует возвратить при
    завершении совместной работы классов; эти наборы данных являются прототипами параметров ввода и вывода, а также
    значения, возвращаемого операцией подсистемы. Определите имя этой операции (соглашения об именах описаны в документе <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рабочий продукт: рекомендации по проекту</a>). Повторяйте эти действия,
    пока все выполняемые подсистемой операции не будут определены.
</p>
<p>
    Затем сгруппируйте операции в соответствии с выполняемыми ими функциями. Предпочтительнее формировать небольшие группы,
    так как в этом случае выполняемые функции, выполняемые соответствующими операциями, будут ближе по своей сути.
    Отслеживайте, возможно ли их повторное использование - сходства в функциях помогут обнаружить возможность такого
    использования. Не старайтесь довести разбиение на группы до совершенства; помните, это лишь первое приближение, и в
    ходе фазы уточнения будет сформирован улучшенный вариант.
</p>
<p>
    <b>Постарайтесь найти похожие интерфейсы.</b> Просмотрите список потенциальных интерфейсов, обращая внимание на похожие
    имена, функции и операции. Если одна и та же операция относится к нескольким интерфейсам, преобразуйте интерфейсы так,
    чтобы она относилась только к одному. Используйте возможности взаимозамены интерфейсов. Задача - добиться связности
    интерфейсов и удалить ненужные операции. Это сделает интерфейсы более понятными и доступными для дальнейшего
    использования.
</p>
<p>
    <b>Определите зависимости между интерфейсами.</b> Параметры и возвращаемое значение каждой операции интерфейса
    относятся к определенному типу: они должны реализовывать какой-либо интерфейс или относиться к одному типу данных. Если
    параметры являются объектами, реализующими конкретный интерфейс, определите связи между данным интерфейсом и теми
    интерфейсами, от которых он зависит. Определение зависимости между интерфейсами позволяет представить информацию в
    виде, удобном для архитектора программного обеспечения, так как зависимости интерфейсов связаны с зависимостями между
    элементами спроектированной модели.
</p>
<p>
    <b>Свяжите интерфейсы с подсистемами.</b> После того как интерфейсы определены, создайте <b>реализуемые</b> связи между
    подсистемами и их интерфейсами. Интерфейс реализуется подсистемой в том случае, если подсистема содержит один или
    несколько элементов, реализующих операции интерфейса. После того, как подсистема будет спроектирована, эти реализации
    будут уточнены (проектировщик подсистем должен будет определить, какие элементы подсистемы будут реализовывать операции
    интерфейсов). Представлением об этой реализации будет обладать только проектировщик подсистемы; клиент подсистемы будет
    работать только с ее интерфейсами.
</p>
<p>
    <b>Определите поведение интерфейсов.</b> Элементы, реализующие интерфейс, часто функционируют как конечный автомат.
    Если операции интерфейса требуется вызывать в определенном порядке (например, вначале подключиться к базе данных, а
    потом работать с ней), то этот конечный автомат демонстрирует все явные и подразумеваемые состояния, в которых могут
    находиться реализующие подсистему элементы проектирования. Концепция конечного автомата помогает пользователю понять
    интерфейс, а проектировщику элементов, который формирует интерфейс - создать элементы с требуемым поведением.
</p>
<p>
    <b>Распределите интерфейсы по пакетам.</b> Интерфейсы попадают в область деятельности архитектора программного
    обеспечения; любое изменение в интерфейсах сказывается на архитектуре. Для того чтобы облегчить управление
    интерфейсами, их следует поместить в один или несколько пакетов. Если каждый интерфейс реализуется одной подсистемой,
    то разбиение интерфейсов на пакеты может соответствовать разбиению подсистем. Если интерфейс реализуется несколькими
    подсистемами, то его следует поместить в отдельный пакет, которым будет заниматься архитектор программного обеспечения.
    Такой подход позволяет управлять интерфейсами независимо от подсистем.
</p>
<h3 class="reactive">
    <a id="XE_protocol__identification_of" name="XE_protocol__identification_of"></a><a id="Identify Capsule Protocols" name="Identify Capsule Protocols">Определите протоколы капсул</a>
</h3>
<div align="left">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="100%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <td width="5%">
                    <p class="reactive">
                        <b>Цель</b>
                    </p>
                </td>
                <td width="95%">
                    Определить элементы проектирования, которые будут представлять элементы системы (только для систем
                    реального времени).
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p class="reactive">
    Протоколы похожи на интерфейсы реактивных систем; они задают способ взаимодействия капсул, определяя набор сигналов,
    которые будут использоваться для обмена информацией между независимыми управляющими потоками. Интерфейсы обычно задают
    механизмы синхронного обмена сообщениями с использованием вызываемых функций, а протоколы в основном служат для
    определения механизма асинхронной связи с помощью сигналов. Протоколы позволяют разделить объявление поведения (набор
    сигналов) от его реализации (элементы подсистемы, реализующие интерфейс). Такое разделение увеличивает независимость
    групп разработки, реализующих различные компоненты системы, сохраняя строгую определенность в способах взаимодействия
    этих компонентов.
</p>
<p class="reactive">
    <b>Для каждой капсулы определите набор входящих и исходящих сигналов</b>. Используя группы, выделенные на ранних
    этапах, определите, какую функцию необходимо активировать при начале взаимодействия классов. Для того чтобы более точно
    определить эту функцию, выясните, какая информация поступает от клиента и какую информацию следует возвратить при
    завершении совместной работы классов; эти наборы данных являются прототипами входных параметров сигнала, передаваемого
    капсулой. Определите имя этого сигнала (соглашения об именах описаны в документе <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рабочий продукт: рекомендации по проекту</a>). Повторяйте эти действия,
    пока все передаваемые капсулой сигналы не будут определены.
</p>
<p class="reactive">
    Затем сгруппируйте сигналы в соответствии с выполняемыми ими функциями. Предпочтительнее формировать небольшие группы,
    так как в этом случае выполняемые соответствующими сигналами функции будут ближе по своей сути. Отслеживайте, возможно
    ли их повторное использование - сходства в функциях помогут обнаружить возможность такого использования. Не старайтесь
    довести разбиение на группы до совершенства; помните, это лишь первое приближение, и в ходе фазы уточнения будет
    сформирован улучшенный вариант. Присвойте протоколу значащее имя, описывающее функцию протокола в кооперации капсул.
</p>
<p class="reactive">
    <b>Постарайтесь найти похожие протоколы.</b> Просмотрите список потенциальных протоколов, обращая внимание на похожие
    имена, функции и сигналы. Если один и тот же сигнал относится к нескольким протоколам, преобразуйте протоколы так,
    чтобы он относился только к одному из них. Используйте возможности взаимозамены протоколов. Задача - добиться связности
    протоколов и удалить ненужные сигналы. Это сделает протоколы более понятными и доступными для дальнейшего
    использования.
</p>
<p class="reactive">
    <b>Свяжите протоколы с капсулами.</b> После определения протоколов создайте <b>порты</b> капсулы, которые будут
    реализовывать протоколы. Порты капсулы определяют ее "интерфейсы", те функции, которые она может выполнять. В
    дальнейшем, при проектировании капсулы, определенное для портов поведение будет описано с помощью конечного автомата
    (один автомат соответствует одной капсуле).
</p>
<p class="reactive">
    <b>Определите поведение протоколов.</b> Элементы, реализующие протокол, часто функционируют как конечный автомат. Если
    сигналы интерфейса требуется получать в определенном порядке (например, вначале получить сигнал о готовности системы, а
    потом - сигнал о возникшей ошибке), то этот конечный автомат демонстрирует все явные и подразумеваемые состояния, в
    которых могут находиться реализующие протокол элементы проектирования. Концепция конечного автомата помогает
    пользователю понять работу протокола, а проектировщику капсул - создать элементы с требуемым поведением.
</p>
<p class="reactive">
    <b>Распределите протоколы по пакетам.</b> Протоколы попадают в область деятельности архитектора программного
    обеспечения; любое изменение в протоколах сказывается на архитектуре. Для того чтобы облегчить управление протоколами,
    их следует поместить в один или несколько пакетов. Такой подход позволяет управлять протоколами независимо от капсул,
    которые их реализуют.
</p><br /></td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Свойства</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Несколько вхождений" abbr="Несколько вхождений">Несколько вхождений</th><td align="left" class="sectionTableCell" headers="property_Несколько вхождений"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Управляется событиями" abbr="Управляется событиями">Управляется событиями</th><td align="left" class="sectionTableCell" headers="property_Управляется событиями"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Выполняющийся" abbr="Выполняющийся">Выполняющийся</th><td align="left" class="sectionTableCell" headers="property_Выполняющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Необязательный" abbr="Необязательный">Необязательный</th><td align="left" class="sectionTableCell" headers="property_Необязательный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Запланированный" abbr="Запланированный">Запланированный</th><td align="left" class="sectionTableCell" headers="property_Запланированный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Повторяющийся" abbr="Повторяющийся">Повторяющийся</th><td align="left" class="sectionTableCell" headers="property_Повторяющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
					contentPage.onload();
					contentPage.processPage.fixDescriptorLinks();
				</script>
</html>
