<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Дескриптор задачи: Проектирование прецедентов</title>
<meta content="TaskDescriptor" name="uma.type">
<meta content="use_case_design" name="uma.name">
<meta content="Проектирование прецедентов" name="uma.presentationName">
<meta content="_mL0YQEocEdqrjq4i3fchvA" name="uma.guid">
<meta content="TaskDescriptor" name="element_type">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ActivityTreeTable.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ProcessElementPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/processElementData.js"></script><script language="JavaScript" type="text/javascript">
					var defaultQueryStr = '?proc={002674F9-6511-4D15-8623-B761D8C48986}&path={002674F9-6511-4D15-8623-B761D8C48986},{9C683674-97C1-4AEE-8DB0-9514AEFF698E},_mL0YQEocEdqrjq4i3fchvA';
					var backPath = './../../';
					var imgPath = './../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo, defaultQueryStr, true, true, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top">
<div id="page-guid" value="_mL0YQEocEdqrjq4i3fchvA"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Дескриптор задачи: Проектирование прецедентов</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../images/taskdes_lg_dgm32.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">В этой задаче рассмотрен процесс уточнения результатов анализа вариантов использования путем разработки реализаций вариантов использования уровня разработки.</td>
</tr>
<tr>
<td>На основе задачи метода: <a href="./../../core.base_rup/tasks/use_case_design_92D13EEE.html" guid="{76E2B93D-051C-4B8C-BEA1-B40A40CBD986}">Проектирование прецедентов</a></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Роли</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Главный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_designer_FCD65796.html" guid="_CQ1sARi2Edq_uI8xTPML6g">Проектировщик</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Дополнительно:
								</span></td><td class="sectionTableCell"><span class="sectionTableCellHeading">Помощь:
								</span></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Входы</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Обязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_usecase_3C5CB7B5.html" guid="_lPfDIL9dEdqBwpaAk4N49g">Вариант</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_usecase_498EF5E2.html" guid="_me4Ocb9dEdqBwpaAk4N49g">Вариант</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">Необязательный:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_supplementary_specification_BA9F2DDB.html" guid="_CQ1sBxi2Edq_uI8xTPML6g">Дополнительные спецификации</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_model_FDB6F428.html" guid="_CQ1sEhi2Edq_uI8xTPML6g">Модель анализа</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_7D6F5DFE.html" guid="_CQ7yohi2Edq_uI8xTPML6g">Модель проекта</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">Внешний:
								</span>
<ul>
<li>Нет</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Выходы</th><td colspan="3" class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_7D6F5DFE.html" guid="_CQ7yohi2Edq_uI8xTPML6g">Модель проекта</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Шаги</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr>
<td class="sectionTableCell">
<div class="stepHeading"> Создание реализаций вариантов использования</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Create Use-Case Realizations" name="Create Use-Case Realizations"></a>
<p>
    Объект <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_use_case_realization_E4F713BD.html" guid="{87EB094F-095B-4981-ACC3-319B3B298641}">Рабочий продукт: Реализация варианта использования проектирования</a>
    предоставляет способ трассировки поведения модели проектирования обратно к модели вариантов использования. Кроме того,
    он применяется для организации коопераций в модели проектирования в соответствии с понятием варианта использования.
</p>
<p>
    Создайте реализацию варианта использования проектирования в модели проектирования для каждого варианта использования.
    Имя реализации варианта использования проектирования должно совпадать с именем связанного варианта использования. Кроме
    того, между реализацией варианта использования и вариантом использования следует создать взаимосвязь реализации.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Опишите взаимодействия между объектами проектирования</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Describe Interactions Between Design Objects" name="Describe Interactions Between Design Objects"></a> 
<p>
    Для каждой реализации варианта использования следует показать взаимодействия между участвующими объектами
    проектирования путем создания одной или нескольких диаграмм последовательности. Ранние версии можно создавать на этапе
    <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Задача: Анализ вариантов использования</a>. Такие версии анализа
    реализаций вариантов использования описывают взаимодействия между <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_analysis_class_DAF7CE03.html" guid="{1E20603F-A5B8-42D5-BDBC-69DCE9C0FCDB}">классами
    анализа</a>. Их следует преобразовать для описания взаимодействий между элементами проектирования.
</p>
<p>
    Процедура обновления диаграмм последовательности состоит из следующих этапов:
</p>
<ul>
    <li>
        Определите каждый объект, принимающий участие в потоке варианта использования. Для этого следует создать экземпляры
        классов проектирования и подсистем, описанных в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/identify_design_elements_E884AB82.html" guid="{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}">Задача: Определение элементов проектирования</a>. В динамических
        системах необходимо определить экземпляры капсул, принимающих участие в потоке варианта использования.
    </li>
    <li>
        Представьте каждый активный объект диаграммы последовательности. Создайте генеральную линию для каждого объекта
        диаграммы последовательности. Подсистемы проектирования можно представить следующими способами: 
        <ul>
            <li>
                На диаграмме последовательности можно показать экземпляры подсистемы.
            </li>
            <li>
                Можно использовать интерфейсы, реализованные подсистемой. Такой подход эффективен, если требуется показать,
                что место интерфейса может занимать любой элемент модели, реализующий такой же интерфейс. Обратите
                внимание, что интерфейсы не должны отправлять сообщения другим объектам диаграммы последовательности. Это
                связано с тем, что интерфейсы полностью инкапсулируют внутреннюю реализацию своих операций. Поэтому нельзя
                гарантировать, что все элементы, реализующие интерфейс, будут спроектированы одинаковым образом. Таким
                образом, на диаграммах последовательности запрещены сообщения, отправляемые из интерфейсов.
            </li>
            <li>
                На диаграммах последовательности подсистему можно представить с помощью компонента. Компоненты
                рекомендуется применять для описания подсистем, поддерживающих обмен сообщениями. Таким образом можно
                показать сообщения, отправляемые из компонента другим объектам.
            </li>
        </ul>
        <p>
            Обратите внимание, что рассматриваются диаграммы последовательности уровня системы, которые отражают
            взаимодействие экземпляров элементов проектирования верхнего уровня (подсистемы и интерфейсов подсистем).
            Диаграммы последовательности, на которых показана внутренняя структура подсистем, создаются отдельно в ходе
            процедуры, рассмотренной в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html" guid="{CAA385CA-2BA2-40F2-8FE3-E21089D02119}">Задача:
            Проектирование подсистемы</a>.
        </p>
    </li>
    <li>
        <p>
            Обратите внимание, что взаимодействия активных объектов, как правило, описываются с помощью коопераций
            спецификации и конечных автоматов. Они применяются для отображения способа отправки сообщений активным объектам
            из других элементов системы в рамках более масштабной реализации варианта использования. Типичный подход
            заключается в инкапсуляции активных объектов в подсистемах таким образом, чтобы реализация варианта
            использования состояла из набора взаимодействующих подсистем. Взаимодействия задают обязанности и интерфейсы
            подсистем. В пределах подсистемы активные объекты представляют параллельные нити выполнения. Подсистемы
            позволяют разделить работу между группами разработки; интерфейсы в этом случае выполняют роль формальных
            контрактов между группами разработки. В динамических системах для представления активных объектов применяются
            объекты <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Рабочий продукт: Капсула</a>.
        </p>
        <p>
            Дополнительное примечание, относящееся к обмену сообщениями между подсистемами: Передача сообщений
            преимущественно с помощью интерфейсов позволяет уменьшить зависимость элементов модели друг от друга и повышает
            устойчивость проектирования. По возможности рекомендуется стремиться к достижению этой цели; сообщения,
            передаваемые между подсистемами и элементами модели, не имеющими отношения к интерфейсам, следует заменять
            сообщениями для интерфейсов, тем самым повышая устойчивость модели.
        </p>
    </li>
    <li>
        Представьте взаимодействие с субъектами. Представьте все экземпляры субъекта и внешние объекты, принимающие участие
        во взаимодействии, генеральными линиями на диаграмме последовательности.
    </li>
    <li>
        Покажите сообщение, передаваемое между взаимодействующими объектами. Поток событий начинается в верхней части
        диаграммы и продолжается вниз (вертикальная ось времени). Покажите сообщения, передаваемые между объектами, добавив
        сообщения (стрелки) между генеральными линиями. Имя сообщения должно совпадать с именем вызываемой этим сообщением
        операции. На ранних этапах проектирования с объектами связано незначительное число операций; в этом случае для
        сообщения можно указать временное имя; такие сообщения называются "невыделенными". Впоследствии, уточнив операции
        объектов, диаграмма последовательности обновляется путем связывания сообщений с операциями.
    </li>
    <li>
        Опишите действия объекта при получении сообщения. Для этого в сообщение добавляется сценарий. Сценарии, состоящие
        из структурного текста или псевдокода, размещаются на полях диаграммы. Конструкции псевдокода должны
        соответствовать языку реализации для облегчения реализации соответствующих операций. На основе сценариев объектов
        сотрудник, отвечающий за класс объекта, присваивает и разрабатывает операции.
    </li>
</ul>
<p align="center">
    <img height="417" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/guidances/guidelines/resources/seqdiag1.gif"     width="672" border="0" />
</p>
<p class="picturetext">
    Поведение варианта использования, реализуемое объектами, описывается на диаграмме последовательности.
</p>
<p>
    После распределения поведения между объектами необходимо определить способ управления потоком событий. Объекты
    выбирались по следующим критериям: они должны взаимодействовать конкретным образом в реализации варианта использования
    и должны выполнять конкретную роль. По мере распределения поведения можно начать проверку этих предположений. На этапах
    потока допустима как централизованная, так и децентрализованная структура. Определения этих вариантов и рекомендаций по
    их применению приведены в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/sequence_diagram_AFA76EBB.html#Distributing Control" guid="3.211008403369512E-306">Методика: Диаграммы последовательности</a>.
</p>
<p>
    На данном этапе могут потребоваться новые объекты, например, если применяется централизованная структура и необходим
    объект для управления потоком. Не забудьте, что все объекты, добавляемые в модель проектирования, должны
    соответствовать требованиям модели объекта.
</p>
<h4>
    <a id="Incorporate Applicable Design Mechanisms" name="Incorporate Applicable Design Mechanisms">Внедрение применимых
    механизмов проектирования</a>
</h4>
<p>
    В разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/architectural_analysis_2B9BE03.html" guid="{8CB48402-D4C5-4E17-BB33-507315CB1BBF}">Задача: Архитектурный анализ</a> были рассмотрены механизмы анализа. В
    разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}">Задача: Определение механизмов проектирования</a> на основе механизмов
    анализа создаются механизмы проектирования; процедура перехода от механизмов анализа к механизмам проектирования
    рассмотрена в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html" guid="{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}">Документ об архитектуре программного обеспечения</a>, механизмы
    проектирования описаны в <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">рекомендациях по проекту</a>. &nbsp;&nbsp;
</p>
<p>
    В ходе выполнения этой задачи все применимые механизмы проектирования внедряются в реализации вариантов использования.
    Проектировщик выбирает механизмы проектирования, применимые к разрабатываемой реализации варианта использования в
    соответствии с рекомендациями, описанными в документе об архитектуре программного обеспечения и рекомендациях по
    проектированию. &nbsp;&nbsp;<br />
     <b>Примечание:</b> Применимые механизмы проектирования могли рассматриваться на этапе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Задача: Анализ вариантов использования</a>, в ходе которой классы анализа
    могли быть связаны с конкретным механизмом анализа - в ходе проектирования должна обрабатываться конкретная
    функциональность. В таком случае применимые механизмы проектирования выбираются из числа механизмов, связанных с
    механизмами анализа классов анализа, принимающих участие в реализации варианта использования.
</p>
<p>
    Проектировщик внедряет применимые механизмы проектирования в реализации вариантов использования путем добавления
    необходимых элементов проектирования и их взаимодействий в реализации вариантов использования в соответствии с
    правилами, описанными в рекомендациях по проектированию.
</p>
<h4>
    <a id="Handle All Variants of the Flow of Events" name="Handle All Variants of the Flow of Events">Обработка всех
    вариантов потока событий</a>
</h4>
<p>
    Каждый вариант потока событий следует описать на отдельной диаграмме последовательности. Преимущество диаграмм
    последовательности по сравнению с диаграммами связи обусловлено уровнем подробности, который требуется при
    проектировании системы.
</p>
<p>
    Начните с описания основного потока, который состоит из наиболее общих или важных событий. Затем опишите такие
    варианты, как исключительные потоки. На предварительном этапе представления операций взаимодействующих объектов не
    требуется описывать все потоки событий. Таким образом, можно пропустить наиболее простые потоки, например,
    затрагивающие только один объект.
</p>
<p>
    Изучите вариант использования и попытайтесь найти варианты потока, которые не были описаны в ходе разработки требований
    и анализа, например, потоки, зависящие от реализации. Опишите каждый обнаруженный поток на диаграмме
    последовательности. Ниже приведены примеры исключительных потоков.
</p>
<ul>
    <li>
        <b>Обработка ошибок</b>. Вариант использования должен обрабатывать ошибки интерфейсов, например, неполадки при
        подключении к удаленной системе. Возможное решение: открыть новый маршрут связи.
    </li>
    <li>
        <b>Обработка тайм-аутов</b>. Если пользователь не отвечает в течение заданного периода, вариант использования
        должен принять специальные меры.
    </li>
    <li>
        <b>Обработка ошибок входных данных объектов варианта использования</b>. Такие ошибки могут возникнуть в ходе
        взаимодействия с пользователем.
    </li>
</ul>
<h4>
    <a id="Handle Optional Parts of the Use Case" name="Handle Optional Parts of the Use Case">Обработка дополнительных
    компонентов варианта использования</a>
</h4>
<p>
    Вместо варианта альтернативный поток можно описать как необязательный поток. В следующем списке приведены примеры
    необязательных потоков.
</p>
<ul>
    <li>
        Отправляя сигнал, субъект выбирает один из вариантов использования. Вариант использования предложил субъекту
        ответить на вопрос или предоставил доступ к набору функций, которые система может выполнить в текущем состоянии.
    </li>
    <li>
        Путь потока зависит от значения атрибута или взаимосвязи. Последующий поток событий зависит от типа обрабатываемых
        данных.
    </li>
</ul>
<p>
    Для привлечения внимания к необязательному потоку или сложному дочернему потоку рекомендуется использовать отдельную
    диаграмму последовательности. На диаграмме последовательности основного потока событий должны быть указаны ссылки на
    все отдельные диаграммы последовательности с помощью сценариев, текста и примечаний на полях с описанием
    соответствующего поведения.
</p>
<p>
    Если поведение необязательного или исключительного потока не зависит от конкретного расположения, например, поведение,
    вызываемое конкретным событием, на диаграмму последовательности основного потока событий следует добавить комментарий о
    том, что в результате возникновения события запускается поведение, описанное на необязательной/исключительной диаграмме
    последовательности. Кроме того, в случае важного поведения, управляемого событиями, для описания поведения системы
    можно использовать диаграммы состояний. Дополнительная информация приведена в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">Рекомендация: Диаграмма состояний</a>.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Упрощение диаграмм последовательности с помощью подсистем (необязательно)</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Simplify Sequence Diagrams Using Subsystems (optional)" name="Simplify Sequence Diagrams Using Subsystems (optional)"></a> 
<p>
    В процессе реализации варианта использования поток событий, как правило, описывается с учетом выполняемых объектов,
    т.е. в качестве взаимодействия между объектами проектирования. Для упрощения диаграмм и определения поведения,
    допускающего повторное использование, может потребоваться инкапсулировать дочерний поток событий в рамках подсистемы.
    Такой подход позволяет заменить большие разделы диаграммы последовательности на отдельное сообщение, передаваемое
    подсистеме. Для иллюстрации внутренних взаимодействий подсистемы, реализующих требуемое поведение, можно использовать
    отдельную диаграмму последовательности (дополнительная информация приведена в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html" guid="{CAA385CA-2BA2-40F2-8FE3-E21089D02119}">Задача: Проектирование подсистемы</a>).
</p>
<p>
    Подмножества последовательности сообщений на диаграммах последовательности следует заменять подсистемами в следующих
    случаях:
</p>
<ul>
    <li>
        Подмножество последовательности повторяется в различных реализациях варианта использования; т.е. совпадающие (или
        аналогичные) сообщения отправляются совпадающим (или аналогичным) объектам с одним и тем же результатом. Применение
        термина 'аналогичные' обусловлено тем, что для повторного применения поведения может потребоваться дополнительное
        проектирование.
    </li>
    <li>
        Подмножество последовательности встречается только в одной реализации варианта использования, однако его повторение
        ожидается в последующих итерациях или аналогичных системах. Поведение может оказаться хорошим многоразовым
        компонентом.
    </li>
    <li>
        Сложное подмножество последовательности встречается только в одной реализации варианта использования, однако его
        можно легко инкапсулировать, оно является предметом ответственности одного сотрудника или группы и позволяет
        получить конкретный результат. В таких ситуациях сложное поведение, как правило, требует специальных технических
        знаний, либо простой инкапсуляции в рамках подсистемы.
    </li>
    <li>
        Подмножество последовательности подлежит инкапсуляции в заменяемом компоненте (см. раздел <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/component_A2E2B3B1.html" guid="3.524150980437479E-305">Концепция: Компонент</a>). В этом случае подсистема является подходящим
        представлением компонента в модели проектирования.
    </li>
</ul>
<p align="center">
    <img height="121" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/seqdiag6.gif" width="409" border="0" />
</p>
<p class="picturetext">
    При необходимости реализацию варианта использования можно описать на нескольких уровнях иерархической структуры
    подсистемы. Генеральные линии на средней диаграмме представляют подсистемы; обведенные взаимодействия - это внутренние
    взаимодействия элементов подсистемы в ответ на получение сообщения.
</p>
<p>
    Данных подход обладает следующими преимуществами:
</p>
<ul>
    <li>
        Реализации вариантов использования становятся менее запутанными (в особенности, для подсистем со сложной внутренней
        структурой).
    </li>
    <li>
        Реализации вариантов использования можно создать перед внутренним проектированием подсистем; например, такая
        возможность полезна в параллельных средах разработки (см. раздел "<a href="#How to Work in Parallel">Параллельная работа</a>").
    </li>
    <li>
        Реализации вариантов использования становятся более общими и легко изменяемым (в особенности если подсистемы
        требуется заменить на другие подсистемы).
    </li>
</ul>
<p class="exampleheading">
    Пример:
</p>
<p class="example">
    Обратитесь к следующей диаграмме последовательности, которая принадлежит реализации варианта использования <b>местного
    звонка</b>:
</p>
<p align="center">
    <img height="396" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/seqdiag7.gif" width="729" />
</p>
<p class="example">
    На этой диаграмме серые классы принадлежат подсистеме Операции сети; остальные классы - подсистеме Операции абонента. В
    данном случае приведена диаграмма последовательности с несколькими подсистемами, т.е. диаграмма, на которой
    представлены все объекты, принимающие участие в потоке событий, независимо от принадлежности их классов.
</p>
<p class="example">
    В качестве альтернативы можно привести поведение вызова в подсистеме Операции сети и рассмотреть работу конкретного
    интерфейса этой подсистемы. Предположим, что подсистема Операции сети предоставляет интерфейс ICoordinator, применяемый
    подсистемой Операции абонента:
</p>
<p align="center">
    <img height="100" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/subs_if.gif" width="425" />
</p>
<p class="example">
    Интерфейс ICoordinator реализован классом Coordinator подсистемы Операции сети. Таким образом, подсистему Операции сети
    и ее интерфейс ICoordinator можно использовать на диаграмме последовательности вместо экземпляров классов подсистемы
    Операции сети.
</p>
<p align="center">
    <img height="417" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/guidances/guidelines/resources/seqdiag1.gif"     width="672" />
</p>
<p class="example">
    Обратите внимание, что экземпляры классов Coordinator, Digit Information, и Network заменены содержащей их подсистемой.
    Все вызовы подсистемы выполняются с помощью интерфейса ICoordinator.
</p>
<h4>
    Отображение интерфейсов в генеральных линиях
</h4>
<p>
    Для обеспечения возможности замены подсистем, реализующих один и тот же интерфейс, во взаимодействиях (а в общем случае
    и на диаграммах) должны быть видимы только взаимодействия; в противном случае после замены подсистем потребуется внести
    дополнительные изменения во взаимодействия (или диаграммы).
</p>
<p class="exampleheading">
    Пример:
</p>
<p class="example" align="left">
    Для добавления доступен только интерфейс ICoordinator, однако он не представляет подсистему на диаграмме
    последовательности:
</p>
<p align="center">
    <img height="309" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/seqdiag2.gif" width="519" />
</p>
<p class="example">
    Отправка сообщения генеральной линии интерфейса означает, что вместо реализующей этот интерфейс подсистемы на диаграмме
    можно указать интерфейс. Обратите внимание, что генеральная линия интерфейса ICoordinator не содержит исходящих
    сообщений, поскольку различные подсистемы, реализующие этот интерфейс, могут отправлять разные сообщения. Однако
    сообщения, отправляемые из реализующей интерфейс подсистемы, при необходимости можно описать как исходящие сообщения
    генеральной линии интерфейса.
</p>
<h4>
    <a id="How to Work in Parallel" name="How to Work in Parallel">Параллельная работа</a>
</h4>
<p>
    В некоторых случаях оптимальным выбором является независимая разработка подсистем параллельно с разработкой других
    подсистем. Для этого в первую очередь необходимо найти зависимости подсистем, определив интерфейсы между ними.
</p>
<p>
    Соответствующая процедура может выглядеть следующим образом:
</p>
<ol>
    <li>
        Рассмотрите требования, влияющие на интерфейсы между подсистемами.
    </li>
    <li>
        Создайте схематическое представление требуемых интерфейсов с указанием сообщений, пересекающих границы подсистем.
    </li>
    <li>
        Нарисуйте диаграммы последовательности с учетом подсистем для каждого варианта использования.
    </li>
    <li>
        Уточните интерфейсы, необходимые для передачи сообщений.
    </li>
    <li>
        Приступите к параллельной разработке подсистем, используя интерфейсы в качестве инструментов синхронизации между
        группами разработки.
    </li>
</ol>
<p>
    Кроме того, на диаграммах последовательности можно использовать подсистемы или только интерфейсы подсистем. В некоторых
    проектах может потребоваться реализовать классы, предоставляющие интерфейсы, перед продолжением моделирования.<br />
    <br />
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Описания поведения, связанного с постоянным хранением</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_persistent_object__describing" name="XE_persistent_object__describing"></a><a id="Describe Persistence-Related Behavior" name="Describe Persistence-Related Behavior"></a> 
<p>
    Основная цель объектно-ориентированного подхода заключается в <b>инкапсуляции</b> подробностей реализации. Таким
    образом, по отношению к постоянному хранению рассматриваемые постоянные объекты должны выглядеть <b>аналогично</b>
    временным объектам. Мы не должны учитывать необходимость постоянного хранения объектов. Кроме того, они должны
    обрабатываться также как и остальные объекты. По крайней мере такова наша цель.
</p>
<p>
    Фактически же в некоторых случаях приложение должно контролировать различные аспекты постоянного хранения:
</p>
<ul>
    <li>
        время чтения и записи постоянных объектов
    </li>
    <li>
        время удаления постоянных объектов
    </li>
    <li>
        способ управления транзакциями
    </li>
    <li>
        способ управления блокировкой и параллелизмом
    </li>
</ul>
<h4>
    <a id="Writing Persistent Objects" name="Writing Persistent Objects">Запись постоянных объектов</a>
</h4>
<p>
    Следует рассмотреть два случая: первая операция записи постоянного объекта в хранилище постоянных объектов и
    последующие операции записи, выполняемые приложением для обновления хранилища постоянных объектов внесенными
    изменениями.
</p>
<p>
    В обоих случаях конкретные механизмы зависят от операций, поддерживаемых средой постоянного хранения. Как правило,
    постоянный объект создается путем отправки соответствующего сообщения в среду постоянного хранения. После этого среда
    постоянного хранения отслеживает все изменения, вносимые в постоянный объект, и записывает их в хранилище постоянных
    объектов (как правило, в ходе фиксации транзакции).
</p>
<p>
    Пример создания постоянного объекта приведен ниже:
</p>
<p align="center">
    <img height="230" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/vbos1.gif" width="325" />
</p>
<p class="picturetext" align="center">
    Объект PersistenceMgr - это экземпляр среды постоянного хранения VBOS. OrderCoordinator создает заказ путем отправки
    сообщения 'createPersistentObject' объекту PersistenceMgr.
</p>
<p>
    <b>В основном</b> данное поведение не требуется моделировать явным образом. Исключение составляет тот случай, когда
    требуется явным образом указать, что объект сохраняется на конкретном этапе последовательности событий. Если
    последующие операции обращаются к объекту, он должен существовать в базе данных; в этом случае важно знать, что объект
    существует в ней.
</p>
<h4>
    <a id="Reading Persistent Objects" name="Reading Persistent Objects">Чтение постоянных объектов</a>
</h4>
<p>
    Приложение может отправить сообщение постоянному объекту только после того, как он будет извлечен из хранилища
    постоянных объектов. В объектно-ориентированной системе для этой цели объектам отправляются сообщения. Однако если
    целевой объект еще не загружен в память из базы данных, возникает неполадка: сообщение нельзя отправить несуществующему
    получателю!
</p>
<p>
    Таким образом, требуется отправить сообщение объекту, отвечающему за обращение к базе данных, а также извлечение и
    создание экземпляра нужного объекта. Только в этом случае сообщение можно отправить в исходном виде. Объект, который
    создает экземпляр постоянного объекта, называется объектом <i>фабрики</i>. Объект <b>фабрики</b> отвечает за создание
    экземпляров объектов, в том числе постоянных объектов. Если запрос известен, то <b>фабрика</b> может возвращать набор
    объектов, соответствующих критериям запроса.
</p>
<p>
    Как правило, объекты связываются друг с другом с помощью ассоциаций. По этой причине достаточно извлечь только
    <b>корневой</b> объект; остальные объекты извлекаются из базы данных в соответствии с ассоциациями с корневым объектом.
    (Для эффективного механизма постоянного хранения характерна следующая особенность: он извлекает объекты только по мере
    необходимости; в противном случае может быть создано большое число ненужных экземпляров объектов. Преждевременное
    извлечение объектов - это одна из основных проблем производительности простых механизмов управления постоянными
    объектами.)
</p>
<p>
    Следующий пример показывает, каким образом можно смоделировать извлечение объектов из хранилища постоянных объектов. На
    реальной диаграмме последовательности объект DBMS не будет показан, поскольку он будет входить в состав объекта
    <b>фабрики</b>.
</p>
<p align="center">
    <img height="297" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/retriev.gif" width="489" />
</p>
<h4>
    <a id="Deleting Persistent Objects" name="Deleting Persistent Objects">Удаление постоянных объектов</a>
</h4>
<p>
    Как это ни парадоксально, но основная проблема постоянных объектов - их постоянное хранение! В отличие от временных
    объектов, которые исчезают по завершении родительского процесса, постоянные объекты существуют до тех пор, пока не
    будут удалены явным образом. Таким образом, важное значение имеет удаление ненужных объектов.
</p>
<p>
    Трудности связаны с определением необходимости удаления. Завершение обработки одним приложением не означает, что объект
    не нужен другим приложениям. Кроме того, поскольку объекты могут содержать неизвестные ассоциации, в некоторых случаях
    достаточно сложно определить, можно ли удалить объект.
</p>
<p>
    В процессе проектирования такую ситуацию можно представить с помощью <b>диаграмм состояний</b>: при достижении объектом
    <b>конечного</b> состояния его можно <b>разблокировать</b>. Разработчики, отвечающие за реализацию постоянных классов,
    в соответствии с диаграммами состояний могут вызвать подходящее поведение для разблокировки объекта. Проектировщик
    реализации варианта использования отвечает за вызов операций, переводящих объект в <b>конечное</b> состояние,
    непосредственно перед удалением объекта.
</p>
<p>
    Если объект связан с большим числом других объектов, возможность его удаления может быть сложно определить. Поскольку
    объекту <b>фабрики</b> известна структура удаляемого объекта и связанных с ним объектов, в большинстве случаев в
    объекте фабрики можно предусмотреть класс, отвечающий за проверку возможности удаления конкретного экземпляра. Кроме
    того, поддержку такой функции может предоставлять среда постоянных объектов.
</p>
<h4>
    <a id="Modeling Transactions" name="Modeling Transactions">Моделирование транзакций</a>
</h4>
<p>
    Транзакции описывают набор вызовов <b>атомарных</b> операций; выполняются все операции, либо ни одна из них. В
    контексте постоянных объектов транзакция описывает набор изменений, вносимых в набор объектов; выполняются все
    изменения, либо ни одно из них. Транзакции обеспечивают согласованность, т.е. наборы объектов переходят из одного
    согласованного состояния в другое.
</p>
<p>
    В реализациях вариантов использования транзакции могут быть представлены несколькими способами:
</p>
<ul>
    <li>
        <b>В текстовом виде</b>. С помощью сценариев на полях диаграммы последовательности; границы транзакций могут быть
        описаны, как это показано ниже. Это простой способ, позволяющий использовать для реализации транзакции произвольное
        число механизмов.
    </li>
</ul>
<p align="center">
    <img height="466" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/txn1.gif" width="496" />
</p>
<p class="picturetext">
    Представление границ транзакций с помощью текстовых аннотаций.
</p>
<ul>
    <li>
        <b>С помощью явных сообщений</b>. Если механизм управления транзакциями предусматривает применение явных сообщений
        для запуска и завершения транзакций, то эти сообщения можно представить на диаграмме последовательности, как это
        показано ниже:
    </li>
</ul>
<p align="center">
    <img height="575" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/txn2.gif" width="558" />
</p>
<p class="picturetext">
    Диаграмма последовательности, на которой показаны явные сообщения, запускающие и завершающие транзакции.
</p>
<h4>
    <a id="Handling Error Conditions" name="Handling Error Conditions"></a>Обработка ошибок
</h4>
<p>
    Если можно выполнить не все операции, указанные в транзакции (как правило, вследствие ошибки), транзакция
    <b>прерывается</b> с отменой всех внесенных изменений. Ожидаемые ошибки представляют исключительные потоки событий в
    вариантах использования. Кроме того, ошибки могут быть связаны со сбоем системы. Ошибки должны быть описаны во
    взаимодействиях. Простые ошибки и исключительные ситуации можно показать непосредственно во взаимодействии; сложные
    ошибки и исключительные ситуации могут потребовать создания собственных взаимодействий.
</p>
<p>
    На диаграммах состояния можно представить режимы сбоев конкретных объектов. Условный поток управления, обрабатывающий
    эти режимы сбоев, можно показать во взаимодействии, в котором возникает ошибка или исключительная ситуация.
</p>
<h4>
    <a id="Handling Concurrency Control" name="Handling Concurrency Control">Управление параллелизмом</a>
</h4>
<p>
    Параллелизм описывает особенности управления доступом к критически важным ресурсам системы в ходе транзакции. Для
    сохранения согласованного состояния системы транзакция может предусматривать исключительный доступ к отдельным ресурсам
    системы. Например, возможность чтения набора объектов, возможность записи набора объектов, либо оба варианта.
</p>
<p>
    Рассмотрим простой пример, в котором требуется ограничить доступ к набору объектов. Предположим, что применяется
    простая система ввода заказов, обрабатывающая поступающие звонки от клиентов. Заказ можно рассматривать в качестве
    транзакции.
</p>
<p>
    В качестве наглядного примера управления параллелизмом предположим, что поступает заказ на пару кроссовок. В процессе
    приема заказа система проверяется размер кроссовок, а также их наличие на складе. Если кроссовки есть в наличии, они
    <b>резервируются</b>, чтобы другие клиенты не смогли приобрести их до отправки заказа. После отправки заказа кроссовки
    удаляются из хранилища.
</p>
<p>
    В период между оформлением заказа и его отправкой для кроссовок указывается специальное состояние; они находятся на
    складе, но "привязаны" к заказу. В случае отмены заказа (например, если клиент передумал или срок действия кредитной
    карты истек) кроссовки возвращаются на склад. После доставки заказа предполагается, что компания не ведет протокол
    отправляемых товаров.
</p>
<p>
    Основная цель параллелизма - обеспечения перехода системы из одного согласованного состояния в другое. Кроме того,
    параллелизм отвечает за выделение ресурсов, необходимых для выполнения транзакций. Существует множество способов
    реализации управления параллелизмом, в том числе блокировка ресурсов, семафоры, триггеры общей памяти и личные рабочие
    области.
</p>
<p>
    В объектно-ориентированной системе трудно определить, основываясь только на шаблоне сообщения, предусматривает ли
    конкретное сообщение изменение состояния объекта. Кроме того, различные реализации могут скрывать необходимость
    ограничения доступа к отдельным типам ресурсов; например, некоторые реализации в начале транзакции предоставляют
    собственное представление состояния системы. В этом случае прочие процессы могут изменять состояние объекта, не влияя
    на 'представление' активных транзакций.
</p>
<p>
    Во избежание ограничения реализации в процессе проектирования достаточно указать ресурсы, требующие исключительного
    доступа во время выполнения транзакции. В рамках примера, приведенного выше, необходимо указать, что требуется
    исключительный доступ к заказанным кроссовкам. В качестве одного из возможных вариантов можно уточнить описание
    отправляемого сообщения, указав необходимость исключительного доступа к объекту. В соответствии с этой информацией
    ответственный за реализацию может определить оптимальный способ реализации требования параллелизма. Ниже приведен
    пример диаграммы последовательности, на которой показаны сообщения, требующие исключительного доступа. Предполагается,
    что по завершении транзакции все блокировки удаляются.
</p>
<p align="center">
    <img height="569" alt="Диаграмма, описанная в тексте." src="./../../core.base_rup/tasks/resources/locking.gif" width="630" />
</p>
<p class="picturetext">
    Пример управления доступом с помощью комментариев.
</p>
<p>
    Ограничение доступа ко всем объектам транзакции не применяется, поскольку в большинстве случаев такие ограничения
    характерны только для небольшого числа объектов; ограничение доступа ко всем ресурсам связано с неэффективным
    использованием ресурсов и может привести к образованию узких мест производительности.<br />
    <br />
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Уточнение описания потока событий</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Refine the Flow of Events Description" name="Refine the Flow of Events Description"></a> 
<p>
    На диаграммы последовательности потока событий реализации варианта использования может потребоваться добавить
    дополнительное описание, если предназначение потока событий нельзя определить путем проверки сообщений, отправляемых
    между взаимодействующими объектами. Например, для облегчения читаемости диаграмм можно указать комментарии о времени,
    примечания об условном поведении и уточнения поведения операции.
</p>
<p>
    Начальное схематичное представление потока событий приведено в разделе <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Задача: Анализ
    вариантов использования</a>. На этом этапе поток событий дополнительно уточняется для более подробного описания
    диаграмм последовательности.
</p>
<p>
    Как правило, только в соответствии с именем операции нельзя определить причину ее выполнения. Текстовые примечания или
    сценарии на полях диаграммы позволяют уточнить диаграмму последовательности. Кроме того, текстовые примечания и
    сценарии могут описывать поток управления, например, решения, циклы и разветвления. Точки расширения в варианте
    использования связываются с конкретными расположениями на диаграммах последовательности с помощью текстовых тегов.
</p>
<p>
    Различные способы добавления комментариев на диаграммы последовательности приведены в предыдущих примерах этого
    раздела.
</p><br />
<br /></td>
</tr>
</table>
</div>
<div class="stepHeading"> Унификация классов и подсистем проектирования</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_design_subsystem__unifying" name="XE_design_subsystem__unifying"></a><a id="Unify Classes and Subsystems" name="Unify Classes and Subsystems"></a>
<p>
    В процессе реализации вариантов использования возникает необходимость унификации классов и подсистем проектирования для
    обеспечения однородности и согласованности <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">модели
    проектирования</a>.
</p>
<p>
    Рекомендации:
</p>
<ul>
    <li>
        Имена элементов модели должны должны описывать их функции.
    </li>
    <li>
        Избегайте похожих имен и синонимов, поскольку элементы модели с такими именами трудно отличить друг от друга.
    </li>
    <li>
        Объединяйте элементы модели с аналогичным поведением, а также элементы, описывающие один и тот же эффект.
    </li>
    <li>
        Объединяйте сущностные классы с одинаковыми атрибутами, а также классы, представляющие одинаковые концепции; при
        этом поведение может быть разным.
    </li>
    <li>
        Используйте наследование для повышения уровня абстракции элементов модели, повышая тем самым устойчивость модели.
    </li>
    <li>
        Вместе с элементом модели следует обновлять описание потока событий реализаций вариантов использования.<br />
    </li>
</ul></td>
</tr>
</table>
</div>
<div class="stepHeading"> Оценка результатов</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Evaluate Your Results" name="Evaluate Your Results"></a> 
<p>
    На этом этапе следует проверить модель проектирования и убедиться, что работа выполняется в правильном направлении.
    Подробная проверка при этом не требуется; достаточно контроля <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/design_model_18BE347C.html" guid="1.4639852935143625E-305">модели
    проектирования</a> в ходе работы с ней.
</p>
<p>
    Рекомендуется обратиться к подразделу <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/use-case_realization_444C8317.html" guid="9.828360528787822E-305">Реализация
    вариантов использования</a> раздела <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/review_the_design_34CB80A9.html" guid="{9574768B-7886-40C9-9938-A7E36E9B0739}">Задача: Проверка
    проектирования</a>.
</p></td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Свойства</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Несколько вхождений" abbr="Несколько вхождений">Несколько вхождений</th><td align="left" class="sectionTableCell" headers="property_Несколько вхождений"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Управляется событиями" abbr="Управляется событиями">Управляется событиями</th><td align="left" class="sectionTableCell" headers="property_Управляется событиями"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Выполняющийся" abbr="Выполняющийся">Выполняющийся</th><td align="left" class="sectionTableCell" headers="property_Выполняющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Необязательный" abbr="Необязательный">Необязательный</th><td align="left" class="sectionTableCell" headers="property_Необязательный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Запланированный" abbr="Запланированный">Запланированный</th><td align="left" class="sectionTableCell" headers="property_Запланированный"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_Повторяющийся" abbr="Повторяющийся">Повторяющийся</th><td align="left" class="sectionTableCell" headers="property_Повторяющийся"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
					contentPage.onload();
					contentPage.processPage.fixDescriptorLinks();
				</script>
</html>
