<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Концепция: Механизм проектирования и реализации.</title>
<meta content="Concept" name="uma.type">
<meta content="design_and_implementation_mechanisms" name="uma.name">
<meta content="Механизм проектирования и реализации." name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "6.131233324119695E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="6.131233324119695E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Концепция: Механизм проектирования и реализации.</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Механизм проектирования добавляет детали в механизм концептуального анализа, но ему не хватает определенной технологии.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}">Определение механизмов проектирования</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_software_architect_DB0BF177.html" guid="{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}">Разработчик архитектуры</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a> 
<h3>
    <a id="Introduction to Design and Implementation Mechanisms" name="Introduction to Design and Implementation Mechanisms">Введение в механизмы проектирования и реализации.</a>
</h3>
<p>
    <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_mechanism_5F46BEF2.html" guid="_yF4Ck9nmEdmO6L4XMImrsA">Механизм проектирования</a> - это уточнение соответствующего <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/analysis_mechanism_4DAA970A.html" guid="_x6stV9nmEdmO6L4XMImrsA">механизма анализа</a> (См. также <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/analysis_mechanisms_36135B43.html" guid="9.76539014099254E-305">концепция:
    механизм анализа</a>). Механизм проектирования добавляет конкретные детали к механизму концептуального анализа, но ему
    не хватает определенной технологии, например, реализации определенного поставщика или, скажем, объектно ориентированной
    СУБД. Как и механизм анализа, механизм проектирования может создавать шаблоны, в данном случае <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/architectural_pattern_E2E8EB79.html" guid="_x7JZRtnmEdmO6L4XMImrsA"><b>архитектурные шаблоны</b></a>&nbsp; или <b><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_pattern_4AEB9B64.html" guid="_yF4CnNnmEdmO6L4XMImrsA">шаблоны
    проектов</a></b><i>.</i>
</p>
<p>
    Подобным образом <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/implementation_mechanism_59389269.html" guid="_yKfc2dnmEdmO6L4XMImrsA">механизм реализации</a> - это уточнение соответствующего механизма проектирования,
    например, с помощью определенного языка программирования или другой технологии реализации как, например, промежуточное
    программное обеспечение определенного поставщика. Механизм реализации может создавать <b><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/idiom_6D91029A.html" guid="_yKVr0tnmEdmO6L4XMImrsA">языки</a></b> или шаблоны реализации.
</p>
<h3>
    <a id="XE_design_mechanism__characteristics_of" name="XE_design_mechanism__characteristics_of"></a><a id="Example: Characteristics of Design Mechanisms" name="Example: Characteristics of Design Mechanisms">Пример:
    Параметры механизмов проектирования</a>
</h3>
<p>
    Рассмотрим механизм анализа для <b>поддержки постоянных объектов</b>:
</p>
<ul>
    <li>
        Предположим, необходимо хранить 2000 маленьких объектов размеров 200 байт каждый в течение нескольких секунд без
        необходимости последующего сохранения.
    </li>
    <li>
        Также, необходимо постоянно хранить несколько очень больших объектов в течение нескольких месяцев. Обновлять их не
        требуется, но доступ к ним осуществляется по сложной технологии.
    </li>
</ul>
<p>
    <a id="inventory" name="inventory"></a>Эти объекты требуют различных средств для хранения. Можно указать следующие
    параметры механизмов проектирования для поддержки хранения:
</p>
<ul>
    <li>
        <b>Хранение внутри памяти</b>; параметры: общий размер - до 1 Мб (размер умножить на количество); быстрый доступ
        для чтения, записи и обновления.
    </li>
    <li>
        <b>Карта флэш-памяти</b>; параметры: общий размер - до 8 Мб; низкая скорость обновления и записи; средняя скорость
        чтения.
    </li>
    <li>
        <b>Двоичный файл</b>; параметры: общий размер - от 100 Кб до 200 Мб; медленная скорость обновления; низкая скорость
        чтения и записи.
    </li>
    <li>
        <b>СУБД</b>; параметры: 100 Кб и более без ограничения; еще более низкая скорость обновления, чтения и записи.
    </li>
</ul>
<p>
    Обратите внимание, что эти скорости называются низкими только в сравнении со скоростью доступа к внутренней памяти.
    &nbsp;Также очевидно, что в некоторых средах время доступа можно уменьшить с помощью кэширования.
</p>
<p>
    <a id="mapping" name="mapping"></a>
</p>
<blockquote>
    <p align="center">
        <img height="221" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/co_dmec1.gif" width="372" />
    </p>
</blockquote><br />
<br />
<h3>
    <a id="XE_implementation_mechanism__mapping_from_design_mechanisms_refining" name="XE_implementation_mechanism__mapping_from_design_mechanisms_refining"></a><a id="XE_design_mechanism__mapping_to_implementation_mechanisms_refining" name="XE_design_mechanism__mapping_to_implementation_mechanisms_refining"></a><a id="Refining the Mapping between Design and Implementation Mechanisms" name="Refining the Mapping between Design and Implementation Mechanisms">Уточнение записи преобразования между
    механизмами проектирования и реализации</a>
</h3>
<p>
    Первоначально запись преобразования между механизмами проектирования и реализации скорее всего будет не оптимальна, но
    позволит выполнять проект и укажет неизвестные до этого риски, а также стимулирует дальнейшие поиски и исследования. В
    дальнейшем с увеличением объема знаний в проекте необходимо уточнить запись преобразования.
</p>
<p>
    Итеративно уточняйте запись преобразования между механизмами проектирования и реализации, убирая избыточные пути и
    работая как "сверху-вниз", так и "снизу-вверх".
</p>
<p>
    <b>Работа сверху-вниз</b> При работе сверху-вниз новые и уточненные реализации вариантов выбора определяют новые
    требования для необходимых механизмов проектирования с помощью необходимых механизмов анализа. Эти новые требования
    могут помочь обнаружить дополнительные параметры механизма проектирования и вызвать разделение между механизмами.
    Также, есть следующие связи между сложностью системы и ее быстродействием:
</p>
<ul>
    <li>
        Излишнее количество механизмов проектирования делают систему слишком сложной.
    </li>
    <li>
        Недостаток механизмов проектирования может снизить быстродействие некоторых механизмов реализации вне разумных
        пределов.
    </li>
</ul>
<p>
    <b>Работа снизу-вверх</b> При работе снизу-вверх и поиске доступных механизмов реализации вероятно обнаружить продукты,
    удовлетворяющие одновременно сразу несколько механизмов проектирования, но они требуют адаптацию или перераспределение
    механизмов проектирования. Уменьшение количества используемых механизмов реализации может снизить производительность.
</p>
<p>
    Например, использовав СУБД для хранения объектов класса А, вы можете решить хранить таким же образом все объекты в
    системе. Это может оказаться очень неэффективно. Совсем не обязательно, что все объекты должны храниться в СУБД.
    Некоторые объекты могут постоянно храниться, но редко использоваться большинством приложений. Наилучшей стратегией
    может быть чтение объекта из СУБД в память и его периодическая синхронизация.
</p>
<p class="example">
    <b>Пример</b>
</p>
<p class="example">
    Информация о полете может храниться в памяти для быстрого доступа и в СУБД для длительного хранения. Это, однако,
    вызывает необходимость наличия механизма для синхронизации.
</p>
<p>
    Часто имеется более одного механизма проектирования, связанного с клиентским классом для удовлетворения разным
    параметрам.
</p>
<p>
    По причине того, что механизмы реализации часто поставляются комплектами в коробочных продуктах (операционные системы и
    промежуточное программное обеспечение), необходимо проводить оптимизацию, основанную на стоимости, разнице в
    сопротивлении или единообразия стиля. Также, механизмы часто взаимозависимы, что делает трудным четкое разделение служб
    в механизмах проектирования.
</p>
<p class="example">
    <b>Примеры</b>
</p>
<blockquote>
    <ul>
        <li>
            <p class="example">
                Механизм уведомления может быть основан на механизме межпроцессных связей.
            </p>
        </li>
        <li>
            <p class="example">
                Механизм сообщений об ошибках может быть основан на механизме поддержки постоянных объектов.
            </p>
        </li>
    </ul>
</blockquote>
<p>
    Процесс уточнения продолжается в течение всего этапа совершенствования и всегда необходимо искать решение,
    балансирующее следующие условия:
</p>
<ul>
    <li>
        Точное соответствие требованиям клиентов механизма проектирования в терминах ожидаемых параметров.
    </li>
    <li>
        Стоимость и сложность большого числа приобретаемых и объединяемых механизмов реализации.
    </li>
</ul>
<p>
    Общая задача - иметь простой и понятный набор механизмов, который бы обеспечивал концептуальную целостность, простоту и
    четкость большой системе.
</p>
<h3>
    <a id="XE_implementation_mechanism__mapping_from_design_mechanisms_examples" name="XE_implementation_mechanism__mapping_from_design_mechanisms_examples"></a><a id="XE_design_mechanism__mapping_to_implementation_mechanisms_examples" name="XE_design_mechanism__mapping_to_implementation_mechanisms_examples"></a><a id="Example: Mapping Design Mechanisms to Implementation Mechanisms" name="Example: Mapping Design Mechanisms to Implementation Mechanisms">Пример: Запись преобразования между механизмами
    проектирования и механизмами реализации</a>
</h3>
<p>
    <b>Постоянные</b> механизмы проектирования могут быть преобразованы в механизмы реализации следующим образом:
</p>
<p align="center">
    <img height="216" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/co_dmec2.gif" width="325" />
</p>
<p>
    Возможная запись преобразования между механизмами анализа и механизмами проектирования. Пунктирные указатели обозначают
    "уточнение", подразумевая, что параметры механизма проектирования наследуются от механизм анализа, но будут перечислены
    и уточнены.
</p>
<p>
    После завершения оптимизации механизмов существует следующие записи преобразования:
</p>
<blockquote>
    <p align="center">
        <img height="110" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/co_dmec3.gif" width="418" />
    </p>
    <p class="picturetext">
        Проектные решения для класса клиента в терминах записей преобразования между механизмами; класс информации о
        полетах требует два типа хранения: хранение внутри памяти, реализованное с помощью готовых библиотечных процедур и
        хранение в базе данных, реализованное с помощью коробочного продукта ХранениеОбъектов.
    </p>
</blockquote>
<p>
    Отображение должно обладать проходимостью в обоих направлениях, чтобы можно было легко определять классы клиентов при
    изменении механизмов реализации.
</p>
<h3>
    <a id="XE_design_mechanism__describing" name="XE_design_mechanism__describing"></a><a id="Describing Design Mechanisms" name="Describing Design Mechanisms">Описание механизмов проектирования</a>
</h3>
<p>
    Механизмы проектирования и подробная информация о их использовании содержится в документации<a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рабочий продукт: Рекомендации, связанные с проектами</a>. Информация об
    отношениях (или записях преобразования) механизмов анализа к механизмам проектирования и механизмам реализации и
    связанные обоснования для этих выборов находится в документации <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html" guid="{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}">Рабочий продукт: Документация по архитектуре программного
    обеспечения</a>.
</p>
<p>
    Так же, как и механизм анализа, механизм проектирования можно моделировать с помощью кооперирования, которое может
    производить <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/architectural_pattern_E2E8EB79.html" guid="_x7JZRtnmEdmO6L4XMImrsA"><b>архитектурные шаблоны</b></a> или<b><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_pattern_4AEB9B64.html" guid="_yF4CnNnmEdmO6L4XMImrsA">шаблоны
    проектов</a>.</b>
</p>
<h4>
    Пример: Механизм хранения
</h4>
<p>
    Этот пример использует экземпляр шаблона для хранения с помощью реляционной СУБД и взят из <a href="http://java.sun.com/products/jdbc/index.html" target="_blank">JDBC&trade; (Java Data Base Connectivity)</a>.&nbsp; Хотя
    здесь приводится проект, JDBC предоставляет исходный код для некоторых классов, таким образом то, что приведено здесь
    находится близко от механизма реализации.
</p>
<p>
    Изображение Статического вида: JDBC показывает классы в кооперировании (строго, в соответствии с классификатором).
</p>
<p align="center">
    <img height="382" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/jdbc1.gif" width="571" border="0" />
</p>
<p align="center">
    <b>Статический вид: JDBC</b>
</p>
<p align="left">
    Классы, помеченные желтым цветом, были предоставлены, остальные (myDBClass и т.д.) - были связаны проектировщиком для
    создания механизма.
</p>
<p align="left">
    В JDBC клиент работает с классом <b>DBClass</b> при чтении или записи постоянных данных. Класс DBClass отвечает за
    доступ к базе данных JDBC с помощью класса <b>DriverManager</b>. При открытии базы данных <b>Соединение</b> класс
    DBClass может создавать операторы SQL, посылаемые в основную реляционную СУБД и выполняемые с помощью класса
    <b>Операторы</b>. Класс Операторы "разговаривает" с базой данных. Результат запроса SQL выдается в объект
    <b>НаборРезультатов</b><span style="mso-spacerun: yes">. &nbsp;</span>
</p>
<p align="left">
    Класс <b>DBClass</b> отвечает за постоянное хранение экземпляра другого класса. Он распознает отношение OO-реляционная
    СУБД и обладает поведением для взаимодействия с реляционной СУБД. Класс DBClass преобразовывает объект, записывает его
    в реляционную СУБД, считывает данные объекта<span style="mso-spacerun: yes">&nbsp;</span> из реляционной СУБД и
    компонует объект. Каждый постоянно хранящийся класс будет иметь соответствующий класс DBClass. &nbsp;
</p>
<p align="left">
    <b>СписокПостоянныхКлассов</b> используется для выдачи набора постоянных объектов при запросе базы данных (например,
    DBClass.read()).
</p>
<p align="left">
    Ниже показаны несколько динамических представлений для демонстрации работы механизма.
</p>
<p align="center">
    <img height="146" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/jdbc2.gif" width="285" border="0" />
</p>
<p align="center">
    <b>JDBC: инициализация</b>
</p>
<p>
    Перед тем, как какой-либо постоянный класс может быть доступен, должна произойти его инициализация.
</p>
<p>
    Для инициализации соединения с базой данных класс DBClass должен загрузить соответствующий драйвер, вызвав операцию
    администратора драйверов getConnection(), указав URL, пользователя и пароль.
</p>
<p>
    Операция getConnection() пробует установить соединение с указанным URL базы данных. Администратор драйверов пытается
    выбрать соответствующий драйвер из набора зарегистрированных драйверов JDBC.
</p>
<p>
    <i>Параметры:</i>
</p>
<p>
    <b>url</b>: url формы базы данных jdbc:subprotocol:subname. Этот URL используется для обнаружения текущего сервера базы
    данных и в этом случае не относится к Web.
</p>
<p>
    <b>пользователь</b>: пользователь базы данных, от чьего имени производится соединение
</p>
<p>
    <b>пароль</b>: пароль пользователя
</p>
<p>
    <i>Возвращаемое значение</i>:
</p>
<p>
    соединение с URL.
</p>
<p align="center">
    <img height="253" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/jdbc3.gif" width="478" border="0" />
</p>
<p align="center">
    <b>JDBC: Создать</b>
</p>
<p align="left">
    Для создания класса агент хранения запрашивает класс DBClass. Класс DBClass создает экземпляр постоянного класса со
    значениями по умолчанию. Класс DBClass затем создает оператор с помощью операции createStatement() класса соединения.
    Оператор выполняется и данные включаются в базу данных.
</p>
<p align="center">
    <img height="352" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/jdbc4.gif" width="627" border="0" />
</p>
<p align="center">
    <b>JDBC: Чтение</b>
</p>
<p>
    Для чтения постоянного класса клиент хранения запрашивает у класса DBClass операцию чтения. Класс DBClass создает
    оператор с помощью операции createStatement() класса соединения. Оператор выполняется, и данные записываются в объект
    НаборРезультатов. Класс DBClass создает экземпляр постоянного класса и заполняет его полученными данными. Данные
    записываются в объект коллекции - экземпляр класса СписокПостоянногоКласса.
</p>
<p>
    Примечание: строка, передаваемая в executeQuery() не обязательно та же самая, что и передаваемая в read(). Класс
    DBClass компонует запрос SQL для получения данных, хранимых базой данных с помощью параметра оператора read(). Это
    делается для того чтобы клиенту класса DBClass не потребовалось информация о внутренних характеристиках базы данных для
    создания правильного запроса. Эта информация скрыта внутри класса DBClass.
</p>
<p align="center">
    <img height="255" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/jdbc5.gif" width="473" border="0" />
</p>
<p align="center">
    <b>JDBC: Обновление</b>
</p>
<p>
    Для обновления постоянного класса клиент хранения запрашивает у класса DBClass операцию обновления. Класс DBClass
    получает данные из объекта постоянного класса и создает оператор с помощью операции createStatement() класса
    соединения. После компоновки оператора выполняется обновление и база данных обновляется информацией из класса.
</p>
<p>
    Помните: задачу упорядочивания постоянного класса и его записи в базу данных выполняет класс DBClass. Поэтому,
    необходимо сначала получить его из постоянного класса и затем создавать оператор SQL.
</p>
<p>
    Примечание: В описанном выше механизме постоянный класс должен обеспечить классу DBClass процедуру доступа ко всем
    хранящимся данным. Таким образом обеспечивается внешний доступ к определенным хранящимся атрибутам, которые в другом
    случае были бы недоступны. Это цена, которую необходимо платить для того чтобы извлечь хранящиеся данные из закрытого
    класса.
</p>
<p align="center">
    <img height="255" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/concepts/resources/jdbc6.gif" width="473" border="0" />
</p>
<p align="center">
    <b>JDBC: Удаление</b>
</p>
<p align="left">
    Для удаления постоянного класса клиент хранения запрашивает у класса DBClass операцию удаления. Класс DBClass создает
    оператор с помощью операции createStatement() класса соединения. Оператор выполняется и данные удаляются из базы
    данных.
</p>
<p align="left">
    При реализации этого проекта могут быть приняты решения о записи преобразований класса DBClass в постоянные классы,
    например, создание одного класса DBClass на один постоянный класс и размещение их в определенных пакетах. &nbsp;Эти
    пакеты будут иметь зависимости от предоставленных пакетов <i>java.sql</i> (Дополнительная информация содержится в <a href="http://java.sun.com/products/jdbc/index.jsp" target="_blank">Документации JDBC<font size="-2"><sup>&trade;</sup></font>
    API</a>), которые содержат поддерживающие классы - администратор драйверов, соединение, оператор и набор результатов.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
