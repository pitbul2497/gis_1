<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Концепция: Проектные тесты</title>
<meta content="Concept" name="uma.type">
<meta content="developer_testing" name="uma.name">
<meta content="Проектные тесты" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "7.256588791264849E-307"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="7.256588791264849E-307"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Концепция: Проектные тесты</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Данные рекомендации помогают преодолеть первые трудности создания проектных тестов и разработки комплекта тестов, который поддерживается в течение всего проекта. Также, рассказывается как создавать проектные тесты наилучшим образом.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/roles/rup_implementer_D145E819.html" guid="{75501BAA-0CCE-4852-A7B2-B10CA71C002A}">Реализатор</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_test__developer_testing__concept_of" name="XE_test__developer_testing__concept_of"></a><a id="XE_design__developer_testing__concept_of" name="XE_design__developer_testing__concept_of"></a> 
<h3>
    <a id="Introduction" name="Introduction"></a>Введение
</h3>
<p>
    Термин "Проектное тестирование" используется для обозначения задач тестирования, выполняемых разработчиками
    программного обеспечения. Также это включает создаваемые в рамках этих задач рабочие продукты. Проектное тестирование
    обычно включает следующие категории: функциональное тестирование, тестирование целостности и некоторые аспекты того,
    что обычно называют тестированием системы. Обычно проектное тестирование связано с задачами в дисциплине реализации, а
    также с задачами в дисциплине анализа и проектирования.
</p>
<p>
    Этот целостный подход позволяет снизить риски, связанные с традиционным, более раздробленным подходом. При традиционном
    подходе к проектному тестированию сначала проверяется работа всех компонентов по отдельности. На более поздних этапах
    жизненного цикла проекта, ближе к завершению разработки, компоненты объединяются в рабочие подсистемы или системы и
    первый раз тестируются вместе.
</p>
<p>
    Этот подход имеет ряд недостатков. Во первых, он способствует поэтапному подходу к тестированию объединяемых
    компонентов и позднее подсистем, и, поэтому ошибки выявляются слишком поздно. Т.к. ошибки выявляются поздно, обычно
    принимается решение не исправлять их, потому что это требует много работы. Это исправление является дорогостоящим и
    замедляет работу в других областях. Это увеличивает риски неудачи проекта.
</p>
<p>
    Во-вторых, при четком разграничении между функциональным тестированием, тестированием целостности и тестированием
    системы, возникает опасность, что ошибки, превосходящие эти ограничения, не будут вообще обнаружены. Риск
    увеличивается, если тестирование выполняется разными коллективами.
</p>
<p>
    RUP рекомендует стиль тестирования, когда разработчики выбирают наиболее важные аспекты тестирования в каждый момент
    времени. В рамках каждой итерации обычно более эффективно найти как можно больше неполадок в коде разработчика до
    передачи в группу тестирования. Это помогает добиться раннего обнаружения серьезных ошибок независимо от того, где
    находятся ошибки - в независимом компоненте, объединении компонентов или уже участвуют в сценарии, предназначенном для
    конечного пользователя.
</p>
<h3>
    <a id="DeveloperTestingPitfalls" name="DeveloperTestingPitfalls"></a>Заблуждения при начале работы с проектным
    тестированием
</h3>
<p>
    Многие разработчики, пытающиеся в начале выполнять тщательное тестирование, вскоре отказываются от этой задачи. Им
    кажется, что это не приносит ощутимых результатов. Также некоторые разработчики, успешно начинающие проектное
    тестирование оказываются в ситуации, когда созданный тестовый комплект не поддерживается и забрасывается.
</p>
<p>
    На этой странице содержаться рекомендации по преодолению первых трудностей создания проектных тестов и по созданию
    тестового комплекта и его успешной поддержки. Дополнительная информация приведена в документе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/maintaining_automated_test_suites_C1BF312D.html" guid="2.0721213907815595E-305">Рекомендации: Поддержка автоматизированных комплектов тестов</a>
</p>
<h4>
    Создайте ожидания
</h4>
<p>
    Те, кто считает проектное тестирование стоящим занятием, выполняют его. Те, кто рассматривает тестирование как рутину,
    старается избежать его. Это обычное явление для большинства разработчиков в большинстве отраслей, и не стоит
    рассматривать это просто как нехватку трудовой дисциплины, т.к. этим не достигается желаемый результат. Таким образом
    надо сделать все необходимое, чтобы процесс тестирования был стоящим и занимательным.
</p>
<p>
    В идеале проектное тестирование должно следовать четкому циклу тестирование-изменение. Даже после небольших изменений в
    продукте, например, добавление метода или класса, необходимо повторять тестирование. Если тест неуспешен, можно точно
    определить, где неисправность. Этот легкий и стабильный темп разработки - лучший результат проектного тестирования.
    Напротив, длинные сеансы отладки должны быть исключением.
</p>
<p>
    Так как изменения в одном классе могут вызвать неполадки в других, стоит проводить несколько соответствующих тестов, а
    не только тест измененного класса. В идеале стоит запускать несколько раз в час полный комплект тестов для компонента.
    Каждый раз после существенных изменений надо запускать комплект тестов, проверять результат и после этого следовать
    далее или исправлять последние изменения. Этот способ получать быструю обратную связь, разумеется, требует некоторых
    усилий.
</p>
<h4>
    Автоматизируйте тесты
</h4>
<p>
    Если тесты необходимо выполнять вручную, это не всегда удобно. Автоматизированные тесты удобны для некоторых
    компонентов. Примером может служить база данных, расположенная в памяти. Она взаимодействует с клиентами через API и не
    имеет других интерфейсов с внешним миром. Тест для нее будет выглядеть подобным образом:
</p>
<blockquote>
<pre>
  /* Убедитесь, что элемент может быть добавлен по крайней мере один раз. */
</pre>
<pre>
 // Установка
</pre>
<pre>
 Database db = new Database();
</pre>
<pre>
 db.add("key1", "value1");
</pre>
<pre>
 // Тест
</pre>
<pre>
 boolean result = db.add("key1", "another value");
</pre>
<pre>
 expect(result == false);
</pre>
</blockquote>
<p>
    Тесты отличаются только одним от обычного кода клиента - вместо того, чтобы верить результатам, выдаваемым API, они
    проверяют этот результат. Если API позволяет легко писать клиентский код, значит тестовый код также легко писать. Если
    писать тестовый код <i>не</i> легко, то вы получаете раннее предупреждение, что API надо улучшить. Итак, проектирование
    с ранним тестированием отражает подход RUP к работе с рисками на ранних стадиях.
</p>
<p>
    Также чем сильнее связь компонента с внешним миром, тем труднее будет его тестировать. Обычно есть два случая -
    графические пользовательские интерфейсы и базовые программы.
</p>
<h5>
    Графические пользовательские интерфейсы
</h5>
<p>
    Предположим, что база данных в примере, рассмотренном выше, получает данные через обратный вызов от объекта
    пользовательского интерфейса. Обратный вызов происходит когда пользователь заполняет текстовые поля и нажимает кнопку.
    Такой тип тестирования - это не то, что вы хотите делать несколько раз в час вручную. Необходимо организовать
    программный ввод, т.е. "нажатие" кнопки в коде.
</p>
<p>
    Нажатие кнопки вызывает выполнение определенного кода в компоненте. Очень вероятно, что этот код изменяет состояние
    некоторых объектов пользовательского интерфейса. Следовательно, необходимо организовать программный запрос этих
    объектов.
</p>
<h5>
    Базовые программы
</h5>
<p>
    Предположим, что тестируемый компонент не является базой данных. Это - оболочка вокруг реальной базы данных на диске.
    Тестирование с применением этой реальной базы данных будет затруднительно. Ее, возможно, трудно установить и настроить.
    Необходимо купить лицензии. База данных может замедлить тесты настолько, что разработчик не захочет делать их часто. В
    таких случаях целесообразно создать "заготовку" базы данных, т.е. программу, делающую минимум для поддержания теста.
</p>
<p>
    Заготовки также необходимы, когда компонент, к которому обращается тестируемый компонент, еще не готов. Это необходимо,
    чтобы не ждать кода другого разработчика.
</p>
<p>
    Дополнительная информация приведена в документе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/stubs_9CB734F8.html" guid="6.347489919609074E-305">Концепция: Заготовки</a>.
</p>
<h4>
    Не создавайте собственные инструменты тестирования
</h4>
<p>
    Проектное тестирование кажется довольно простым процессом. Настройка объекта, вызов через API, проверка результата и
    извещение об ошибке в случае, если результат не такой, как ожидалось. Также удобно группировать тесты в комплекты.
    Инструменты, отвечающие этим требованиям, называются <i>системы тестирования</i>.
</p>
<p>
    Проектное тестирование <b>является</b> простым и требования для систем тестирования не сложны. Таким образом, на
    создание собственных систем тестирования будет затрачено значительно больше времени и энергии, чем при использовании
    готовых систем. Существуют много готовых систем как коммерческих, так и c открытым исходным кодом, и целесообразно
    использовать одну из них.
</p>
<h4>
    Создавайте поддерживающий исходный код
</h4>
<p>
    Тестовый код обычно повторяется. Часто можно видеть тестовый код наподобие следующего:
</p>
<blockquote>
<pre>
 // пустое имя не допустимо
</pre>
<pre>
    retval = o.createName(""); 
</pre>
<pre>
    expect(retval == null);    
</pre>
<pre>
    // пробел в начале строки не допустим
</pre>
<pre>
    retval = o.createName(" l"); 
</pre>
<pre>
    expect(retval == null);    
</pre>
<pre>
    // пробел после строки не допустим
</pre>
<pre>
    retval = o.createName("name "); 
</pre>
<pre>
    expect(retval == null);    
</pre>
<pre>
    // первый символ не может быть цифрой
</pre>
<pre>
    retval = o.createName("5allpha"); 
</pre>
<pre>
    expect(retval == null);    
</pre>
</blockquote>
<p>
    Этот код создан с помощью копирования кода проверки, вставки и редактирования для новой проверки.
</p>
<p>
    В данном случае существует двойная опасность. Если поменяется интерфейс, то потребуется много редактирования. (В более
    сложных случаях простой замены не достаточно.) Также если код сложный, проверка может потеряться в тексте.
</p>
<p>
    Таким образом, если вы повторяетесь, то целесообразно вынести тестовый код в код поддержки. Даже если код выше - это
    только пример, он будет более понятен и легок в поддержке, если написан следующим образом:
</p>
<blockquote>
<pre>
  void expectNameRejected(MyClass o, String s) { 
</pre>
<pre>
    Object retval = o.createName(s);    
</pre>
<pre>
    expect(retval == null); }
</pre>
<pre>
 ...
</pre>
<pre>
 // пустое имя не допустимо
</pre>
<pre>
 expectNameRejected(o, ""); 
</pre>
<pre>
 // пробел в начале строки не допустим
</pre>
<pre>
 expectNameRejected(o, " l"); 
</pre>
<pre>
 // пробел после строки не допустим
</pre>
<pre>
 expectNameRejected(o, "name "); 
</pre>
<pre>
 // первый символ не может быть цифрой
</pre>
<pre>
 expectNameRejected(o, "5alpha"); 
</pre>
</blockquote>
<p>
    Разработчики, делающие тесты, часто ошибочно применяют стиль излишнего копирования-вставки. Если есть такая тенденция,
    то целесообразно поменять направление разработки тестов. Необходимо убрать весь повторяющийся код.
</p>
<h4>
    Сначала напишите тест.
</h4>
<p>
    Написание тестов, после написания кода - это рутина. Необходимо пройти ее и двигаться дальше. Написание тестов перед
    кодом устанавливает положительную обратную связь от тестирования. При большем применении кода увеличивается
    проходимость тестов. Разработчики, которые сначала пишут тесты, более успешны, хотя они не затрачивают больше времени.
    За дополнительной информацией по первоначальному созданию тестов обратитесь к документу <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-first_design_6124EA6D.html" guid="2.5962561793181055E-305">Концепция: Начальное проектирование тестов</a>
</p>
<h4>
    Делайте тесты понятными
</h4>
<p>
    Необходимо учитывать, что тест может быть изменен кем-то еще в дальнейшем. Типична ситуация, когда на более поздних
    итерациях изменяется поведение компонента. Простой пример - допустим, в компоненте декларируется метод извлечения
    квадратного корня следующим образом:
</p>
<blockquote>
    <p>
        <tt>double sqrt(double x);</tt>
    </p>
</blockquote>
<p>
    В этой версии отрицательный аргумент заставляет функцию <tt>квадратный корень</tt> вернуть значение NaN ("не число" из
    IEEE 754-1985 <i>Стандарт для двоичной арифметики с плавающей точкой</i>). В новой итерации метод квадратного корня
    допускает отрицательное число и возвращает сложный результат:
</p>
<blockquote>
    <p>
        <tt>Complex sqrt(double x);</tt>
    </p>
</blockquote>
<p>
    Старые тесты для функции <tt>квадратный корень</tt> необходимо будет поменять. Практически это значит понять их работу
    и обновить их так, чтобы они работали с новой функцией <tt>квадратного корня</tt>. При обновлении тестов необходимо
    оставить в силе их способность находить ошибки. Иногда происходит следующее:
</p>
<blockquote>
<pre>
  void testSQRT () {    
</pre>
<pre>
    //  обновление данных тестов для новой функции квадратный корень
</pre>
<pre>
    // когда будет время
</pre>
<pre>
    /* double result = sqrt(0.0); ...     */ }
</pre>
</blockquote>
<p>
    Другие возможности менее очевидны: тесты могут измениться так, что, продолжая работать, они не тестируют то, что
    должны. Конечный результат может быть комплект тестов, который не эффективен для поиска ошибок. Такая ситуация
    называется "ослабление комплекта тестов". В этом случае ослабленный комплект тестов будет оставлен, т.к. поддержание
    его не оправдано.
</p>
<p>
    Нельзя сохранить эффективность теста для поиска ошибок, если не ясно, каков реализуемый<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-ideas_list_A6CEF011.html" guid="6.149711039531016E-305">план теста</a>. Обычно код теста недостаточно комментирован, несмотря на то, что он
    сложнее для понимания, чем код продукта.
</p>
<p>
    Ослабление комплекта тестов менее вероятно для непосредственного теста квадратного корня, чем в случае непрямого теста.
    Например, есть исходный код, вызывающий квадратный корень. Этому исходному коду соответствуют тесты. При изменении
    функции <tt>квадратный корень</tt> некоторые тесты перестанут работать. Сотрудник, изменяющий <tt>квадратный
    корень</tt>, должен изменить эти тесты. При изменении он может ослабить тесты, т.к. он не знаком с ними и потому что
    неясно их соответствие новому варианту исходного кода.
</p>
<p>
    Если вы пишите текст поддержки для тестов (как рекомендуется выше), будьте внимательны - текст поддержки должен
    прояснять, а не запутывать цель теста. Обычная жалоба на объектно ориентированные программы - в них нет участков, где
    что-то делается. При изучении любого метода обнаруживается, что он перенаправляет выполнение задания куда-то еще. Эта
    структура имеет свои преимущества, но понимать исходный код в этом случае сложнее. Без затраты больших усилий изменения
    будут неправильными или сделают исходный код еще более сложным. Это же верно и в отношение исходный код тестов, только
    с ним разработчики занимаются еще меньше. Задачу надо решать написанием понятных тестов.
</p>
<h4>
    Структура теста должна соответствовать структуре продукта.
</h4>
<p>
    Предположим, что кто-то унаследовал ваш компонент. Требуется изменить его часть. Возможно новый разработчик исследует
    старые тесты для создания новой версии. Перед написанием исходного кода будут обновлены старые тесты.
</p>
<p>
    Однако, весь этот план не удастся выполнить, если соответствующие тесты не будут найдены. В этом случае будут сделаны
    изменения, затем запущены тесты и исправлены не удавшиеся тесты. Это будет способствовать ослаблению комплекта тестов.
</p>
<p>
    По этой причине необходимо, чтобы комплект тестов был правильно структурирован и расположение тестов было предсказуемым
    с точки зрения структуры продукта. Обычно, тесты организуются в параллельную иерархию - один тестовый класс для одного
    класса продукта. Таким образом, если кто-то меняет класс с именем <tt>протокол</tt>, он будет знать, что класс теста
    называется <tt>ТестовыйПротокол</tt>, и будет известно расположение исходных файлов.
</p>
<h4>
    Позвольте тестам нарушать инкапсуляцию
</h4>
<p>
    Можно ограничить взаимодействие тестов с компонентами так же, как это делает исходный код клиента и через тот же
    интерфейс, что и исходный код клиента. Однако, это имеет свои недостатки. Предположим, что тестируется простой класс,
    поддерживающий список, соединенный двойной связью.
</p>
<p align="center">
    <img height="46" alt="Изображение примера списка, соединенного двойной связью" src="./../../../core.base_rup/guidances/concepts/resources/dvltst-img1.gif"     width="195" />
</p>
<p class="picturetext">
    Рисунок1: список, соединенный двойной связью
</p>
<p>
    В частности, тестируется метод <tt>СписокСоединенныйДвойнойСвязью.вставитьПеред(СуществующийОбъект, Объект
    НовыйОбъект)</tt>. В одном из тестов в середину списка вставляется элемент и затем проверяется, правильно ли он был
    вставлен. Тест использует список выше чтобы создать этот обновленный список:
</p>
<p align="center">
    <img height="46" alt="Изображение примера списка, соединенного двойной связью со вставленным объектом"     src="./../../../core.base_rup/guidances/concepts/resources/dvltst-img2.gif" width="318" />
</p>
<p class="picturetext">
    Рисунок2: список, соединенный двойной связью, со вставленным элементом
</p>
<p>
    Правильность списка проверяется следующим образом:
</p>
<blockquote>
<pre>
  // лист стал длиннее на один элемент.
</pre>
<pre>
 expect(list.size()==3);
</pre>
<pre>
 // элемент на правильном месте
</pre>
<pre>
 expect(list.get(1)==m); 
</pre>
<pre>
 // остальные элементы присутствуют.
</pre>
<pre>
 expect(list.get(0)==a); expect(list.get(2)==z);
</pre>
</blockquote>
<p>
    Кажется, что этого достаточно, но это не так. Предположим, что реализация списка не правильная, и обратные указатели не
    установлены корректно. Таким образом, обновленный список выглядит следующим образом:
</p>
<p align="center">
    <img height="73" alt="Изображение примера списка, соединенного двойной связью с ошибкой реализации"     src="./../../../core.base_rup/guidances/concepts/resources/dvltst-img3.gif" width="318" />
</p>
<p class="picturetext">
    Рисунок3: список, соединенный двойной связью, с ошибкой реализации
</p>
<p>
    Если <tt>СписокСоединенныйДвойнойСвязью.получить(int index)</tt> проходит список от начала до конца (что вероятно),
    тест не обнаружит эту ошибку. Если же класс предоставляет методы <tt>элементПеред</tt> и <tt>элементПосле</tt>, то
    обнаружение такой ошибки не сложно.
</p>
<blockquote>
<pre>
  // Проверка обновления всех связей
</pre>
<pre>
 expect(list.elementAfter(a)==m);
</pre>
<pre>
 expect(list.elementAfter(m)==z);
</pre>
<pre>
 expect(list.elementBefore(z)==m);
</pre>
<pre>
 //это выдаст ошибку
</pre>
<pre>
 expect(list.elementBefore(m)==a);
</pre>
</blockquote>
<p>
    Но что, если эти методы не предоставляются классом? Можно разработать более сложные последовательности вызова методов,
    которые обнаружат эту ошибку. Например, можно использовать следующее:
</p>
<blockquote>
<pre>
  // Проверка правильности обратной связи от Z.
</pre>
<pre>
 list.insertBefore(z, x);
</pre>
<pre>
 // В случае, если обновление не было сделано, X будет вставлено
</pre>
<pre>
 // после A.
</pre>
<pre>
 expect(list.get(1)==m); 
</pre>
</blockquote>
<p>
    Но такой тест труднее создать и поддерживать. (Также без хороших комментариев не будет понятна его работа.) Существуют
    два решения:
</p>
<ol>
    <li>
        Добавить методы <tt>элементПеред</tt> и <tt>элементПосле</tt> к внешнему интерфейсу. Однако, это покажет реализацию
        всем и сделает будущие изменения очень трудными.
    </li>
    <li>
        Сделать тесты скрытыми и проверять указатели напрямую.
    </li>
</ol>
<p>
    Последнее - это лучшее решение, даже для простого класса как <tt>СписокСоединенныйДвойнойСвязью</tt> и, особенно, для
    более сложных классов в продукте.
</p>
<p>
    Обычно тесты размещаются в том же пакете, что и класс, который они тестируют. Им выделяется защищенный или
    дружественный доступ.
</p>
<h3>
    <a id="TestDesignMistakes" name="TestDesignMistakes"></a>Типичные ошибки проектирования тестов
</h3>
<p>
    Каждый тест использует компонент и проверяет правильность результата. При выполнении тест может обнаруживать некоторые
    ошибки или нечаянно пропускать их. Вот некоторые типичные ошибки проектирования тестов
</p>
<h4>
    Неточность указания ожидаемых результатов
</h4>
<p>
    Предположим, что тестируется компонент, преобразовывающий XML в HTML. В данном случае легким решением будет взять
    пример XML, запустить преобразование и проверить результат в браузере. Если результат выглядит правильным, он
    принимается как официальный. После чего, тест сравнивает полученный результат преобразования с ожидаемым результатом.
</p>
<p>
    Однако, это опасная практика. Даже пользователи с опытом работы склонны доверять данным, выдаваемым компьютером.
    Вероятно, что возможные ошибки останутся не замеченными на экране. (Не говоря о том, что браузеры могут не реагировать
    на ошибки форматирования HTML.) Принятие такого результата некорректного HTML в качестве официального гарантирует
    неправильную работу теста в дальнейшем.
</p>
<p>
    Менее опасно просмотреть непосредственно код HTML, но это так же ненадежно. Можно легко не заметить ошибку, так как
    выводимый результат сложен. Наилучший способ - подготовить ожидаемый результат вручную.
</p>
<h4>
    Ошибка при проверке системы
</h4>
<p>
    Тесты обычно проверяют делаемые изменения, но не проверяют то, что должно остаться без изменений. Предположим, что
    программа меняет первые 100 записей в файле. Необходимо убедиться, что 101-<sup>ая</sup> запись не была изменена.
</p>
<p>
    Теоретически, надо убедиться, что в системе (файловая система, память и сеть) не изменилось ничего лишнего.
    Практически, надо тщательно выбрать, что возможно проверить. Важно сделать эту проверку.
</p>
<h4>
    Ошибка при проверке хранения
</h4>
<p>
    То, что компонент сообщает об изменении, не означает, что данные сохранены в базу данных. Требуется проверить базу
    данных другим способом.
</p>
<h4>
    Ошибка при проверке ограниченных случаев
</h4>
<p>
    Тест может быть рассчитан на проверку трех полей, но другие поля должны быть заполнены. При тестировании для этих полей
    часто используются одни и те же данные. Например, во всех полях указывается имя подруги или число 999.
</p>
<p>
    Однако, иногда имеет значение то, что не должно. Часто какая-то ошибка возникает в зависимости от определенных вводимых
    данных. Если всегда вводить одни и те же данные, то такую ошибку нельзя обнаружить. Надо вводить разнообразные данные.
    Часто это очень легко сделать - достаточно поменять цифру или имя. Надо менять вводимые данные, когда есть такая
    возможность. (Примечание: не используйте имя прошлой подруги, если новая работает с вами.)
</p>
<p>
    Вот дополнительная выгода. Если программа путает поле <i>X</i> с полем <i>Y</i>, то в случае одинакового значения, это
    невозможно обнаружить.
</p>
<h4>
    Ошибка при тестировании упрощенных данных
</h4>
<p>
    Часто в тестах используются вымышленные данные. Такие данные иногда нереально просты. Например, имя клиента может быть
    Иван, Петя или Илья. В последствие, при работе с реальным пользователем могут возникать ошибки, например, из-за того,
    что имя будет содержать больше символов. Также, имя возможно будет содержать пробел.
</p>
<p>
    Целесообразно затратить небольшое усилие и использовать реалистичные данные.
</p>
<h4>
    Ошибка при отсутствии деятельности проверяемого исходный кода
</h4>
<p>
    Предположим, что записи базы данных присваивается значение 0, запускается калькулятор, который сохраняет 0 в записи и
    затем значение записи проверяется. Что демонстрирует этот тест? Можно было и не запускать калькулятор. Если бы ничего
    не было введено, тест бы все равно ничего не показал.
</p>
<p>
    Это не очень реалистичный пример. Но такая ошибка может закрасться более незаметно. Например, есть тест для сложной
    программы установки. Он проверяет, удалены ли все временные файлы после установки. Но при установке из-за выбранных
    опций один временный файл не был создан. Есть вероятность, что именно его забудет убрать программа.
</p>
<h4>
    Ошибка при неправильной деятельности проверяемого исходный кода
</h4>
<p>
    Иногда программа делает правильную вещь в неправильный момент. Рассмотрим следующий простейший пример:
</p>
<blockquote>
<pre>
  if (a &lt; b && c)     
</pre>
<pre>
     return 2 * x;
</pre>
<pre>
 else
</pre>
<pre>
     return x * x;
</pre>
</blockquote>
<p>
    Логическое выражение неверно, и тест неверно оценивает его и идет по неправильному пути. Случайно, переменная X имеет
    значение 2 в этом тесте. Таким образом, результат неправильного пути случайно оказывается правильным, т.е. таким, как
    если бы тест пошел по правильному пути.
</p>
<p>
    Для каждого ожидаемого результата необходимо выяснить, можно ли его получить неправильным способом. Часто это нельзя
    сказать, однако иногда можно.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
