<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Концепция: Структурированный класс</title>
<meta content="Concept" name="uma.type">
<meta content="structured_class" name="uma.name">
<meta content="Структурированный класс" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "1.1994826813129747E-304"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "1.1994826813129747E-304"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="1.1994826813129747E-304"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Концепция: Структурированный класс</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Структурированным классом называется класс, состоящий из &quot;вложенных компонентов&quot; и применяемый для моделирования иерархических систем вложенных объектов, т.е. классов, состоящих из &quot;компонентов&quot;.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Модель проектирования</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_structured_class__concepts" name="XE_structured_class__concepts"></a> 
<h3>
    <a id="Definition" name="Definition"></a>Определение
</h3>
<p>
    В рамках UML ([<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04" guid="7.755968586980351E-308">UML04</a>]) классы (Class) представляют собой подтип EncapsulatedClassifier и метакласса
    Class одновременно, благодаря чему у объектов Class могут быть внутренняя структура и порты. Кроме того, компоненты в
    UML представляют собой подтип типа Class. Таким образом, в контексте RUP как <strong>компоненты</strong>, так и
    <strong>классы</strong> представляют собой структурированные классы.
</p>
<h5>
    <a id="Part" name="Part"></a>Компонент
</h5>
<p>
    Экземпляр структурированного класса содержит объект или набор объектов для каждого компонента. Все экземпляры
    уничтожаются при уничтожении содержащего их экземпляра структурированного класса.
</p>
<p>
    На следующем примере показаны два представления класса Car:
</p>
<blockquote>
    <p>
        На рисунке (a) у класса <strong>Car</strong> составная связь в роли <strong>rear</strong> с классом
        <strong>Wheel</strong> и составная связь с ролью <strong>e</strong> с классом <strong>Engine</strong>. Любой
        экземпляр класса <strong>Engine</strong> можно привязать к произвольному количеству экземпляров класса
        <strong>Wheel</strong>.<br />
        <br />
         На рис. (b) показана та же самая ситуация. Однако на рис. (b) в дополнение к прежним данным указаны следующие
        сведения:
    </p>
    <ul>
        <li>
            <p>
                <strong>rear</strong> и <strong>e</strong> входят во внутреннюю структуру класса <strong>Car</strong>.
                Такая организация позволяет задавать параметры для экземпляров классов <strong>Wheel</strong> и
                <strong>Engine</strong> в контексте класса <strong>Car</strong>, не изменяя классы <strong>wheels</strong>
                и <strong>engines</strong> в целом.
            </p>
        </li>
        <li>
            <p>
                в контексте класса <strong>Car</strong> экземпляр в роли <strong>e</strong> можно подключить только к двум
                экземплярам в роли <strong>rear</strong>. Кроме того, экземпляры в ролях <strong>e</strong> и
                <strong>rear</strong> можно связать только в случае, если их роли относятся к одному и тому же экземпляру
                класса <strong>Car</strong>.
            </p>
        </li>
        <li style="list-style: none">
            Другими словами, для экземпляров классов <strong>Wheel</strong> и <strong>Engine</strong> установлены
            дополнительные ограничения, когда они выступают в соответствующих ролях в рамках экземпляра класса
            <strong>Car</strong>. Эти ограничения не распространяются на классы <strong>Wheel</strong> и
            <strong>Engine</strong> в целом. Другие экземпляры классов <strong>wheels</strong> и <strong>engines</strong>
            могут быть привязаны произвольным образом, как показано на рис. (a).<br />
            <br />
        </li>
    </ul>
</blockquote>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/parts.jpg" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Пример: роли компонентов в структурированном классе
</p>
<h5>
    <a id="Connector" name="Connector"></a>Соединитель
</h5>
<p>
    Соединитель - это экземпляр отношения между двумя компонентами в структурированном классе. Соединители позволяют
    обмениваться данными. Соединители могут быть реализованы в виде обычных или временных связей, например в форме
    параметров процедур, переменных, глобальных значений и других механизмов.
</p>
<p>
    Внутренние взаимосвязи структурированного класса указываются с помощью соединителей сборки и соединителей
    делегирования:
</p>
<ul>
    <li>
        В рамках реализации структурированного класса <strong>соединители сборки</strong> применяются для соединения портов
        различных компонентов. Сообщение, отправленное в порт одного структурированного класса, доставляется в
        соответствующий порт другого структурированного класса. Набор компонентов можно соединить друг с другом через
        порты. Компоненту не нужна никакая информация о других компонентах за исключением того, что они существуют и
        удовлетворяют требованиям, предъявляемым к интерфейсным портам. Связь между структурированными классами
        моделируется с помощью их портов.
    </li>
    <li style="list-style: none">
        <br />
        <br />
    </li>
    <li>
        <strong>Соединители делегирования</strong> применяются для подключения внешних портов структурированного класса к
        внутренним портам его внутренних компонентов. Сообщение, полученное внешним портом, передается на внутренний порт.
        Сообщение, отправленное на внутренний порт, передается на внешний порт и далее в подключенный к нему
        структурированный класс.
    </li>
</ul>
<h3>
    <a id="Port" name="Port"></a>Порт
</h3>
<p>
    Порт - это элемент структуры класса. Привязав обмен данных между структурированным классом и внешними объектами к
    определенным портам и интерфейсам, можно усилить инкапсуляцию и повысить точность спецификаций и протоколов обмена
    данными структурированного класса.
</p>
<p>
    Все необходимое для обмена данными через порт взаимодействия указывается в описании необходимых и предоставляемых
    интерфейсов этого порта. Если все взаимодействие структурированного класса со средой осуществляется через порты,
    внутреннее содержание структурированного класса будет полностью изолировано от среды. Это позволяет использовать такой
    структурированный класс в любом контексте, удовлетворяющем требованиям, предъявляемым портами этого класса.
</p>
<p>
    Не делается никаких предположений относительно способа реализации порта. Порт может быть явным объектом или полностью
    виртуальной концепцией, не существующей в реализации явно.
</p>
<p>
    Ниже приведены примеры портов:
</p>
<h5>
    Пример 1
</h5>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/ports.jpg" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Порт класса Engine, используемый классами Car и Boat
</p>
<p>
    На рисунке выше показан класс <strong>Engine</strong> с портом <strong>p</strong> и двумя интерфейсами:
</p>
<ul>
    <li>
        Предоставляемый интерфейс <strong>powertrain</strong> задает набор служб, которые класс предлагает через данный
        порт (т.е. допустимые операции и данные для порта).
    </li>
    <li>
        Необходимый интерфейс <strong>power</strong> задает набор служб, предоставления которых класс ожидает от среды.
    </li>
</ul>
<p>
    Через порт <strong>p</strong> класс <strong>Engine</strong> полностью инкапсулирован, и для его реализации не нужны
    никакие сведения о среде, в которой класс Engine будет работать. Если среда соответствует ограничениям, установленным
    предоставляемым и необходимым интерфейсами класса Engine, класс будет работать правильно.<br />
    <br />
     Для иллюстрации рассмотрим два примера использования класса <strong>Engine</strong>:
</p>
<ul>
    <li>
        Класс <strong>Car</strong> соединяет порт <strong>p</strong> двигателя с набором колес через интерфейс
        <strong>axle</strong>.
    </li>
    <li>
        Класс <strong>Boat</strong> соединяет порт <strong>p</strong> двигателя с винтом через интерфейс
        <strong>shaft</strong>.
    </li>
</ul>
<p>
    Пока взаимодействие между классом <strong>Engine</strong> и компонентом, привязанным к его порту <strong>p</strong>,
    соответствует ограничениям и спецификациям интерфейсов, двигатель будет работать правильно независимо от того, где он
    находится: в автомобиле или в лодке.
</p>
<p>
    Более того, если у класса <strong>Engine</strong> есть другие порты, например порт <strong>f</strong>
    (<strong>потребление топлива</strong>), колеса и винт по-прежнему будут обращаться к классу <strong>Engine</strong>
    через порт <strong>p</strong>. С портом <strong>f</strong> будет взаимодействовать указатель уровня топлива, независимо
    от того, какое топливо подается в двигатель и какие типы датчиков уровня топлива применяются в автомобилях и в лодках.
</p>
<h5>
    Пример 2
</h5>
<p>
    Данный пример основан на API протоколов Java ([<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#JAV03" guid="7.755968586980351E-308">JAV03</a>]) -
    пакете, предоставляющем, среди прочих, следующие классы и интерфейсы для ведения протоколов на платформе Java 2.
</p>
<ul>
    <li style="list-style: none">
        <strong>Logger</strong> - основной объект, к которому будут обращаться приложения. Он применяется для занесения в
        протокол сообщений о конкретных компонентах приложения или системы.
    </li>
    <li style="list-style: none">
        <strong>Level</strong> - применяется для управления важностью и срочностью сообщений протокола.
    </li>
    <li style="list-style: none">
        <strong>Filter</strong> - применяется для тонкой настройки параметров занесения информации в протокол на более
        низком уровне, чем уровень протокола.
    </li>
    <li style="list-style: none">
        <strong>Handler</strong> - получает сообщения от Logger и экспортирует их в различных направлениях (в память, в
        потоки выходной информации, на консоли, в файлы и сокеты).
    </li>
    <li style="list-style: none">
        <strong>Formatter</strong> применяется для форматирования записей протокола.
    </li>
</ul>
<p>
    Эти классы и интерфейсы участвуют в двух важных видах взаимодействий. Одни классы и интерфейсы применяются для
    занесения информации в протокол, а другие - для управления протоколами. На следующем рисунке проиллюстрирована разница
    во взаимодействии клиентов и администраторов с протоколом в модели UML:
</p>
<ul>
    <li style="list-style: none">
        Взаимодействие <strong>записи</strong> - объект в роли <strong>LogClient</strong> подключается к роли
        <strong>LogWriter</strong> для записи данных в протокол.
    </li>
    <li style="list-style: none">
        Взаимодействие <strong>администрирования</strong> - объект в роли <strong>LogAdministrator</strong> подключается к
        роли <strong>LogController</strong> для получения доступа к протоколу и изменения его параметров.<br />
    </li>
</ul>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/collab.gif" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Виды взаимодействия клиентов и администраторов с протоколом
</p>
<p>
    Одно из возможных представлений протокола и его служб в UML 2.0 - компонент с портами и объявленными интерфейсами,
    показанный на следующем рисунке:
</p>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/ports1.gif" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Пакет Java Logging API, реализованный в виде компонента с набором интерфейсов, сгруппированных по портам
</p>
<p>
    В спецификации Java Logging API некоторые службы ведения протокола реализованы в виде классов, а некоторые - в виде
    интерфейсов. В данном примере все службы моделируются в качестве интерфейсов, которые могут быть реализованы внутри
    компонентов. Две разновидности поведения, связанные с взаимодействиями <strong>записи</strong> и
    <strong>администрирования</strong>, могут быть представлены интерфейсами, объединенными в логические группы. Таким
    образом, получается следующая картина:
</p>
<ul>
    <li style="list-style: none">
        Интерфейсы <strong>Logger</strong> и <strong>Level</strong> сгруппированы в порт <strong>LogWriter</strong>.
        Клиенты служб протокола пользуются этими интерфейсами для записи данных в протокол.
    </li>
    <li style="list-style: none">
        Интерфейсы <strong>Handler</strong>, <strong>Filter</strong> и <strong>Formatter</strong>, объединенные в порт
        <strong>LogController</strong>. Данными интерфейсами администраторы пользуются для доступа к протоколу и изменения
        его параметров.
    </li>
</ul>
<p>
    Такой способ моделирования позволяет разделить зоны ответственности путем группировки интерфейсов по портам. При этом
    сохраняется запас точности для спецификации компонентов и параметров их взаимодействия с внешним миром.
</p>
<h3>
    <a id="Modeling" name="Modeling"></a>Моделирование
</h3>
<p>
    В процессе разработки классы и компоненты могут быть представлены в виде наборов взаимосвязанных блоков, которые, в
    свою очередь, допускают дальнейшую декомпозицию.
</p>
<p>
    <strong>Составная диаграмма структуры</strong> может применяться для иллюстрации внутренней структуры класса. Например,
    на следующем рисунке показана составная диаграмма структуры кассы в системе продажи билетов. Класс состоит из трех
    частей:
</p>
<ul>
    <li>
        Интерфейс продавца билетов
    </li>
    <li>
        Расписание представлений с возможностью сортировки по датам и другим условиям.
    </li>
    <li>
        Набор баз данных, в которых хранится информация о представлениях и билетах.
    </li>
</ul>
<p>
    Части системы взаимодействуют через стандартизированные интерфейсы, привязанные к портам. Касса как единый объект, в
    свою очередь, обменивается данными с внешним миром через единый порт. Сообщения, поступающие в этот порт, передаются в
    класс продавца, однако эти сведения о внутренней структуре класса кассы скрыты от внешних клиентов.
</p>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/structclass.gif" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Пример: составная диаграмма структуры системы продажи билетов.
</p>
<h3>
    <a id="UML 1.x Representation" name="UML 1.x Representation"></a>Представление UML 1.x
</h3>
<p>
    Учтите, что понятие структурированного класса появилось только в UML 2.0.
</p>Большинство характеристик капсулы RUP можно передать в виде структурированного класса (дополнительные сведения об этом
приведены в разделах <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Рабочий продукт: капсула</a> и <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/capsule_7077C999.html" guid="7.026940817483919E-306">Рекомендации по рабочим
продуктам: Капсула</a>). 
<p>
    Если ваш инструментарий поддерживают только UML 1.5, можно воспользоваться альтернативным решением, описанным в
    разделах <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Рабочий продукт: Капсула</a> и <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/capsule_7077C999.html" guid="7.026940817483919E-306">Рекомендации по рабочим
    продуктам: Капсула</a>.
</p>
<p>
    Дополнительные сведения приведены в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html" guid="4.792914878943572E-306">Различия между UML 1.x и UML 2.0</a>.<br />
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
