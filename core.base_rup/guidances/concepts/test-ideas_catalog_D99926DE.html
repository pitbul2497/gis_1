<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Концепция: Каталог идей по тестированию</title>
<meta content="Concept" name="uma.type">
<meta content="test-ideas_catalog" name="uma.name">
<meta content="Каталог идей по тестированию" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "6.368392607593696E-305"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "6.368392607593696E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="6.368392607593696E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Концепция: Каталог идей по тестированию</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">В каталоге идей по тестированию хранятся идеи, которые с наибольшей вероятностью позволят обнаружить большинство ошибок в программном обеспечении. В данной рекомендации рассказывается о том, как создать такой каталог.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_ideas_list_2A0F8E03.html" guid="{45219F27-0F84-4FD5-A7BC-73C19226303B}">Тест - Список идей</a>
</li>
<li>
<a href="./../../../core.base_rup/capabilitypatterns/improve_test_assets_1C99FFB9.html" guid="{CD77CBDA-CC13-4593-BB81-41AF3FF7A84C}">Улучшение ресурсов тестирования</a>
</li>
<li>
<a href="./../../../core.base_rup/capabilitypatterns/improve_test_assets_BA3D58B2.html" guid="_D2HUJUdWEdqMoerwwyqMKQ">Улучшение ресурсов тестирования</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_test-ideas_catalog__concept_of" name="XE_test-ideas_catalog__concept_of"></a> 
<h3>
    <a id="Introduction" name="Introduction">Введение</a>
</h3>
<p>
    Программирование во многом представляет собой использование одних и тех же механизмов в различных контекстах. Эти
    механизмы, как правило, представляют собой определенные структуры классов и данных (например, связанные списки,
    хэш-таблицы или реляционные базы данных) или <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/operation_A1EEE7AB.html" target="_blank" guid="_yPQoFtnmEdmO6L4XMImrsA"><i>действия</i></a> (например, поиск, сортировка, создание временных файлов или создание
    нового окна браузера). Например, у двух реляционных баз данных со сведениями о клиентуре могут быть практически одни и
    те же характеристики, причем одна база может использоваться в качестве клише для создания другой.
</p>
<p>
    Интересная особенность таких клише заключается в том, что через них копируются и <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/fault_B3F2B061.html" target="_blank" guid="_yJJZA9nmEdmO6L4XMImrsA"><i>ошибки</i></a> тоже. Люди редко изобретают новые изощренные ошибки при вставке данных
    в связанные списки. Гораздо чаще повторяются ошибки других людей, сделанные ранее. Например, при создании новых окон
    браузера часто допускаются следующие ошибки:
</p>
<ul>
    <li>
        новое окно создается в ситуации, когда следует продолжить работу с существующим окном
    </li>
    <li>
        закрытое или свернутое окно браузера не делается видимым
    </li>
    <li>
        применяются функции Internet Explorer несмотря на то, что пользователь работает с другим браузером
    </li>
    <li>
        не выполняется проверка поддержки JavaScript
    </li>
</ul>
<p>
    Поскольку ошибки в большинстве своем стандартны, их можно обнаружить с помощью стандартных <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_idea_6A36A957.html" target="_blank" guid="_yYDXsNnmEdmO6L4XMImrsA"><i>идей по тестированию</i></a>. Поместите идеи по тестированию в свой каталог для
    повторного использования.
</p>
<h3>
    <a id="HowCatalogsFindFaults" name="HowCatalogsFindFaults">Как каталог идей по тестированию помогает находить
    ошибки</a>
</h3>
<p>
    Одно из замечательных качеств каталога заключается в том, что одна идея может помощь найти несколько ошибок. Ниже
    приведен пример идеи, позволяющей найти две ошибки.
</p>
<p>
    Первая ошибка была допущена в компиляторе C. Компилятор можно вызывать с опциями в командной строке, например "-table",
    "-trace" или "-nolink". Эти опции можно сокращать до минимума, при котором они остаются однозначными. Например, вместо
    "-table" можно указать "-table". Однако нельзя указать "-t", поскольку теряется однозначность: эта опция может значить
    "-table" или "-trace".
</p>
<p>
    Внутри опции командной строки хранились в таблице:
</p>
<div align="left">
    <table cellspacing="0" cellpadding="2" width="25%" border="1">
        <tbody>
            <tr>
                <td width="100%">
                    -table
                </td>
            </tr>
            <tr>
                <td width="100%">
                    -trace
                </td>
            </tr>
            <tr>
                <td width="100%">
                    -nolink
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Если в командной строке указана опция, компилятор пытается найти ее в таблице. Сначала компилятор находил первое
    совпадение: для "-t" это опция "-table". После этого компилятор просматривал остальные элементы таблицы и искал второе
    совпадение. Наличие второго совпадения означало ошибку, поскольку опция получалась неоднозначной.
</p>
<p>
    Просмотр таблицы был запрограммирован следующим образом:
</p>
<p class="example">
    <code>for (first=0; first &lt; size; first++)<br />
     {<br />
     &nbsp;&nbsp;if (matches(entry[first], thing_sought))<br />
     &nbsp;&nbsp;{ /* at least one match */<br />
     &nbsp;&nbsp;&nbsp;&nbsp;for(dup=first+1; dup &lt; size; dup++) /* search for another */<br />
     &nbsp;&nbsp;&nbsp;&nbsp;if (matches(entry[dup], thing_sought)) /* extra match */<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; /* error out */<br />
     &nbsp;&nbsp;&nbsp;&nbsp;return first;<br />
     &nbsp;&nbsp;}<br />
     }<br />
     return -1; /* Not found or ambiguity */</code>
</p>
<p>
    Вы уже видите ошибку? Она не сразу бросается в глаза.
</p>
<p>
    Ошибка находится в операторе break. Этот оператор должен осуществлять выход из внешнего цикла при обнаружении второго
    совпадения, но в действительности он осуществляет выход из внутреннего цикла. Такое поведение программы равносильно
    тому, что второе совпадение не будет найдено, поскольку будет возвращаться индекс первого совпадения.
</p>
<p>
    Обратите внимание на то, что ошибку можно обнаружить только на опции, для которой в таблице будут два совпадения,
    например "-t".
</p>
<p>
    Теперь взглянем на другую ошибку, совершенно не зависящую от первой.
</p>
<p>
    Программный код получает на входе строку. Он должен заменить последний символ '=' в строке символом '+'. Если в строке
    нет символа '=', ничего не происходит. Код пользуется процедурой стандартной библиотеки C <font     size="+0">strchr</font>. Код приведен ниже:
</p>
<blockquote>
<pre>
  ptr = strchr(string, '=');  /* Find last = */ if (ptr != NULL_CHAR)     *ptr = '+';
</pre>
</blockquote>
<p>
    Здесь ошибка тоже незаметна на первый взгляд.
</p>
<p>
    Функция <font size="+0">strchr</font> возвращает <i>первое</i> вхождение символа в строку, а не последнее. Правильная
    функция называется <font size="+0">str<b><u>r</u></b>chr</font>. Скорее всего, в данном случае программист опечатался.
    Кроме того, реальная ошибка более фундаментального свойства заключается в том, что не следовало присваивать двум
    функциям стандартной библиотеки настолько похожие имена, что опечатавшись, можно вызвать одну функцию из другой.
</p>
<p>
    Эту ошибку можно обнаружить только в случае, если во входной строке несколько знаков равенства. Пример:
</p>
<ul>
    <li>
        для "a=b" будет получен правильный результат - "a+b".
    </li>
    <li>
        для "noequals" будет получен правильный результат - "noequals".
    </li>
    <li>
        для "a=b=c" будет получен неправильный результат "a+b=c" вместо правильного "a=b+c".
    </li>
</ul>
<p>
    Интересная и полезная особенность этого примера заключается в том, что ошибки, вызванные совершенно разными причинами
    (опечатка и неверное понимание конструкции языка C) и приводящие к совершенно разным результатам (вызов неправильной
    функции, неправильное использование оператора break), могут быть обнаружены с помощью <i>одной и той же</i> идеи
    тестирования (поиск чего-либо с двумя вхождениями).
</p>
<h3>
    <a id="GoodCatalogs" name="GoodCatalogs">Хороший каталог идей по тестированию</a>
</h3>
<p>
    Каким должен быть хороший каталог?
</p>
<ul>
    <li>
        В нем мало идей, но эти идеи способны обнаружить большое количество ошибок.
    </li>
    <li>
        Он просто для чтения и восприятия. Должно быть достаточно просто отбросить идеи, которые не относятся к той или
        иной ситуации.
    </li>
    <li>
        В нем находятся только те идеи, которые будут использоваться. Например, те, кто никогда не имеет дел с браузерами,
        могут пропустить идеи по тестированию программ, взаимодействующих с браузерами. Разработчики компьютерных игр могут
        воспользоваться более краткой версией каталога, чем разработчики программного обеспечения безопасности. При
        тестировании компьютерных игр можно сосредоточиться только на тех идеях, которые с максимальной вероятностью
        позволяют обнаружить ошибки.
    </li>
</ul>
<p>
    С учетом этих правил целесообразно создать несколько каталогов. Некоторые виды данных и операций используются во всех
    видах программ, и идеи по их тестированию следует поместить в общий каталог для всех программистов. Некоторые виды
    данных и операций используются только в определенных предметных областях, и идеи по их тестированию достаточно включить
    в каталоги для этих предметных областей.
</p>
<p>
    <a href="./../../../core.base_rup/guidances/guidelines/resources/tstids_short-catalog.pdf" target="_blank">Пример каталога</a> (<a href="http://www.adobe.com/products/acrobat/alternate.html">Загрузите Adobe Reader</a>), показанный ниже, может стать
    неплохой отправной точкой. Каталог <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_booleans_ands_and_ors_BB81527B.html" guid="9.407283892342409E-306">идей по тестированию выражений с операторами AND и OR</a> может служить другим примером.
</p>
<h3>
    <a id="UsingACatalogExample" name="UsingACatalogExample">Пример применения каталога идей по тестированию</a>
</h3>
<p>
    Ниже проиллюстрировано применение примера каталога идей. &nbsp;Предположим, что вы реализуете следующий метод:
</p>
<blockquote>
<pre>
  void applyToCommonFiles(Directory d1,         Directory d2,         Operation op);
</pre>
</blockquote>
<p>
    <font size="+0">applyToCommonFiles</font> в качестве аргументов получает два имени каталогов. Если файлу в первом
    каталоге присвоено то же имя, что файлу во втором, метод <font size="+0">applyToCommonFiles</font> выполняет
    определенную операцию над этой парой файлов. Выполняется рекурсивный просмотр подкаталогов.
</p>
<p>
    Сначала найдите в каталоге идей заголовки, которые имеют отношение к вашей ситуации. Просмотрите все идеи под этими
    заголовками и выпишите подходящие в <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-ideas_list_A6CEF011.html" guid="6.149711039531016E-305">список идей по
    тестированию</a>.
</p>
<p>
    <b>Примечание:</b> пошаговое описание может создать впечатление, что работа с каталогом требует больших усилий. В
    действительности на создание списка требуется меньше времени, чем на чтение инструкций по его созданию.
</p>
<p>
    Для метода <font size="+0">applyToCommonFiles</font> каталогом можно пользоваться в соответствии с инструкциями из
    этого раздела.
</p>
<p>
    Первая запись - <b>Любой объект</b>. Могут ли аргументами быть пустые указатели? Это вопрос соглашения между <font     size="+0">applyToCommonFiles</font> и вызывающими процедурами. Соглашение должно быть таким, что вызывающие процедуры
    не передают пустые указатели. Если они передадут пустые указатели, данная процедура не может быть выполнена правильно:
    <font size="+0">applyToCommonFiles</font> может выполнить любое действие. В данном случае тесты неприменимы, поскольку
    ничего из того, что будет делать <font size="+0">applyToCommonFiles</font> , нельзя считать неправильным. Однако <font     size="+0">applyToCommonFiles</font> должна проверять и корректно обрабатывать ситуацию, когда в качестве входных
    аргументов получены пустые указатели, и это поведение нуждается в тестировании. Исходя из такого предположения, можно
    создать следующий начальный список идей:
</p>
<ul>
    <li>
        аргумент d1 пустой (ошибка)
    </li>
    <li>
        аргумент d2 пустой (ошибка)
    </li>
    <li>
        аргумент op пустой (ошибка)
    </li>
</ul>
<p>
    Следующая запись каталога - <b>Строки</b>. Имена файлов представляют собой строки, и эти строки сравниваются на предмет
    совпадения. Идея тестирования с помощью пустой строки ("") не особенно полезна. Вероятно, будут использоваться
    стандартные процедуры сравнения строк, и они будут обрабатывать пустые строки правильно.
</p>
<p>
    Но постойте... Если речь идет о сравнении строк, как насчет регистра символов? Предположим, что <font     size="+0">d1</font> содержит файл "File". <font size="+0">d2</font> содержит файл "file". Совпадают ли имена этих
    файлов? В UNIX - конечно же, нет. В Microsoft&reg; Windows&reg; - почти наверняка совпадают. Вот еще одна идея для
    тестирования:
</p>
<ul>
    <li>
        Имена файлов в каталогах совпадают без учета регистра, но не совпадают с учетом регистра.
    </li>
</ul>
<p>
    Обратите внимание на то, что этой идеи не было в каталоге. Однако идеи из каталога привлекли наше внимание к
    определенному обстоятельству (имена файлов представляют собой строки), и на этом фоне мы придумали собственную идею. Не
    следует воспринимать каталог как исчерпывающий список - в действительности это скорее генератор новых идей.
</p>
<p>
    Следующая запись - <b>Наборы</b>. Каталог представляет собой набор файлов. Многие программы, работающие с наборами,
    некорректно обрабатывают пустые наборы. Некоторые программы, корректно справляющиеся с пустыми наборами и с наборами из
    нескольких элементов, некорректно обрабатывают наборы, в которых находится ровно один элемент. Поэтому полезны
    следующие идеи:
</p>
<ul>
    <li>
        d1 пуст
    </li>
    <li>
        d2 пуст
    </li>
    <li>
        в d1 ровно один файл
    </li>
    <li>
        в d2 ровно один файл
    </li>
</ul>
<p>
    Следующая идея заключается в том, чтобы воспользоваться набором максимального возможного размера. <font     size="+0">applyToCommonFiles</font> в большинстве случаев будет применяться для небольших каталогов. Затем кто-нибудь
    может попробовать воспользоваться двумя большими деревьями каталогов с несколькими тысячами файлов, и в этот момент
    может выясниться, что программа настолько неэффективно обращается с памятью, что не сможет справиться с таким
    сценарием.
</p>
<p>
    Не обязательно тестировать программу на максимальном теоретически возможном размере каталога, но стоит попробовать на
    больших значениях в пределах разумного. В любом случае должен быть <i>хотя бы один тест</i> для сценария, когда в
    каждом каталоге больше трех файлов:
</p>
<ul>
    <li>
        в d1 очень много файлов
    </li>
    <li>
        в d2 очень много файлов
    </li>
</ul>
<p>
    Последняя идея (повторяющиеся элементы) не имеет смысла для каталогов и файлов. Если в каталоге будут несколько файлов
    с одинаковыми именами, эта ошибка не связана с <font size="+0">applyToCommonFiles</font>- в данном случае речь идет о
    повреждении файловой системы.
</p>
<p>
    Следующая категория - <b>Поиск</b>. Эти идеи можно перевести на язык <font size="+0">applyToCommonFiles</font>
    следующим способом:
</p>
<ul>
    <li>
        в d1 и d2 нет файлов с одинаковыми именами (все имена разные)
    </li>
    <li>
        в d1 и d2 ровно одна пара файлов с одинаковыми именами (эти файлы - последние по алфавиту в каждом из каталогов)
    </li>
    <li>
        в d1 и d2 несколько пар файлов с одинаковыми именами
    </li>
</ul>
<p>
    Последняя идея тестирования заключается в проверке <font size="+0">applyToCommonFiles</font>. Возвращает ли эта
    процедура результат в момент обнаружения первого совпадения? Идея, оставшаяся за кадром, заключается в том, что, скорее
    всего, программа будет получать список файлов в каталоге с помощью какой-нибудь процедуры, возвращающей список файлов в
    алфавитном порядке. Если это не так, имеет смысл сделать совпадающими файлы, стоящие последними по алфавиту. Перед тем
    как посвятить массу времени изучению того, как упорядочены файлы, спросите себя, насколько вероятно то, что поиск
    ошибок упростится за счет того, что совпадающие файлы будут последними по алфавиту. Если код обрабатывает элементы
    набора последовательно в линейном порядке, применение последнего элемента в качестве контрольного позволяет
    обнаруживать ошибки, связанные с выходом за границы набора. Если код обрабатывает элементы набора итерационным путем,
    порядок, скорее всего, не имеет значения.
</p>
<p>
    Взглянем еще на одну запись в примере каталога. Раздел <b>Связанные структуры</b> напоминает нам о том, что мы
    сравниваем <i>деревья</i> каталогов, а не просто линейные массивы файлов. Выбор способа тестирования <font     size="+0">applyToCommonFiles</font> приводит нас к осознанию того, что процедура описана не полностью.
</p>
<p>
    Если дерево каталогов выглядит так, как показано на следующем рисунке:
</p>
<p align="center">
    <img height="162" alt="Диаграмма структуры каталогов" src="./../../../core.base_rup/guidances/concepts/resources/tstidsctl-img1.gif" width="334" />
</p>
<p class="picturetext">
    Рис. 1: Структура каталогов
</p>
<p>
    заглянет ли <font size="+0">applyToCommonFiles</font> в каталог <font size="+0">Cdir</font>? Это не имеет смысла. В
    этом каталоге не может быть файлов, для которых будет пара во втором дереве. Похоже, что парные файлы могут встречаться
    только в парных каталогах. То есть, предположим, что структура каталогов следующая:
</p>
<p align="center">
    <img height="165" alt="Диаграмма второй структуры каталогов" src="./../../../core.base_rup/guidances/concepts/resources/tstidsctl-img2.gif" width="334" />
</p>
<p class="picturetext">
    Рис. 2: Вторая структура каталогов
</p>
<p>
    Файлы "File" не образуют пары, поскольку они находятся в разных подкаталогах. Подкаталоги должны просматриваться только
    в случае, если они присутствуют в обоих каталогах: <font size="+0">d1</font> <font size="+0">d2</font>. Таким образом,
    возникают следующие идеи:
</p>
<ul>
    <li>
        какого-либо подкаталога d1 нет в каталоге d2 (не просматривается)
    </li>
    <li>
        какого-либо подкаталога в d2 нет в каталоге d1 (не просматривается)
    </li>
    <li>
        какой-либо подкаталог есть и в d1, и в d2 (просматривается)
    </li>
</ul>
<p>
    Однако при этом возникают новые вопросы. Должна ли операция (<font size="+0">op</font>) выполняться для парных
    подкаталогов, или же для только для парных файлов? Если она выполняется для подкаталогов, должна ли она выполняться до
    их просмотра или после? Это важно, поскольку операция может, например, удалить парный файл или каталог. В таком случае,
    <i>следует</i> ли разрешить операции изменять структуру каталогов? И еще точнее: что должна делать процедура <font     size="+0">applyToCommonFiles</font> в ситуации, когда это происходит? Этот же вопрос встает и для ситуации с
    итерационным просмотром содержимого каталогов.
</p>
<p>
    Подобные вопросы обычно возникают при внимательном изучении описания методов создания идей по тестированию. Но давайте
    пока оставим их в стороне. Какими бы ни были ответы, для них должны быть идеи по тестированию, и эти идеи должны
    обеспечивать проверку правильности работы кода.
</p>
<p>
    Вернемся к каталогу. Мы просмотрели еще не все идеи. Пустой первый аргумент (пустая структура) соответствует ситуации с
    пустым каталогом. На этот случай мы уже используем идею из группы <b>Наборы</b>. Кроме того, у нас есть <b>минимальная
    непустая</b> структура - каталог с одним файлом. Подобная избыточность регулярно встречается, но мешает не сильно.
</p>
<p>
    Как насчет <b>кольцевой структуры</b>? Структуры каталогов не могут быть кольцевыми - каталог не может находиться
    внутри одного из своих потомков или внутри себя... или может? Как насчет ярлыков (в Windows) и ссылок (в UNIX)? Если
    ярлык в каталоге <font size="+0">d1</font>ссылается на каталог <font size="+0">d1</font>, должна ли процедура <font     size="+0">applyToCommonFiles</font> осуществлять бесконечный спуск? Ответ на этот вопрос может породить несколько новых
    идей для тестирования:
</p>
<ul>
    <li>
        каталог d1 циклический из-за ярлыков или ссылок
    </li>
    <li>
        каталог d2 циклический из-за ярлыков или ссылок
    </li>
</ul>
<p>
    В зависимости от того, как должна вести себя процедура в этих ситуациях, могут возникнуть и другие идеи.
</p>
<p>
    Наконец, как насчет <b>нескольких уровней вложенности</b>? В прежних идеях предполагалось, что процедура спускается на
    один уровень вложенности, но нужно проверить способность <font size="+0">applyToCommonFiles</font> спускаться на
    несколько уровней:
</p>
<ul>
    <li>
        просмотр нескольких уровней (&gt;1) подкаталогов d1
    </li>
    <li>
        просмотр нескольких уровней (&gt;1) подкаталогов d2
    </li>
</ul>
<h3>
    <a id="CreatingYourOwnCatalogs" name="CreatingYourOwnCatalogs">Создание и пополнение собственного каталога идей по
    тестированию</a>
</h3>
<p>
    Как указано выше, в стандартном каталоге не обязательно будут все возможные идеи. Однако каталоги по конкретным <a class="elementLinkWithUserText" href="./../../../core.base_concepts/guidances/termdefinitions/domain_D8238B93.html" target="_blank" guid="_yHEVYdnmEdmO6L4XMImrsA">предметным областям</a> циркулируют только внутри компаний, занимающихся
    этими областями. Если вы хотите пользоваться такими каталогами, вам придется создать их. Вот некоторые советы на этот
    счет.
</p>
<ul>
    <li>
        Не стоит переполнять каталог непроверенными идеями по поиску ошибок. Помните о том, что каждая идея стоит денег и
        времени: 
        <ul>
            <li>
                вашего времени на поддержание каталога
            </li>
            <li>
                времени других программистов на обдумывание идей по тестированию
            </li>
            <li>
                времени других программистов на реализацию идей по тестированию
            </li>
        </ul><br />
         Добавляйте в каталог только проверенные идеи. Должен быть известен по крайней мере один случай, когда идея
        обнаруживает ошибку. В идеальной ситуации это должна быть такая ошибка, которую не удалось обнаружить в ходе других
        тестов, т.е. ошибка, которая была обнаружена в ходе эксплуатации. Хороший способ создания каталогов заключается в
        просмотре базы данных ошибок компании и изучении того, как можно было обнаружить эти ошибки раньше.
    </li>
    <li style="LIST-STYLE-TYPE: none">
        <br />
        <br />
    </li>
    <li>
        Не стоит рассчитывать на то, что хороший каталог идей по тестированию удастся создать в свободное от работы время.
        На эту работу следует отвести отдельное время, как и на любую другую важную работу. Мы рекомендуем заниматься
        каталогом идей по тестированию в рамках выполнения операции <a class="elementLinkWithUserText" href="./../../../core.base_rup/capabilitypatterns/improve_test_assets_1C99FFB9.html" guid="{CD77CBDA-CC13-4593-BB81-41AF3FF7A84C}">Операция: оптимизация ресурсов тестирования</a>.
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
