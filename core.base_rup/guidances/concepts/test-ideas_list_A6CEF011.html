<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Концепция: Тест - Список идей</title>
<meta content="Concept" name="uma.type">
<meta content="test-ideas_list" name="uma.name">
<meta content="Тест - Список идей" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "6.149711039531016E-305"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "6.149711039531016E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="6.149711039531016E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Концепция: Тест - Список идей</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Список идей по тестированию - это список идей, перечисленных в порядке убывания важности и связанных с определенными стратегиями, применяемыми при создании тестов.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/identify_test_ideas_395DAB3B.html" guid="{6FAD9DF9-DE4E-4BA5-9B9B-482A2366D1B9}">Определение идеи тестирования</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_ideas_list_2A0F8E03.html" guid="{45219F27-0F84-4FD5-A7BC-73C19226303B}">Тест - Список идей</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_test-ideas_list__concept_of" name="XE_test-ideas_list__concept_of"></a> 
<h3>
    <a id="Introduction" name="Introduction">Введение</a>
</h3>
<p>
    Разработчики тестов черпают информацию из различных источников, включая модели проекта, интерфейсы классификаторов,
    диаграммы состояний и собственно код продукта. В определенный момент эта информация претерпевает преобразование в тесты
    исполняемой программы:
</p>
<ul>
    <li>
        входные значения для тестируемого программного обеспечения
    </li>
    <li>
        конкретная конфигурация аппаратного и программного обеспечения
    </li>
    <li>
        перевод в определенное состояние
    </li>
    <li>
        ожидание определенных результатов
    </li>
</ul>
<p>
    Хотя можно перейти напрямую от информации к тестам, зачастую бывает целесообразно добавить промежуточный шаг. На этом
    шаге <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_idea_6A36A957.html" target="_blank" guid="_yYDXsNnmEdmO6L4XMImrsA"><i>идеи по тестированию</i></a> записываются в <i>список идей</i>,
    который затем используется для создания тестов.
</p>
<h3>
    <a id="TestIdeas" name="TestIdeas">Что такое идея по тестированию?</a>
</h3>
<p>
    Идея по тестированию (или <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_requirement_E14A2712.html" target="_blank" guid="_yYNIudnmEdmO6L4XMImrsA">требование к тесту</a>) - это краткое описание теста, который нужно выполнить. В
    качестве примера рассмотрим функцию, вычисляющую квадратный корень, и предложим несколько идей для ее тестирования:
</p>
<ul>
    <li>
        дать в качестве входного значения число немного меньше нуля
    </li>
    <li>
        дать в качестве входного значения ноль
    </li>
    <li>
        дать в качестве входного значения квадрат целого числа, например 4 или 16 (будет ли результатом ровно 2 или 4?)
    </li>
</ul>
<p>
    Эти идеи можно без труда преобразовать в исполняемые тесты с точным описанием входных значений и ожидаемых результатов.
</p>
<p>
    Относительно неформальный промежуточный список идей обладает двумя преимуществами:
</p>
<ul>
    <li>
        идеи для тестов более понятны и просты для восприятия, чем готовые тесты - проще понять, что же именно нужно
        проверить
    </li>
    <li>
        с помощью идей можно описать сложные тесты - об этом рассказано в разделе <a href="#TestDesignUsingTheList">Разработка тестов с помощью списка</a>
    </li>
</ul>
<p>
    В примерах идей для функции вычисления квадратного корня использовались только входные значения, однако ничто не мешает
    использовать любые другие элементы исполняемого теста. Например, идея "напечатать на принтере LaserJet IIIp" описывает
    <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_environment_67E4FF5F.html" target="_blank" guid="_yX5mttnmEdmO6L4XMImrsA">среду тестирования</a>, равно как идея "выполнить тест с полной базой
    данных", хотя эти идеи не отличаются полнотой: <b>что</b> нужно напечатать на принтере? <b>Что</b> нужно сделать с
    полной базой данных? Однако эти идеи напоминают о том, что именно нельзя упускать из виду, позволяя отложить конкретную
    реализацию этих идей до момента разработки тестов.
</p>
<p>
    Идеи по тестированию зачастую основаны на <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/fault_model_C99EBECA.html" target="_blank" guid="_yJJZCdnmEdmO6L4XMImrsA"><i>моделях сбоев</i></a>, дающих представление о наиболее часто встречающихся ошибках и
    способах их обнаружения. В качестве примера можно рассмотреть граничные значения. Например, функция вычисления
    квадратного корня может выглядеть примерно так:
</p>
<blockquote>
<pre>
double sqrt(double x) {
    if (x &lt; 0) 
      // signal error
    ...
</pre>
</blockquote>
<p>
    Вполне может быть, что вместо <b>&lt;</b> по ошибке будет указано <b>&lt;=</b>. Такие опечатки встречаются довольно
    часто, и поэтому они стоят проверки. Данную ошибку нельзя обнаружить при <b>X</b>, равном <b>2</b>, поскольку как
    неправильное (<b>x&lt;=0</b>), так и правильное выражение (<b>x&lt;0</b>) в этом случае пойдут по одной и той же ветви
    оператора <b>if</b>. По этой же причине данную ошибку нельзя обнаружить, присвоив <b>X</b> значение -<b>5</b>.
    Единственный способ обнаружить эту ошибку заключается в том, чтобы присвоить <b>X</b> значение <b>0</b>, и это
    обстоятельство оправдывает создание второго теста.
</p>
<p>
    В данном случае сбой можно смоделировать достаточно прямолинейно. В других случаях это не так просто. Например, всякий
    раз, когда программа манипулирует ссылками на структуры, полезно проверять цикличность ссылок. Неправильная обработка
    циклических структур может быть вызвана различными ошибками. Однако в целях тестирования не обязательно владеть
    информацией обо всех возможных ошибках - достаточно знать, что вероятность возникновения какой-либо определенной ошибки
    оправдывает выполнение теста.
</p>
<p>
    В следующих разделах приведена информация об идеях по тестированию различных моделей сбоев. Первые две модели сбоев
    явные, остальные - неявные.
</p>
<ul>
    <li>
        <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_booleans_and_boundaries_74AE938C.html" guid="1.8659406802663404E-305">Рекомендации: идеи по тестированию логических операторов и граничных значений</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_method_calls_B0A17E5C.html" guid="4.418859682485385E-305">Рекомендации: идеи по тестированию вызовов методов</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-ideas_catalog_D99926DE.html" guid="6.368392607593696E-305">Концепция: каталог идей по тестированию</a>
    </li>
</ul>
<p>
    Эти модели сбоев применимы к разнообразным рабочим продуктам. Например, в первой приведены идеи по тестированию
    логических выражений. Логические выражении могут встречаться непосредственно в коде, в сторожевых условиях,
    циклограммах и диаграммах состояний, а также в неформальных описаниях поведения методов (например, в опубликованных
    API).
</p>
<p>
    В некоторых случаях полезно создание рекомендаций для отдельных рабочих продуктов. См. <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_statechart_and_flow_diagrams_B881354C.html" guid="3.794638918140148E-305">Рекомендации: идеи по тестированию диаграмм состояний и блок-схем</a>.
</p>
<p>
    В список идей по тестированию можно включить идеи из различных моделей сбоев, относящихся к различным рабочим
    продуктам.
</p>
<h3>
    <a id="TestDesignUsingTheList" name="TestDesignUsingTheList">Проектирование тестов с помощью списка</a>
</h3>
<p>
    Предположим, что вы разрабатываете тесты для метода, выполняющего поиск строки в последовательном наборе. Этот метод
    может выполнять поиск с учетом или без учета регистра и возвращает номер первого найденного совпадения или значение -1,
    если совпадение не найдено.
</p>
<blockquote>
<pre>
int Collection.find(String string,
                    Boolean ignoreCase);
</pre>
</blockquote>
<p>
    Вот несколько идей по тестированию данного метода:
</p>
<ol>
    <li>
        совпадение найдено в первой позиции
    </li>
    <li>
        совпадение найдено в последней позиции
    </li>
    <li>
        не найдено ни одно совпадение
    </li>
    <li>
        найдены несколько совпадений
    </li>
    <li>
        при поиске без учета регистра найдено совпадение, которое не было бы совпадением с учетом регистра
    </li>
    <li>
        при поиске с учетом регистра найдено точное совпадение
    </li>
    <li>
        при поиске с учетом регистра пропущено значение, которое было бы совпадением без учета регистра
    </li>
</ol>
<p>
    Реализация этих семи тестов - по одному на каждую идею - не составила бы труда. Однако в одном тесте можно объединить
    несколько идей. Например, следующий тест <i>удовлетворяет</i> условиям идей 2, 6 и 7:
</p>
<blockquote>
    <p>
        Подготовка: создается набор, содержащий значения ["dawn", "Dawn"]<br />
         Вызов теста: collection.find("Dawn", false)<br />
         Ожидаемый результат: значение 1 (если значение "dawn" не будет пропущено, метод вернет значение 0)
    </p>
</blockquote>
<p>
    Чем более обобщенные формулировки идей, тем проще объединять их.
</p>
<p>
    Предположим, что можно охватить все идеи тремя тестами. Чем три теста, охватывающие семь идей, лучше семи отдельных
    тестов?
</p>
<ul>
    <li>
        При создании большого количества тестов довольно часто тест с номером N+1 создается путем копирования теста N и
        подгонки его параметров под следующую идею. В результате, особенно если речь идет о сложном программном
        обеспечении, тест N+1 испытывает программу почти так же, как тест N. При выполнении этого теста выполняются
        практически те же самые участки кода.<br />
        <br />
         Малое количество тестов, каждый из которых охватывает несколько идей по тестированию, довольно сложно создать
        путем "клонирования". Все тесты будут отличаться друг от друга, и при их выполнении будут работать различные
        участки кода.<br />
        <br />
         Чем лучше такой подход? Если бы список идей по тестированию был полным и идеи охватывали все возможные ошибки в
        программе, способ создания тестов не играл бы роли. Однако списки никогда не бывают полными. Чем разнообразнее
        тесты и чем больше различных участков кода они заставляют работать, тем больше вероятность того, что какая-либо
        ошибка будет выявлена случайно. В результате у меньшего количества сложных тестов больше шансов обнаружить ошибку,
        о которой вы даже не задумывались, чем у большего количества однообразных тестов.<br />
        <br />
    </li>
    <li>
        Иногда при создании сложных тестов в голову приходят новые идеи. При работе с простыми тестами идеи приходят реже,
        потому что все тесты однообразны, и это усыпляет разум.
    </li>
</ul>
<p>
    В то же время у сложных тестов есть и недостатки.
</p>
<ul>
    <li>
        Если каждый тест охватывает ровно одну идею и тест 2 выявляет ошибку, вы будете мгновенно знать наиболее вероятную
        причину ошибки: программа неправильно обрабатывает совпадение в последней позиции. Если тест охватывает идеи 2, 6 и
        7 одновременно, поиск конкретной причины ошибки усложняется.<br />
        <br />
    </li>
    <li>
        Сложные тесты менее понятны и требуют больших усилий по обслуживанию. Цели таких тестов менее очевидны.<br />
        <br />
    </li>
    <li>
        Сложные тесты сложнее создавать. На создание теста, охватывающего пять идей, зачастую требуется больше времени, чем
        на создание пяти тестов, каждый из которых удовлетворяет одной идее. Более того, гораздо проще допустить ошибку -
        например, разработчику может показаться, что тест охватывает все пять идей, хотя в реальности он охватывает только
        четыре.
    </li>
</ul>
<p>
    На практике нужно найти оптимальный баланс между простотой и сложностью. Например, первые тесты (обычно это <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/smoke_test_961BBC4D.html" target="_blank" guid="_yVhBFtnmEdmO6L4XMImrsA"><i>проверка дымом</i></a>) должны быть простыми и легкими для понимания
    и направлены на обнаружение самых очевидных ошибок. Последующие тесты должны быть сложнее, однако не настолько
    сложными, чтобы их стало невозможно обслуживать.
</p>
<p>
    После создания набора тестов нужно проверить, нет ли в них типичных ошибок, которые обсуждаются в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/developer_testing_D800236F.html#TestDesignMistakes" guid="7.256588791264849E-307">Концепция: тестирование разработчиков</a>.
</p>
<h3>
    <a id="UsingTestIdeasBeforeTest" name="UsingTestIdeasBeforeTest">Применение идей по тестированию перед
    тестированием</a>
</h3>
<p>
    Списком идей по тестированию можно пользоваться для анализа и проверки рабочих продуктов проекта. Например, рассмотрим
    часть <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_model_BAFECB4C.html" target="_blank" guid="_yF4CltnmEdmO6L4XMImrsA">модели проекта</a>, показывающую взаимосвязь между классами Department
    (отдел) и Employee (сотрудник).
</p>
<p align="center">
    <img height="45" alt="Изображение примера модели проекта" src="./../../../core.base_rup/guidances/concepts/resources/tstidslst-img1.gif" width="223" />
</p>
<p class="picturetext">
    Рисунок 1: Связь между классами Department и Employee
</p>
<p>
    В правилах создания идей по тестированию подобных моделей будет предложено рассмотреть ситуацию, когда в отделе много
    сотрудников. Задав себе вопрос "Что будет, если на данном этапе в отделе будет столько-то сотрудников?" во время
    анализа проекта, можно обнаружить ошибки анализа и проектные ошибки. Например, можно выяснить, что сотрудников можно
    перемещать между отделами только по одному. Это ограничение может вызвать огромные сложности, если в компании часто
    происходят крупномасштабные изменения структуры с переподчинением большого количества сотрудников.
</p>
<p>
    Подобные недоработки, когда разработчик не учел какой-либо сценарий, называются <i>упущениями</i>. Если в проекте
    допущено упущение, скорее всего, оно же допущено и при разработке идей по тестированию. Примеры упущений
    рассматриваются в публикациях <a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#GLA81" guid="7.755968586980351E-308">[GLA81]</a>, <a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#OST84" guid="7.755968586980351E-308">[OST84]</a>, <a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#BAS87" guid="7.755968586980351E-308">[BAS87]</a>, <a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#MAR00" guid="7.755968586980351E-308">[MAR00]</a> и других работах.
</p>
<p>
    Роль тестирования в разработке продуктов обсуждается в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-first_design_6124EA6D.html" guid="2.5962561793181055E-305">Концепция:
    разработка с приоритетом тестов</a>.
</p>
<h3>
    <a id="TestIdeasTraceability" name="TestIdeasTraceability">Идеи по тестированию и прослеживаемость</a>
</h3>
<p>
    <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/traceability_84090089.html" target="_blank" guid="_yY8vkNnmEdmO6L4XMImrsA">Прослеживаемость</a> - это вопрос компромиссов. Достаточно ли пользы от
    нее, чтобы оправдать усилия на ее реализацию? Это вопрос нужно обдумать при выполнении задачи <a class="elementLinkWithUserText" href="./../../../core.base_rup/tasks/define_assessment_and_traceability_needs_19C5C9FE.html" guid="{F6F9BB36-5A72-421E-B195-8937E0C46AF8}">Задача: формулировка потребности в оценке и прослеживаемости</a>.
</p>
<p>
    Если обеспечение прослеживаемости оправдано, обычно принято прослеживать тесты вплоть до рабочих продуктов, на основе
    которых они были созданы. Например, в рамках проекта может быть обеспечена прослеживаемость между API и его тестами.
    Если в API будут внесены изменения, вы будете знать, какие тесты нужно будет изменить. Если изменится код, реализующий
    API, вы будете знать, какие тесны нужно выполнить вновь. Если тест дает неожиданный результат, вы знаете, какой API
    требует внимания.
</p>
<p>
    Список идей по тестированию дает определенную степень прослеживаемости. Тесты можно привязать к идеям, которые они
    охватывают, а идеи - к исходным рабочим продуктам.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
