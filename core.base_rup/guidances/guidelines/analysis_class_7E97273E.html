<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Класс анализа</title>
<meta content="Guideline" name="uma.type">
<meta content="analysis_class" name="uma.name">
<meta content="Класс анализа" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.2738948033145062E-306"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.2738948033145062E-306"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="2.2738948033145062E-306"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Класс анализа</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Существует три стереотипа классов анализа: пограничный, управляющий и сущностный. В этой рекомендации разъясняются их смысл и предназначение.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Анализ прецедентов</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_analysis_class_DAF7CE03.html" guid="{1E20603F-A5B8-42D5-BDBC-69DCE9C0FCDB}">Класс анализа</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a> 
<h3>
    <a id="Analysis Class Stereotypes" name="Analysis Class Stereotypes">Стереотипы классов анализа</a>
</h3>
<p>
    Классы анализа подразделяются на следующие стереотипы:
</p>
<ul>
    <li>
        Пограничные классы
    </li>
    <li>
        Управляющие классы
    </li>
    <li>
        Сущностные классы
    </li>
</ul>
<p>
    Помимо предоставления вам более подробных указаний о процессе при поиске классов, это разбиение на стереотипы повышает
    устойчивость модели объектов, поскольку изменения в модели отражаются только в определенной области. Например,
    изменения в пользовательском интерфейсе повлияют только на пограничные классы. Изменения в управляющем потоке - только
    на управляющие классы. Изменения в долговременной информации - только на сущностные классы. Кроме того, эти стереотипы
    особенно полезны при идентификации классов на этапах анализа и раннего проектирования. На последующих стадиях
    проектирования рекомендуется рассматривать несколько иной набор стереотипов, лучше приспособленный к среде реализации,
    типу приложений и т.п.
</p>
<h4>
    <a id="Boundary Class Def" name="Boundary Class Def">Пограничный класс</a> <font size="2"><img height="31"     alt="Значок пограничного класса" src="./../../../core.base_rup/guidances/guidelines/resources/bcls.jpg" width="47" /></font>
</h4>
<p>
    <b>Пограничный класс</b> - это класс, применяемый для моделирования взаимодействия между околосистемными и
    внутрисистемными объектами. Такое взаимодействие предусматривает передачу и преобразование событий и внесение изменений
    в представление системы (например, интерфейс).
</p>
<p>
    Пограничные классы моделируют части системы, зависящие от ее окружения. Сущностные и управляющие классы - части, не
    зависящие от околосистемных объектов. Таким образом, изменение GUI или протокола связи вызывает изменение только
    пограничных, но не сущностных и управляющих классов.
</p>
<p>
    Пограничные классы также упрощают понимание системы, поскольку они проясняют ее границы. Они помогают в проектировании,
    предоставляя удобную исходную точку для определения связанных служб. Например, если на ранней стадии проектирования вы
    определяете интерфейс принтера, то вскоре вы должны будете смоделировать форматирование распечаток.
</p>
<p>
    К наиболее распространенным пограничным классам относятся окна, протоколы связи, интерфейсы принтеров, детекторы и
    терминалы. Нет необходимости моделировать рутинные части интерфейсов, такие как кнопки, как отдельные пограничные
    классы. Обычно все окно можно рассматривать как удобный структурный пограничный объект. Пограничные классы полезны
    также при захвате интерфейсов API, которые могут быть не объектно-ориентированными, например устаревшего кода.
</p>
<p>
    Пограничные классы следует моделировать в соответствии с тем, какой тип границы они представляют. Взаимодействие с
    другой системой сильно отличается от взаимодействия с субъектом-пользователем (через пользовательский интерфейс). При
    взаимодействии с субъектом-пользователем самое важное - это интерфейс, представляемый пользователю. При взаимодействии
    с другой системой самое важное - это протокол связи.
</p>
<p>
    Пограничный объект (экземпляр пограничного класса) может пережить экземпляр варианта использования, если, к примеру, он
    должен появиться на экране в промежутке между запуском двух вариантов использования. Однако, как правило, пограничные
    объекты живут столько же, сколько экземпляр варианта использования.
</p>
<h5>
    Выявление пограничных классов
</h5>
<p>
    Пограничный класс выступает посредником между интерфейсом и внешним по отношению к системе объектом. Пограничные
    объекты изолируют систему от изменений в окружающем мире (изменений в интерфейсах связи с другими системами,
    требованиях пользователей и т.п.), не позволяя этим изменениям повлиять на остальную часть системы.
</p>
<p>
    В системе может быть несколько типов пограничных классов:
</p>
<ul>
    <li>
        <b>Классы пользовательского интерфейса</b> - промежуточные классы в соединении с пользователями системы
    </li>
    <li>
        <b>Классы интерфейса системы</b> - промежуточные классы в соединении с другой системой
    </li>
    <li>
        <b>Классы интерфейса устройств</b> - классы, предоставляющие интерфейс устройствам (например, детекторам),
        обнаруживающим внешние события
    </li>
</ul>
<h5>
    Выявление классов пользовательского интерфейса
</h5>
<p>
    Определите один пограничный класс для каждой пары вариант использования - субъект. Этот класс будет отвечать за
    координирование взаимодействия с субъектом. Можно также определить <b>вспомогательные</b> пограничные классы, которым
    основной пограничный класс передаст часть своих обязанностей. Это уместно, прежде всего, в случае приложений GUI с
    окнами, в которых можно смоделировать по одному пограничному объекту для каждого окна или для каждой формы. Моделируйте
    лишь ключевые абстракции системы; не моделируйте каждую кнопку, список и виджет в GUI. Цель анализа - сформировать
    адекватную картину компонентов, из которых составлена система, а не проектировать все до мельчайших подробностей.
    Другими словами, определите пограничные классы только для явлений в системе или для объектов, упомянутых в <b>потоке
    событий</b> реализации варианта использования в анализе.
</p>
<p>
    Сделайте наброски или воспользуйтесь дампами содержимого экрана из раздела <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_user_interface_prototype_7237E5AA.html" guid="{3DF10D00-8C80-4429-92B8-C6A221F0F90C}">Прототип пользовательского интерфейса</a>, иллюстрирующими характеристики
    и внешний вид пограничных классов.
</p>
<h5>
    Выявление классов интерфейса системы
</h5>
<p>
    Пограничный класс, взаимодействующий с внешней системой, отвечает за ведение диалога с ней; он предоставляет интерфейс
    этой системы для создаваемой системы.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    Снятие средств в банкомате должно быть проверено сетью банкомата - субъектом (который, в свою очередь, сверяет снятие с
    банковской учетной системой). Для обеспечения связи с сетью банкомата можно определить объект Интерфейс сети банкомата.
</p>
<p>
    Интерфейс существующей системы может уже быть определенным; в этом случае, обязанности должны быть выведены
    непосредственно из определения интерфейса. Если существует формальное определение интерфейса, то его можно
    деформализовать, поскольку в формальном определении здесь нет необходимости; просто запомните, что существующий
    интерфейс будет использован повторно во время проектирования.
</p>
<h5>
    Выявление классов интерфейса устройств
</h5>
<p>
    В системе могут быть элементы, действующие как внешние (спонтанно изменяющие значение без влияния какого-либо объекта
    системы), например оборудование детекторов. Хотя такой тип внешнего устройства и можно представить с помощью субъектов,
    такое представление может оказаться неудобным для пользователей системы, поскольку в нем прослеживается тенденция
    ставить устройства-субъекты и пользователей-субъектов на один "уровень". Отказываясь от объединения требований, мы,
    однако, должны рассмотреть источник всех внешних событий и убедиться, что система может их распознавать.
</p>
<p>
    Если устройство представлено как субъект в модели варианта использования, то применение пограничного класса в качестве
    посредника в соединении между устройством и системой вполне оправданно. Если модель варианта использования не включает
    эти "устройства-субъекты", то теперь пришло время их добавить, обновив при необходимости Дополнительные описания
    вариантов использования.
</p>
<p>
    Для каждого "устройства-субъекта" создайте пограничный класс, которому будут переданы обязанности устройства или
    детектора. Если для устройства уже существует формально определенный интерфейс, запомните его - он понадобится вам во
    время проектирования.
</p>
<h4>
    <a id="Control Class Def" name="Control Class Def">Управляющий класс</a> <font size="2"><img height="37"     alt="Значок управляющего класса" src="./../../../core.base_rup/guidances/guidelines/resources/control.jpg" width="36" /></font>
</h4>
<p>
    <b>Управляющий класс</b> - это класс, служащий для моделирования управляющего поведения для одного или нескольких
    вариантов использования. Управляющие объекты (экземпляры управляющих классов) часто контролируют другие объекты,
    поэтому их поведение можно назвать координирующим. Управляющие классы инкапсулируют конкретное поведение для варианта
    использования.
</p>
<p>
    Поведение управляющего объекта тесно связано с реализацией конкретного варианта использования. Во многих сценариях
    можно даже сказать, что управляющие объекты "запускают" реализации варианта использования в анализе. Однако некоторые
    управляющие объекты участвуют сразу в нескольких реализациях варианта использования в анализе, если задачи варианта
    использования тесно взаимосвязаны. Более того, несколько управляющих объектов различных управляющих классов могут
    участвовать в одном варианте использования. Не всем вариантам использования нужен управляющий объект. Например, если
    поток событий в варианте использования связан с одним сущностным объектом, то этот вариант использования может
    реализовываться пограничным объектом совместно с сущностным объектом. Вы можете начать с определения одного
    управляющего класса для реализации варианта использования в анализе, а затем уточнить это по мере определения других
    реализаций варианта использования в анализе и обнаружения общности.
</p>
<p>
    Управляющие классы могут давать вклад в понимание системы, поскольку они представляют динамику системы, обработку
    основных задач и управляющие потоки.
</p>
<p>
    Когда система выполняет вариант использования, создается управляющий объект. По окончании выполнения варианта
    использования его управляющие объекты обычно уничтожаются.
</p>
<p>
    Заметьте, что управляющий класс не обрабатывает <b>все</b>, что требуется в варианте использования. Он лишь
    координирует задачи других объектов, реализующих функциональную возможность. Управляющий класс делегирует задания
    объектам, которые были назначены ответственными за функциональную возможность.
</p>
<h5>
    Выявление управляющих классов
</h5>
<p>
    Управляющие классы координируют работу системы. Некоторые варианты использования могут выполняться системой и без
    управляющих объектов (а только с сущностными и пограничными объектами) - особенно варианты использования,
    предусматривающие лишь простое манипулирование хранимой информацией.
</p>
<p>
    Более сложные варианты использования обычно требуют применения одного или нескольких управляющих классов для
    координирования поведения остальных объектов системы. Примерами управляющих объектов могут служить такие программы, как
    администраторы транзакций, координаторы ресурсов и обработчики ошибок.
</p>
<p>
    Управляющие классы эффективно разъединяют пограничные и сущностные объекты, делая систему более устойчивой к изменениям
    в ее пограничном слое. Они также отделяют поведение, связанное с вариантами использования, от сущностных объектов,
    делая последние более пригодными к многоразовому применению в вариантах использования и системах.
</p>
<p>
    Управляющие классы предоставляют поведение, которое:
</p>
<ul>
    <li>
        Не зависит от околосистемных объектов (не меняется при изменении этих объектов),
    </li>
    <li>
        Определяет управляющую логику (порядок событий) и транзакции в варианте использования.
    </li>
    <li>
        Мало меняется при изменении внутренней структуры или поведения сущностных классов,
    </li>
    <li>
        Использует или задает содержимое нескольких сущностных классов и поэтому должно координировать их поведение.
    </li>
    <li>
        Выполняется по-разному при каждой активации (поток событий может находиться в нескольких состояниях).
    </li>
</ul>
<h5>
    Решение вопроса о необходимости управляющего класса
</h5>
<p>
    Поток событий варианта использования определяет порядок выполнения различных задач. Сначала выясните, можно ли
    управлять потоком с помощью уже уже определенных пограничных и сущностных классов. Для простых <b>потоков событий</b>,
    которые, в основном, вводят, извлекают и отображают (или изменяют) информацию, применение отдельного управляющего
    класса обычно не оправдано; за координирование варианта использования будут отвечать пограничные классы.
</p>
<p>
    <b>Поток событий</b> должен быть инкапсулирован в отдельный управляющий класс, если поток сложный и состоит из
    динамического поведения, которое может изменяться независимо от интерфейсов (пограничных классов) и хранилищ информации
    (сущностных классов) системы. За счет инкапсулирования <b>потоков событий</b> один и тот же управляющий класс может
    быть многократно использован для нескольких систем с разными интерфейсами и хранилищами информации (или, по крайней
    мере, базовыми структурами данных).
</p>
<p class="example">
    <b>Пример: управление очередью задач</b>
</p>
<p class="example">
    Вы можете определить управляющий класс из варианта использования Выполнить задачу в Системе управления складом. Этот
    управляющий класс обрабатывает очередь задач, обеспечивая правильный порядок их выполнения. Очередная задача в очереди
    выполняется, как только выделяется соответствующее передающее оборудование. Таким образом, система может одновременно
    выполнять несколько задач.
</p>
<p class="example">
    Поведение, определяемое соответствующим управляющим объектом, будет проще описать, если вы разделите его на два
    управляющих класса - Исполнитель задач и Обработчик очереди. Объект Обработчик очереди следит только за порядком в
    очереди и выделением передающего оборудования. Для всей очереди достаточно одного объекта Обработчик очереди. Когда
    система переходит к выполнению очередной задачи, она создает новый объект Исполнитель задачи, который и выполняет
    задачу. Таким образом, для каждой выполняемой системой задачи необходим отдельный объект Исполнитель задачи.
</p>
<p align="center">
    <img height="164"     alt='Слишком сложные классы должны быть разделены на классы с согласованными взаимосвязанными обязанностями'     src="./../../../core.base_rup/guidances/guidelines/resources/splitclass.gif" width="403" />
</p>
<p class="picturetext" align="center">
    Сложные классы следует разделять по линиям схожих обязанностей
</p>
<p class="example">
    Принципиальное достоинство этого разбиения заключается в том, что мы отделили обязанности, связанные с обработкой
    очереди (нечто, относящееся сразу ко многим вариантам использования), от конкретных задач управления задачами,
    относящихся к этому варианту использования. Это упрощает понимание классов и их адаптацию по мере развития проекта.
    Кроме того, это позволяет сбалансировать нагрузку на систему, поскольку для обработки заданий можно создать столько
    Исполнителей задач, сколько необходимо.
</p>
<h5>
    Инкапсуляция основного и альтернативных/исключительных потоков событий в разных управляющих классах
</h5>
<p>
    Для того чтобы проще было вносить изменения, инкапсулируйте основной и альтернативные потоки событий в разных
    управляющих классах. Если альтернативные и исключительные потоки полностью независимы, отделите и их друг от друга. Это
    упростит расширение и обслуживание системы в будущем.
</p>
<h5>
    Разделение управляющих классов, в которых два субъекта совместно используют один и тот же управляющий класс
</h5>
<p>
    Управляющие классы также может потребоваться разделить, если несколько субъектов используют один и тот же управляющий
    класс. Это позволит изолировать изменения в требованиях одного субъекта от остальной части системы. В случае, когда
    стоимость изменения высока или его последствия неприемлемы, вы должны определить все управляющие классы, связанные с
    несколькими субъектами, и разделить их. В идеальном случае каждый управляющий класс должен взаимодействовать (через
    некоторый пограничный объект) не более чем с одним субъектом.
</p>
<p class="exampleheading">
    Пример: управление вызовами
</p>
<p class="example">
    Рассмотрим вариант использования <b>Локальный вызов</b>. Первоначально мы можем определить управляющий класс, чтобы
    управлять самим вызовом.
</p>
<p class="example" align="center">
    <img height="295"     alt="Различные субъекты, участвующие в варианте использования, обычно требуют отдельных управляющих классов"     src="./../../../core.base_rup/guidances/guidelines/resources/ac_ucan2.gif" width="362" />
</p>
<p class="picturetext">
    Управляющий класс, обрабатывающий локальные телефонные звонки в телефонной системе, можно быстро разбить на два
    управляющих класса - <b>A-поведение</b> и <b>B-поведение</b>, по одному для каждого участвующего субъекта.
</p>
<p class="example">
    В локальном телефонном звонке участвуют два субъекта: <b>A-подписчик</b>, инициализирующий вызов, и <b>B-подписчик</b>,
    принимающий вызов. <b>A-подписчик</b> берет трубку, слышит долгий гудок, затем набирает номер, который система
    сохраняет и анализирует. После получения всех цифр система отправляет прерывистый гудок субъекту <b>A-подписчик</b> и
    звонок субъекту <b>B-подписчик</b>. В момент, когда субъект <b>B-подписчик</b> отвечает, гудок и звонок прекращаются и
    начинается диалог между подписчиками. Когда оба подписчика вешают трубку, вызов завершается.
</p>
<p class="example">
    Необходимо контролировать два типа поведения: что происходит в системе A-подписчика и что происходит в системе
    B-подписчика. По этой причине, исходный управляющий объект был разделен на два управляющих объекта - <b>A-подписчик</b>
    и <b>B-подписчик</b>.
</p>
<p>
    Разделять управляющий класс не нужно, если:
</p>
<ul>
    <li>
        Вы можете быть уверены, что поведение субъектов, связанных с объектами управляющего класса, не изменится или
        изменится лишь незначительно.
    </li>
    <li>
        Поведение объекта управляющего класса по отношению к одному субъекту практически не связано с его поведением по
        отношению к другому субъекту, так что все типы поведения можно хранить в одном объекте. Такое объединение типов
        поведения затрудняет внесение изменений.
    </li>
</ul>
<h4>
    <a id="Entity Class Def" name="Entity Class Def">Сущностный класс</a> <font size="2"><img height="37"     alt="Значок сущностного класса" src="./../../../core.base_rup/guidances/guidelines/resources/entity.jpg" width="37" /></font>
</h4>
<p>
    <b>Сущностный класс</b> - это класс, применяемый для моделирования хранимой информации и связанного с ней поведения.
    Сущностные объекты (экземпляры сущностных классов) служат для хранения и обновления информации о некотором явлении,
    например о событии, пользователе или реально существующем объекте. Обычно это постоянные объекты с атрибутами и
    взаимосвязями, необходимыми в течение длительного времени, иногда - в течение всей жизни системы.
</p>
<p>
    Сущностный объект обычно не связан с какой-нибудь одной конкретной реализацией варианта использования в анализе; иногда
    сущностный объект не связан даже с самой системой. Значения его атрибутов и взаимосвязей часто задаются субъектом. В
    некоторых случаях сущностный объект может понадобиться для выполнения внутренних системных задач. Поведение сущностных
    объектов может быть столь же сложным, сколь и у других стереотипов объектов. Однако, в отличие от других объектов, это
    поведение тесно связано с явлением, которое представляет сущностный объект. Сущностные объекты не зависят от среды
    (субъектов).
</p>
<p>
    Сущностные объекты представляют ключевые концепции разрабатываемой системы. Типичными примерами сущностных классов в
    банковской системе могут служить <b>Учетная запись</b> и <b>Клиент</b>. В системе сетевой обработки - соответственно
    <b>Узел</b> и <b>Ссылка</b>.
</p>
<p>
    Если моделируемое явление не используется другими классами, то его можно смоделировать как атрибут сущностного класса
    или даже как взаимосвязь между сущностными классами. С другой стороны, если явление используется любым другим классом в
    модели проектирования, то его необходимо моделировать как класс.
</p>
<p>
    Сущностные классы предоставляют другую точку зрения для изучения системы. Они демонстрируют логическую структуру
    данных, которая поможет вам понять, что система должна предлагать своим пользователям.
</p>
<h5>
    Выявление сущностных классов
</h5>
<p>
    Сущностные классы представляют хранилища информации в системе; они обычно используются для представления ключевых
    концепций системы. Сущностные объекты, как правило, пассивны и постоянны. Их основные обязанности заключаются в
    хранении и управлении информацией в системе.
</p>
<p>
    Источником для образования сущностных классов часто служат Глоссарий (разработанный во время определения требований) и
    модель бизнес-домена (разработанная во время моделирования бизнеса, если оно выполнялось).
</p>
<h3>
    <a id="Recommended Restrictions on the Use of Association" name="Recommended Restrictions on the Use of Association">Ограничения на использование стереотипа ассоциации</a>
</h3>
<h4>
    <b><a id="Restrictions for Boundary Classes" name="Restrictions for Boundary Classes">Ограничения для пограничных
    классов</a></b>
</h4>
<p>
    Допустимо следующее:
</p>
<ul>
    <li>
        Ассоциации связи между двумя пограничными классами, например, для описания связи конкретного окна с другими
        пограничными объектами.
    </li>
    <li>
        Ассоциации связи или подписки, ведущие от пограничного класса к сущностному классу, поскольку пограничным объектам
        может понадобиться отслеживать определенные сущностные объекты между действиями в пограничном объекте или получать
        информацию об изменениях состояния в сущностном объекте.
    </li>
    <li>
        Ассоциации связи, ведущие от пограничного класса к управляющему классу, так что пограничный объект может
        активизировать конкретное поведение.
    </li>
</ul>
<h4>
    <b><a id="Restrictions for Control Classes" name="Restrictions for Control Classes">Ограничения для управляющих
    классов</a></b>
</h4>
<p>
    Допустимо следующее:
</p>
<ul>
    <li>
        Ассоциации связи или подписки между управляющими и сущностными классами, поскольку управляющим объектам может
        понадобиться отслеживать определенные сущностные объекты между действиями в управляющем объекте или получать
        информацию об изменениях состояния в сущностном объекте.
    </li>
    <li>
        Ассоциации связи между управляющими и пограничными классами, позволяющие передавать результаты активизированного
        поведения в среду.
    </li>
    <li>
        Ассоциации связи между управляющими классами, позволяющие создавать более сложные шаблоны поведения.
    </li>
</ul>
<h4>
    <b><a id="Restrictions Entity Classes" name="Restrictions Entity Classes">Ограничения для сущностных классов</a></b>
</h4>
<p>
    Сущностные классы должны быть только источником ассоциаций (связи или подписки) для других сущностных классов. Объекты
    сущностных классов, как правило, живут долго; напротив, объекты управляющих и пограничных классов, как правило, живут
    мало. С архитектурной точки зрения важно ограничить область, в пределах которой сущностный объект "видит" свое
    окружение, чтобы было легче вносить изменения в систему.
</p>
<h4>
    <b><a id="Summary of Restrictions" name="Summary of Restrictions">Обзор ограничений</a></b>
</h4>
<div align="center">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="85%"     summary="Допустимые сочетания стереотипов ассоциаций" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <th scope="col" width="20%">
                    ИзВ<br />
                     (перемещаемость)
                </th>
                <th scope="col" align="middle" width="26%">
                    <p class="tableheading">
                        Пограничный
                    </p>
                </th>
                <th scope="col" align="middle" width="27%">
                    <b>Сущностный</b>
                </th>
                <th scope="col" align="middle" width="27%">
                    <p class="tableheading">
                        Управляющий
                    </p>
                </th>
            </tr>
            <tr>
                <th width="20%">
                    <p class="tableheading">
                        Пограничный
                    </p>
                </th>
                <td align="middle" width="26%">
                    <p align="center">
                        связь
                    </p>
                </td>
                <td align="middle" width="27%">
                    связь 
                    <p>
                        подписка
                    </p>
                </td>
                <td align="middle" width="27%">
                    связь
                </td>
            </tr>
            <tr>
                <th width="20%">
                    <p class="tableheading">
                        Сущностный
                    </p>
                </th>
                <td align="middle" width="26%">
                </td>
                <td align="middle" width="27%">
                    связь 
                    <p>
                        подписка
                    </p>
                </td>
                <td align="middle" width="27%">
                    &nbsp;
                </td>
            </tr>
            <tr>
                <th width="20%">
                    <p class="tableheading">
                        Управляющий
                    </p>
                </th>
                <td align="middle" width="26%">
                    <p align="center">
                        связь
                    </p>
                </td>
                <td align="middle" width="27%">
                    связь 
                    <p>
                        подписка
                    </p>
                </td>
                <td align="middle" width="27%">
                    связь
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p class="picturetext">
    Допустимые сочетания стереотипов ассоциаций
</p>
<h3>
    <a id="Enforcing Consistency" name="Enforcing Consistency">Обеспечение согласованности</a>
</h3>
<ul>
    <li>
        При определении нового типа поведения проверьте, существует ли класс со схожими обязанностями. Всегда, когда это
        возможно, используйте классы повторно. Только убедившись в отсутствии объекта, который может выполнять такое
        поведение, создавайте новые классы.
    </li>
    <li>
        После определения классов проверьте их, чтобы убедиться в согласованности их обязанностей. Если обязанности классов
        не пересекаются, разбейте объект на два или более классов. Соответственно, обновите диаграммы взаимодействия.
    </li>
    <li>
        Если класс разбит из-за наличия в нем непересекающихся обязанностей, проверьте шаблоны, в которых класс играет
        роль, и выясните, требуется ли их обновление. Обновите шаблоны, если это необходимо.
    </li>
    <li>
        Класс всего лишь с одной обязанностью сам по себе не является проблемой, но возникает вопрос, зачем он нужен.
        Существование всех классов должно быть оправданным.
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
