<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Капсула</title>
<meta content="Guideline" name="uma.type">
<meta content="capsule" name="uma.name">
<meta content="Капсула" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "7.026940817483919E-306"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "7.026940817483919E-306"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="7.026940817483919E-306"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Капсула</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">В этой рекомендации описывается концепция программного обеспечения, работающего в режиме реального времени, под названием Капсула.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Капсула</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/identify_design_elements_E884AB82.html" guid="{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}">Определение элементов проекта</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html" guid="{CAA385CA-2BA2-40F2-8FE3-E21089D02119}">Проектирование подсистемы</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_capsule_designer_F3E66EDF.html" guid="{86253FE7-0036-4D14-8BD7-C18CE86A5E14}">Проектировщик капсул</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_concurrency__capsule_guidelines" name="XE_concurrency__capsule_guidelines"></a><a id="XE_capsule__guidelines_for" name="XE_capsule__guidelines_for"></a> 
<h3 class="reactive">
    Разделы
</h3>
<ul class="reactive">
    <li>
        <a href="#Ports">Порты</a> 
        <ul class="reactive">
            <li>
                <a href="#Relay ports">Промежуточные порты</a>
            </li>
            <li>
                <a href="#End Ports">Конечные порты</a>
            </li>
            <li>
                <a href="#Port Visibility">Область видимости порта</a>
            </li>
            <li>
                <a href="#Port-Based Triggers">Триггеры на основе портов</a>
            </li>
        </ul>
    </li>
    <li>
        <a href="#State Machines">Конечные автоматы</a>
    </li>
    <li>
        <a href="#Time Service">Служба времени</a>
    </li>
    <li>
        <a href="#Capsule Taxonomy">Таксономия капсул</a>
    </li>
    <li>
        <a href="#UML_2.0_Representation">Представление UML 2.0</a>
    </li>
</ul>
<h3 class="reactive">
    <a id="Ports" name="Ports">Порты</a>
</h3>
<p class="reactive">
    Так как порты находятся на границе капсулы, они могут быть видны как снаружи, так и изнутри капсулы. При просмотре
    снаружи все порты представляют один и тот же непроницаемый объектный интерфейс и различаются лишь по идентификаторам и
    ролям, которые они играют в протоколе. Напротив, при просмотре изнутри капсулы порты подразделяются на два типа:
    <b>промежуточные порты</b> и <b>конечные порты</b>. Они различаются по своим внутренним соединениям: промежуточные
    порты подключены к подкапсулам, а конечные - к конечному автомату капсулы. Вообще говоря, промежуточные порты служат
    для выборочного экспортирования "интерфейсов" внутренних подкапсул, а конечные порты - это пограничные объекты для
    конечного автомата капсулы. И промежуточные, и конечные порты могут находиться на границе капсулы и, как указано выше,
    недостижимы снаружи.
</p>
<h4 class="reactive">
    <a id="Relay ports" name="Relay ports"><font size="3">Промежуточные порты</font></a>
</h4>
<p class="reactive">
    <b>Промежуточные порты</b> - это порты, которые просто пропускают через себя все сигналы. Они предоставляют "отверстие"
    в оболочке инкапсуляции в капсуле, через которое подкапсулы могут контактировать с внешним миром, оставаясь невидимыми
    для него (и наоборот). Промежуточный порт подключен, через соединитель, к подкапсуле и обычно также подключен снаружи к
    некоторой другой "равноправной" капсуле. Они принимают сигналы от обеих сторон и просто передают их другой стороне,
    сохраняя направление потока сигналов. Это достигается без задержек и потерь информации, за исключением случая, когда к
    другой стороне не подключен соединитель. В последнем случае сигнал теряется.
</p>
<p class="reactive">
    Промежуточные порты позволяют напрямую (с нулевой дополнительной нагрузкой) передавать сигналы, предназначенные для
    капсулы, в подкапсулу без вмешательства со стороны конечного автомата капсулы. Промежуточные порты могут находиться
    только на границе капсулы, следовательно, их область видимости всегда <b>общедоступная</b>.
</p>
<h4 class="reactive">
    <a id="End Ports" name="End Ports"><font size="3">Конечные порты</font></a>
</h4>
<p class="reactive">
    Для того чтобы быть полезной, цепочка соединителей должна завершаться конечным портом, соединенным с конечным
    автоматом. Конечные порты - это пограничные объекты для конечных автоматов из капсул (хотя, как будет показано ниже,
    некоторые из них служат также пограничными объектами для капсул). Конечные порты - это первичные источники и последние
    приемники всех сигналов, отправляемых капсулами. Эти сигналы создаются конечными автоматами капсул. Для отправки
    сигнала конечный автомат инициализирует операцию отправки или вызова на одном из своих конечных портов. Затем сигнал
    передается через подключенный соединитель, возможно, проходя при этом через один или несколько промежуточных портов и
    сцепленных соединителей, пока не достигнет другого конечного порта, обычно расположенного в другой капсуле. Поскольку
    связь, основанная на обмене сигналами, может быть асинхронной, конечный порт содержит очередь для сообщений,
    полученных, но пока не обработанных конечным автоматом (т.е. он играет роль почтового ящика). Прием сигнала и отправка
    в принимающий конечный автомат выполняется конечным автоматом согласно стандартной семантике UML.
</p>
<p class="reactive">
    Как и промежуточные порты, конечные порты могут находиться на границе капсулы с общедоступной областью видимости. Эти
    порты называются <b>общедоступными конечными портами</b>. Такие порты являются пограничными объектами и конечного
    автомата, и содержащей его капсулы. Однако конечный порт может находиться и целиком внутри капсулы, будучи частью ее
    внутренней структуры реализации. Эти порты применяются конечным автоматом для связи с его подкапсулами или внешними
    <b>слоями поддержки реализации</b>. Эти внутренние конечные порты называются <b>защищенными конечными портами</b>,
    поскольку их область видимости защищена.
</p>
<p class="reactive">
    Учтите, что тип порта полностью определяется его внутренними соединениями и его областью видимости вне капсулы;
    различные термины (промежуточный порт, общедоступный конечный порт, частный конечный порт) служат лишь сокращениями.
    Общедоступный порт без внутренних соединений может стать либо промежуточным, либо конечным портом, в зависимости от
    того, как он будет подключен впоследствии, но он может остаться и неподключенным и служить приемником поступающих
    сигналов.
</p>
<h4 class="reactive">
    <a id="Port Visibility" name="Port Visibility"><font size="3">Область видимости порта</font></a>
</h4>
<p class="reactive">
    С внешней точки зрения, порт - это просто порт; определить, является ли этот порт промежуточным или конечным,
    невозможно в принципе. Однако, если показано разложение капсулы на составные компоненты, то различие между конечным и
    промежуточным портами отмечено графически, как указано ниже.
</p>
<p class="reactive" align="center">
    <img height="173" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_cpsl1.gif" width="451" />
</p>
<p class="reactivepicturetext" align="center">
    Обозначение порта - диаграмма связи (вид изнутри)
</p>
<h4 class="reactive">
    <a id="Port-Based Triggers" name="Port-Based Triggers"><font size="3">Триггеры на основе портов</font></a>
</h4>
<p class="reactive">
    На практике часто бывает, что два или более портов одной и той же капсулы используют один и тот же протокол, но
    семантически различны. Кроме того, один и тот же сигнал может появиться в нескольких ролях протокола, поддерживаемых
    различными портами капсулы. В любом случае, может потребоваться различать конкретный конечный порт, получивший текущий
    сигнал. Это позволит приложениям обрабатывать один и тот же сигнал по-разному в зависимости от источника этого сигнала,
    а также состояния. Такой тип триггера называется <b>триггер на основе портов</b>. Триггеры на основе портов
    моделируются в UML с помощью сторожевых условий, проверяющих соответствие конкретному исходному порту.
</p>
<h3 class="reactive">
    <a id="State Machines" name="State Machines"><font size="4">Конечные автоматы</font></a>
</h3>
<p class="reactive">
    Спецификация конечного автомата капсулы и спецификация допустимых последовательной протокола задаются с помощью
    стандартных конечных автоматов UML.
</p>
<h3 class="reactive">
    <a id="Time Service" name="Time Service"><font size="3"><font size="4">Служба времени</font></font></a>
</h3>
<p class="reactive">
    Как и следовало ожидать, в большинстве систем реального времени фактор времени является первоочередным. В общем случае,
    необходимо смоделировать две формы ситуаций режима реального времени: возможность активизировать задачи в заданное
    <b>время дня</b> и возможность активизировать задачи по истечении заданного <i>интервала</i> с определенного момента
    отсчета.
</p>
<p class="reactive">
    Большинству систем, работающих в режиме реального времени, требуется явная и доступная непосредственно (в управляемом
    режиме) утилита времени - <b>служба времени</b>. Эта служба, доступная через стандартный порт (точку доступа к службе),
    преобразует время в события, которыми впоследствии можно будет управлять так же, как и другими событиями, основанными
    на сигналах. Например, при наличии такой службы конечный автомат может запросить уведомление в виде события "тайм-аута"
    при наступлении заданного времени дня или истечении заданного интервала.
</p>
<h3 class="reactive">
    <a id="Capsule Taxonomy" name="Capsule Taxonomy"><font size="4">Таксономия капсул</font></a>
</h3>
<p class="reactive">
    Как концепция, капсулы могут использоваться самыми разными способами. Возможные варианты применения капсул описываются
    в рамках иерархии и таксономии капсул.
</p>
<p class="reactive" align="center">
    <map id="FPMap0" name="FPMap0">
        <area shape="rect" alt="Реализация модели роли" coords="219,297,363,349" href="#Role Model Realization"></area>
        <area shape="rect" alt="Типовая модель роли" coords="137,216,264,265" href="#Typed Role Model"></area>
        <area shape="rect" alt="Типовая реализация роли" coords="373,248,525,295" href="#Typed Role Realization"></area>
        <area shape="rect" alt="Реализация роли" coords="395,110,541,154" href="#Role Realization"></area>
        <area shape="rect" alt="Капсула" coords="94,2,166,46" href="#Capsule"></area>
        <area shape="rect" alt="Модель роли" coords="252,114,365,161" href="#Role Model"></area>
        <area shape="rect" alt="Тип роли" coords="98,112,211,160" href="#Role Type"></area>
    </map><img height="467" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_cpsl5.gif" width="635" usemap="#fpmap0"     border="0" />
</p>
<p class="reactivepicturetext" align="center">
    Таксономия капсул с иерархией обобщения
</p>
<p class="reactive" align="left">
    Базовая таксономия капсул - это:
</p>
<ul class="reactive">
    <li>
        <p class="reactive" align="left">
            <a id="Capsule" name="Capsule"><b>Капсула</b></a>
        </p>
        <p class="reactive" align="left">
            Базовая капсула, без портов, внутренней структуры и поведения, не слишком интересна - ее возможности весьма
            ограничены. Такая капсула позволяет определить абстрактную капсулу, порождающую остальные капсулы. Поскольку
            порты, структура и поведение не определены, этот тип капсулы полезен только как средство определения
            "заглушки", которая впоследствии будет уточнена.
        </p>
    </li>
    <li>
        <p class="reactive" align="left">
            <b><a id="Role Type" name="Role Type">Тип роли</a></b>
        </p>
        <p class="reactive" align="left">
            "Тип роли" капсулы состоит из определения капсулы, которое определяет абстрактную капсулу с одним или
            несколькими портами; структура и поведение не определены. Этот тип капсулы применяется в случаях, когда
            "интерфейсы" (порты) набора капсул необходимо определить только один раз; конкретные реализации этих
            интерфейсов будут определяться подтипами капсулы 'типа роли'.
        </p>
    </li>
    <li>
        <p class="reactive" align="left">
            <a id="Role Model" name="Role Model"><b>Модель роли</b></a>
        </p>
        <p class="reactive" align="left">
            "Модель роли" состоит из определения капсулы с внутренней структурой (задаваемой кооперацией спецификации),
            состоящей из вложенных и потенциально взаимосвязанных капсул, а также, возможно, одного или нескольких портов.
            Этот тип капсулы служит для определения "шаблона" для структуры системы, 'подробности' которой предоставляются
            внутренним капсулам. Если у капсулы модели роли есть порты, то эти порты определяют 'интерфейсы' для капсулы.
        </p>
        <p class="reactive" align="left">
            Поведение 'модели роли' не задано (конечный автомат не определен); поведение должно определяться подтипами
            капсулы.
        </p>
    </li>
    <li>
        <p class="reactive" align="left">
            <a id="Role Realization" name="Role Realization"><b>Реализация роли</b></a>
        </p>
        <p class="reactive" align="left">
            "Реализация роли" капсулы определяет поведение (через конечный автомат) для капсулы, но ни внутреннюю
            структуру, ни интерфейсы. В сущности, она предоставляет абстрактное определение поведения для всех производных
            капсул, которые должны сами определить свою внутреннюю структуру и интерфейс. Определение поведения можно
            рассматривать как 'эскиз', которому должны удовлетворять все капсулы, производные по отношению к капсуле
            'реализации роли'.
        </p>
    </li>
</ul>
<p class="reactive" align="left">
    Существуют три полезных гибрида этих базовых типов, представляющие собой сочетание этих базовых определений:
</p>
<ul class="reactive">
    <li>
        <p class="reactive" align="left">
            <a id="Typed Role Realization" name="Typed Role Realization"><b>Типовая реализация роли</b></a>
        </p>
        <p class="reactive" align="left">
            Этот тип капсулы определяет и интерфейс, и поведение набора капсул, но не ограничивает внутреннюю структуру
            производных капсул. Фактически, это капсула 'реализации роли', расширяющая определение интерфейса.
        </p>
    </li>
    <li>
        <p class="reactive" align="left">
            <a id="Typed Role Model" name="Typed Role Model"><b>Типовая модель роли</b></a>
        </p>
        <p class="reactive" align="left">
            Этот тип капсулы определяет интерфейс и структуру набора капсул, но не ограничивает поведение таких капсул.
            Преимущество такого подхода заключается в том, что он позволяет определить шаблон для интерфейса и структуры,
            который впоследствии можно будет обозначить как необходимый производным капсулам.
        </p>
    </li>
    <li>
        <p class="reactive" align="left">
            <a id="Role Model Realization" name="Role Model Realization"><b>Реализация модели роли</b></a>
        </p>
        <p class="reactive" align="left">
            Этот тип капсулы определяет внутреннюю структуру капсулы и ее абстрактное поведение, но не определяет
            интерфейс. Этот тип капсулы полезен в случаях, когда несколько капсул могут совместно использовать значительную
            часть внутренней структуры и поведения, но их интерфейсы различны.
        </p>
    </li>
</ul>
<p class="reactive" align="left">
    Оставшийся тип капсулы, 'типовая реализация модели роли', определяющая структуру и интерфейс, а также поведение в
    абстрактном (для интерфейса) и конкретном (для внутренней структуры) смыслах, сложна и может оказаться трудной для
    понимания при попытке ее правильно реализовать. Она упоминается на случай, если полнофункциональные тесты капсулы
    потребуется определить как часть самой капсулы, а следовательно, как два отдельных конечных автомата. В большинстве
    случаев такую конструкцию следует избегать.
</p>
<h3>
    <a id="UML_2.0_Representation" name="UML_2.0_Representation">Представление UML 2.0</a>
</h3>
<p>
    Учтите, что текущее представление RUP для капсул основано на нотации UML 1.5. Большая часть материала может быть
    представлена в формате UML 2.0 с помощью концепции, описанной в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">Концепция:
    структурированный класс</a>.
</p>
<p>
    Дополнительная информация приведена в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html" guid="4.792914878943572E-306">Различия между UML 1.x и UML 2.0</a>.<br />
    <br />
    <br />
    <br />
</p></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
