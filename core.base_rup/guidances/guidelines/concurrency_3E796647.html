<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Параллелизм</title>
<meta content="Guideline" name="uma.type">
<meta content="concurrency" name="uma.name">
<meta content="Параллелизм" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.5676516174458592E-304"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.5676516174458592E-304"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="1.5676516174458592E-304"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Параллелизм</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Настоящая рекомендация поможет разработчикам выбрать наилучший способ поддержки параллелизма в системе программного обеспечения.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Модель проектирования</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/capsule_design_BF66E39A.html" guid="{F13C1161-7F17-45E3-A8B7-03944A1FA6E4}">Проектирование капсул</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/describe_runtime_architecture_2F8E190.html" guid="{4D35C038-A2D0-48B8-9ECD-52717FEAE33A}">Создание описания архитектуры среды выполнения</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_concurrency__guidelines_for" name="XE_concurrency__guidelines_for"></a> 
<h3>
    <a id="Introduction" name="Introduction">Введение</a>
</h3>
<p>
    Искусство проектирования заключается в выборе "наилучшего" способа удовлетворения заданных требований. Применительно к
    параллельной системе искусство проектирования часто сводится к тому, чтобы найти наиболее простой способ поддержки
    параллелизма. Одна из первых заповедей разработчиков - не изобретать колесо. Многие проблемы можно решить с помощью уже
    готовых шаблонов и стандартов проектирования. Учитывая сложность параллельных систем, единственный эффективный путь -
    использовать уже проверенные средства и стремиться максимально упростить конструкцию.
</p>
<h3>
    <a id="Concurrency approaches" name="Concurrency approaches">Подходы к обеспечению параллелизма</a>
</h3>
<p>
    Параллельные задачи, выполняемые целиком на данном компьютере, называются <b>нитями выполнения</b>. Подобно всем
    параллельным задачам, нити выполнения - это абстрактная концепция, поскольку они происходят во времени. Лучшее, что
    можно сделать для физического захвата нити выполнения, - представить ее состояние в конкретный момент времени.
</p>
<p>
    Самый прямой путь в представлении параллельных задач с помощью компьютеров - выделять отдельный компьютер для каждой
    задачи. Однако это, как правило, слишком дорого и не всегда способствует устранению противоречий. Общепринят другой
    подход: поддерживать выполнение нескольких задач на одном физическом процессоре с помощью той или иной формы
    <b>многозадачности</b>. В этом случае процессор и его ресурсы, такие как память и шина, используются совместно. (К
    сожалению, такое совместное использование ресурсов может повлечь новые конфликты, отсутствовавшие в исходной проблеме.)
</p>
<p>
    Чаще всего проблему многозадачности решают путем выделения каждой задаче "виртуального" процессора. Этот виртуальный
    процессор обычно называют <b>процессом или задачей</b>. Обычно у каждого процесса есть свое адресное пространство,
    логически отделенное от адресного пространства остальных виртуальных процессоров. Это предотвращает конфликты процессов
    из-за памяти. К сожалению, дополнительная нагрузка, связанная с необходимостью переключать физический процессор с
    одного процесса на другой, часто бывает непомерно высока. При переключении процессов смена наборов реестров в CPU
    (<b>переключение контекста</b>) настолько обременительна, что даже у современных высокопроизводительных процессов на
    это уходят сотни микросекунд.
</p>
<p>
    Для снижения этой нагрузки многие операционные системы позволяют обрабатывать несколько <b>упрощенных нитей</b> в одном
    процессе. Такие нити совместно используют адресное пространство процесса. Это ускоряет переключение контекста, но
    повышает вероятность конфликтов памяти.
</p>
<p>
    Для некоторых высокопроизводительных приложений даже нагрузка, связанная с переключением упрощенных нитей, может быть
    слишком высока. В таких случаях иногда применяется еще более упрощенная форма многозадачности, основанная на
    использовании некоторых специальных функций приложения.
</p>
<p>
    Поддержка параллелизма в системе может оказать значительное влияние на ее архитектуру. Решение о переходе от
    однопроцессной к многопроцессной архитектуре предполагает серьезные изменения в структуре системы, причем во многих
    аспектах. Может потребоваться введение дополнительных механизмов (например, вызовов удаленных процедур), которые могут
    сильно отразиться на архитектуре системы.
</p>
<p>
    Необходимо учесть требования к готовности системы, а также дополнительную нагрузку, связанную с управлением
    дополнительными процессами и нитями.
</p>
<p>
    Как и в большинстве архитектурных решений, изменение архитектуры процессов приводит к тому, что вместо одних проблем
    появляются другие:
</p>
<div align="center">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="85%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <th scope="col" width="18%">
                    <p class="tableheading">
                        Подход
                    </p>
                </th>
                <th scope="col" width="46%">
                    <p class="tableheading">
                        Преимущества
                    </p>
                </th>
                <th scope="col" width="46%">
                    <p class="tableheading">
                        Недостатки
                    </p>
                </th>
            </tr>
            <tr>
                <td width="18%">
                    Однопроцессность, отсутствие нитей
                </td>
                <td width="46%">
                    <ul>
                        <li>
                            Простота
                        </li>
                        <li>
                            Быстрый внутрипроцессный обмен сообщениями
                        </li>
                    </ul>
                </td>
                <td width="46%">
                    <ul>
                        <li>
                            Трудности с выравниванием нагрузки
                        </li>
                        <li>
                            Невозможность добавления процессоров
                        </li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td width="18%">
                    Однопроцессность, поддержка нескольких нитей
                </td>
                <td width="46%">
                    <ul>
                        <li>
                            Быстрый внутрипроцессный обмен сообщениями
                        </li>
                        <li>
                            Многозадачность без межпроцессной связи
                        </li>
                        <li>
                            Лучшая многозадачность без нагрузки, связанной со 'сложными' процессами
                        </li>
                    </ul>
                </td>
                <td width="46%">
                    <ul>
                        <li>
                            Необходимость защиты нитей в приложении
                        </li>
                        <li>
                            Необходимость эффективного управления нитями в операционной системе
                        </li>
                        <li>
                            Необходимость учета совместного использования памяти
                        </li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td width="18%">
                    Многопроцессность
                </td>
                <td width="46%">
                    <ul>
                        <li>
                            Простота масштабирования при добавлении процессоров
                        </li>
                        <li>
                            Сравнительная легкость в распределении по узлам
                        </li>
                    </ul>
                </td>
                <td width="46%">
                    <ul>
                        <li>
                            Чувствительность к границам процессов: межпроцессная связь слишком сильно снижает
                            производительность
                        </li>
                        <li>
                            Дорогостоящие подкачка и переключение контекста
                        </li>
                        <li>
                            Сложности в проектировании
                        </li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Типичный эволюционный путь - начать с однопроцессной архитектуры и постепенно добавлять процессы для групп поведений,
    которые должны выполняться одновременно. В этих более широких группах рассматривать дополнительные требования,
    связанные с параллелизмом, и добавлять нити в процессы для увеличения степени параллелизма.
</p>
<p>
    Исходная точка - присвоить много активных объектов одной задаче или нити операционной системы, воспользовавшись
    специально предназначенным для этой цели планировщиком работы с активными объектами. Обычно таким образом удается
    добиться очень упрощенной имитации параллелизма, хотя в рамках одной задачи или нити операционной системы не удастся
    воспользоваться преимуществами компьютеров с несколькими CPU. &nbsp;Ключевое решение - изолировать блокирующее
    поведение в отдельных нитях, так чтобы оно не стало узким местом. Это приведет к распределению активных объектов с
    блокирующим поведением по отдельным нитям операционной системы.
</p>
<p class="reactive">
    В системах, работающих в режиме реального времени, эти соображения в равной степени относятся и к капсулам: у каждой
    капсулы есть логическая управляющая нить, которая может (но не обязана) совместно использовать нить, задачу или процесс
    операционной системы с другими нитями.
</p>
<h3>
    <a id="Issues" name="Issues">Вопросы</a>
</h3>
<p>
    К сожалению, как и во многих других архитектурных решениях, простых ответов не существует: оптимальный вариант
    достигается при сбалансированном подходе. Для изучения последствий конкретных вариантов выбора можно воспользоваться
    небольшими архитектурными прототипами. При рассмотрении прототипа архитектуры процессов обратите особое внимание на
    возможность повышения числа процессов до теоретически максимального значения системы. Ответьте на следующие вопросы:
</p>
<ul>
    <li>
        Можно ли повысить число процессов до максимума? Насколько можно превысить это число сверх максимума? Есть ли
        возможности для роста?
    </li>
    <li>
        Какое влияние окажет превращение некоторых процессов в упрощенные нити, работающие в совместно используемом
        адресном пространстве процесса?
    </li>
    <li>
        Что происходит с временем ответа при увеличении числа процессов? Увеличивается ли интенсивность межпроцессной связи
        (IPC)? Насколько заметно снижение производительности?
    </li>
    <li>
        Можно ли снизить IPC путем комбинирования или реорганизации процессов? Приведет ли такое изменение к появлению
        больших монолитных процессов, в которых трудно выравнивать нагрузку?
    </li>
    <li>
        Можно ли снизить IPC за счет применения совместно используемой памяти?
    </li>
    <li>
        Следует ли равномерно распределять ресурсы времени между всеми процессами? Возможно ли управлять распределением
        ресурсов времени? Существуют ли потенциальные препятствия для изменения приоритетов планирования?
    </li>
</ul>
<h4>
    <font size="+0"><b><a id="Inter-Object Communications" name="Inter-Object Communications">Межобъектная
    связь</a></b></font>
</h4>
<p>
    Активные объекты могут контактировать друг с другом синхронно или асинхронно. Синхронная связь удобна, поскольку она
    позволяет упростить сложное взаимодействие за счет строго контроля последовательности. Это означает, что, пока активный
    объект находится на шаге "выполнять до конца", включающем синхронные вызовы других активных объектов, все параллельные
    взаимодействия, инициализируемые другими объектами, игнорируются до окончания выполнения всей последовательности.
</p>
<p>
    Хотя такая связь удобна в некоторых случаях, в других она может вызывать проблемы, поскольку может оказаться, что более
    важное высокоприоритетное событие будет ожидать своей очереди (такая ситуация называется инверсией приоритетов).
    Ситуация усугубляется тем, что синхронно вызываемый объект сам может быть заблокирован, поскольку ожидает ответа на
    свой синхронный вызов. Такая ситуация может повлечь за собой неограниченную инверсию приоритетов. В самом худшем
    случае, циклическое замыкание цепочки синхронных вызовов приводит к тупику.
</p>
<p>
    Асинхронные вызовы позволяют избежать этой проблемы, поскольку их время ответа ограничено. Однако, в зависимости от
    архитектуры программного обеспечения, асинхронная связь часто приводит к усложнению кода, так как активному объекту в
    любой момент может потребоваться отвечать на несколько асинхронных событий (каждое из которых может быть связано
    сложной последовательностью асинхронных взаимодействий с другими объектами). Реализация такой концепции вызывает
    значительные трудности, и вероятность ошибок весьма высока. &nbsp;
</p>
<p>
    Упростить задачу программирования приложения позволяет технология асинхронного обмена сообщениями с гарантированной
    доставкой. Приложение может продолжать работу, даже если сетевое соединение или удаленное приложение недоступны.
    Асинхронный обмен сообщениями можно использовать и в синхронном режиме. Напротив, синхронная технология требует, чтобы
    соединение было доступно всегда, когда доступно приложение. Поскольку известно, что соединение существует, выполнять
    фиксацию может быть проще.
</p>
<p class="reactive">
    В подходе, рекомендованном в Rational Unified Process для систем, работающих в режиме реального времени, <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">капсулы</a> контактируют асинхронно посредством <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_signal_AD16C912.html" guid="{8CA124DA-A80C-45D7-BC65-BA6B4247FF11}">сигналов</a>, согласно конкретным <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_protocol_BEB5FBE1.html" guid="{6E4F4D6F-2934-432C-9335-5537B795F67F}">протоколам</a>. Тем не менее, можно осуществлять и синхронную связь - за
    счет использования пар сигналов, по одному в каждом направлении.
</p>
<h4>
    <font size="+0"><b><a id="Pragmatics" name="Pragmatics">Прагматические соображения</a></b></font>
</h4>
<p>
    Хотя нагрузка, связанная с переключением контекста, для активных объектов может быть невелика, некоторые приложения все
    равно могут счесть ее неприемлемой. Это обычно происходит в случаях, когда необходимо быстро обрабатывать большие
    объемы данных. В таких случаях может потребоваться вернуться к применению пассивных объектов и более традиционных (но и
    более рискованных) приемов управления параллелизмом, например семафоров.
</p>
<p>
    Указанные соображения, однако, не обязательно означают, что мы должны вовсе отказаться от применения активных объектов.
    Даже в приложениях, интенсивно обменивающихся данными, часто бывает так, что компоненты, чувствительные к
    производительности, являются лишь небольшой частью всей системы. Это означает, что в остальной части системы можно
    пользоваться активными объектами.
</p>
<p>
    В целом, производительность - это только один из критериев, который следует учитывать при проектировании системы. Если
    система сложна, то другие критерии, такие как простота обслуживания, модифицируемость, понятность и др., не менее, а
    иногда и более важны. Применение активных объектов обладает несомненным преимуществом, поскольку скрывает большую часть
    сложностей, связанных с параллелизмом и управлением параллелизмом, и в то же время позволяет выражать концепции
    проектирования в терминах приложений, а не в терминах низкоуровневых механизмов, относящихся к той или иной конкретной
    технологии.
</p>
<h3>
    <a id="Heuristics" name="Heuristics">Эвристические соображения</a>
</h3>
<h4>
    <a id="Focus on interactions" name="Focus on interactions">Сконцентрируйтесь на взаимодействии параллельных
    компонентов</a>
</h4>
<p>
    Параллельные компоненты без взаимодействия представляют собой, в общем-то, тривиальную проблему. Практически все
    проблемы проектирования связаны с обеспечением взаимодействия между параллельными задачами, поэтому прежде всего
    необходимо разобраться в том, как осуществляется взаимодействие. Ответьте на следующие вопросы:
</p>
<ul>
    <li>
        Является ли взаимодействие одно-, дву- или мультинаправленным?
    </li>
    <li>
        Существует ли взаимосвязь типа клиент-сервер или типа главный-подчиненный?
    </li>
    <li>
        Требуется ли синхронизация в какой-либо форме?
    </li>
</ul>
<p>
    Разобравшись с тем, как устроено взаимодействие, мы можем подумать о том, как его реализовать. При выборе реализации
    следует стремиться к максимальной простоте конфигурации, согласующейся, однако, с требованиями к производительности
    системы. Требования к производительности обычно включают как общий уровень производительности, так и приемлемую
    латентность при ответе на внешние события.
</p>
<p class="reactive">
    Эти вопросы еще более актуальны для систем, работающих в режиме реального времени. Такие системы обычно очень
    чувствительны к колебаниям производительности, например 'искажениям' во времени ответа или нарушению сроков выполнения
    требуемых действий.
</p>
<h4>
    <a id="Isolate and encapsulate external interfaces." name="Isolate and encapsulate external interfaces.">Изолируйте и
    инкапсулируйте внешние интерфейсы</a>
</h4>
<p>
    Весьма опасно строить работу приложения на основе каких-либо конкретных предположений о внешних интерфейсах и крайне
    неэффективно блокировать сразу несколько управляющих нитей в ожидании события. Вместо этого назначьте отдельному
    объекту выделенную задачу обнаружения события. Когда событие произойдет, этот объект сможет уведомить об этом всех,
    кому это необходимо. Такая конфигурация основана на стандартном и хорошо себя зарекомендовавшем шаблоне проектирования
    "Наблюдатель" [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" guid="7.755968586980351E-308">GAM94</a>]. При необходимости ее легко расширить до более гибкого шаблона
    "Издатель-подписчик", в котором издатель играет роль промежуточного объекта между объектами, обнаруживающими события, и
    объектами, заинтересованными в событиях ("подписчиками") [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" guid="7.755968586980351E-308">BUS96</a>].
</p>
<h4>
    <a id="Isolate and encapsulate blocking and polling behavior." name="Isolate and encapsulate blocking and polling behavior.">Изолируйте и инкапсулируйте блокировки и опросы</a>
</h4>
<p>
    Инициатором действий в системе могут выступать внешние события. Примером очень важного внешнего события может служить
    простая передача времени часов. Другие внешние события поступают от устройств ввода, подключенных к внешнему
    аппаратному обеспечению, включая пользовательские интерфейсы, датчики процессов и соединения с другими системами. В
    первую очередь, это относится к системам, работающим в режиме реального времени, которые обычно тесно связаны с
    окружающим миром.
</p>
<p>
    Для того чтобы программное обеспечение могло обнаружить событие, оно должно либо быть заблокировано в ожидании
    прерывания, либо периодически проверять аппаратное обеспечение с целью выяснить, не произошло ли событие. В последнем
    случае период опроса должен быть достаточно мал, чтобы не пропустить короткоживущие события или несколько вхождений,
    либо просто минимизировать латентный период между возникновением события и его обнаружением.
</p>
<p>
    Интересно, что независимо от того, насколько редко происходит событие, часть программного обеспечения должна быть
    заблокирована, ожидая его или регулярно проверяя, не наступило ли оно. Однако многие (если не большинство) события,
    которые должна обрабатывать система, случаются редко; основную часть времени в любой заданной системе ничего
    существенного не происходит.
</p>
<p>
    Хорошим примером такой системы может служить обычный лифт. Важные события в его жизни - это вызов, выбор этажа
    пассажиром, блокировка дверей пассажиром и перемещение с одного этажа на следующий. Некоторые из этих событий требуют
    немедленного отклика, однако все они происходят чрезвычайно редко в масштабе времени, единицей измерения которого
    служит время ответа.
</p>
<p>
    Простое событие может активизировать многие действия, и эти действия могут зависеть от состояний различных объектов.
    Более того, разные конфигурации системы могут трактовать одно и то же событие по-разному. Например, когда кабина лифта
    проезжает этаж, необходимо обновить экран с номером текущего этажа в кабине; кроме того, лифт должен знать, на каком
    этаже находится кабина, чтобы правильно отвечать на новые вызовы и выборы этажей пассажирами. Иногда на этажах
    присутствует индикатор текущего местонахождения кабины лифта, иногда - нет.
</p>
<h4>
    <a id="Prefer reactive behavior to scheduled behavior." name="Prefer reactive behavior to scheduled behavior.">Предпочитайте прерывания опросу</a>
</h4>
<p>
    Опрос обходится дорого: часть системы должна периодически прекращать свою работу и проверять, не наступило ли событие.
    Если на событие необходимо отвечать быстро, то система должна проверять его наступление очень часто, еще более сокращая
    объем остальной работы, которая могла бы быть сделана.
</p>
<p>
    Гораздо эффективнее присвоить событию прерывание, которое будет активизировать связанный с событием код. Хотя
    использовать прерывания иногда избегают, поскольку они считаются "дорогостоящими", правильное их применение значительно
    эффективнее периодического опроса.
</p>
<p>
    Применение прерываний в качестве механизма уведомления о событиях оправдано в случаях, когда события поступают случайно
    и редко, так что большая часть усилий по проведению опроса пропадает впустую. Напротив, если события поступают
    регулярно и предсказуемо, то опрос предпочтительнее прерываний. В промежуточной ситуации опрос и прерывания примерно
    равноценны. В большинстве случаев, однако, учитывая случайность событий в реальном мире, предпочтительнее прерывания.
</p>
<h4>
    <a id="Prefer event notification to data broadcasting" name="Prefer event notification to data broadcasting">Предпочитайте уведомление о событиях оповещению путем рассылки
    данных</a>
</h4>
<p>
    Оповещение путем рассылки данных (обычно - с помощью сигналов) стоит дорого и, как правило, проходит впустую: лишь
    незначительное число объектов могут быть заинтересованы в данных, однако все (или большинство) вынуждены прерывать свою
    работу для их изучения. Менее ресурсозатратно применение уведомлений, позволяющее информировать только те объекты,
    которые заинтересованы в наступлении события. Ограничьте сферу оповещения только теми событиями, которые требуют
    внимания многих объектов (обычно это события, связанные с временем или синхронизацией).
</p>
<h4>
    <a id="Make heavy use of light-weight mechanisms and light use of heavy-weight mechanisms." name="Make heavy use of light-weight mechanisms and light use of heavy-weight mechanisms.">Старайтесь как можно чаще
    использовать простые механизмы и как можно реже - сложные</a>
</h4>
<p>
    Конкретно:
</p>
<ul>
    <li>
        Применяйте пассивные объекты и синхронные вызовы методов там, где не нужен параллелизм, но нужен мгновенный ответ.
    </li>
    <li>
        Применяйте активные объекты и асинхронные сообщения при обеспечении параллелизма на уровне приложений.
    </li>
    <li>
        Изолируйте блокирующие элементы с помощью нитей операционной системы. Активный объект можно отобразить в нить
        операционной системы.
    </li>
    <li>
        Для обеспечения максимальной изоляции пользуйтесь процессами операционной системы. Для независимого запуска и
        завершения работы программ, как и для потенциально распределенных подсистем, требуются отдельные процессы.
    </li>
    <li>
        Применяйте отдельные CPU для физического распределения или для простого повышения мощности.
    </li>
</ul>
<p>
    Наверное, наиболее важное указание по разработке эффективных параллельных приложений заключается в том, чтобы в
    максимальной степени использовать простые механизмы обеспечения параллелизма. И аппаратное обеспечение, и программное
    обеспечение операционной системы играют основную роль в поддержке параллелизма, но они предоставляют относительно
    сложные механизмы, оставляя много работы проектировщику приложения. Между имеющимися инструментами и потребностями
    параллельных приложений остается большой зазор.
</p>
<p>
    Активные объекты позволяют уменьшить этот зазор с помощью двух ключевых возможностей:
</p>
<ul>
    <li>
        Они унифицируют абстракции проектирования, инкапсулируя базовую единицу параллелизма (управляющую нить), которую
        можно реализовать с помощью любого из основных механизмов операционной системы или CPU.
    </li>
    <li>
        Когда активные объекты совместно используют отдельную нить операционной системы, они становятся очень эффективным,
        простым механизмом обеспечения параллелизма, который в противном случае пришлось бы реализовывать непосредственно в
        приложении.
    </li>
</ul>
<p>
    Активные объекты также создают идеальную среду для пассивных объектов, предоставляемых языками программирования.
    Проектирование системы на основе исключительно параллельных объектов, без процедурных артефактов, таких как программы и
    процессы, дает более модульные, связные и понятные конфигурации.
</p>
<h4>
    <a id="Eschew performance bigotry." name="Eschew performance bigotry.">Избегайте фанатизма при оптимизации кода</a>
</h4>
<p>
    В большинстве систем менее 10% кода используют более 90% времени CPU.
</p>
<p>
    Многие проектировщики систем стараются оптимизировать каждую строку кода. Лучше потратить время на оптимизацию той
    10%-ной части кода, которая выполняется чаще всего или дольше всего. При написании остальных 90% кода сделайте упор на
    понятность, модульность и простоту обслуживания и реализации.
</p>
<h3>
    <a id="Choosing Mechanisms" name="Choosing Mechanisms">Выбор механизмов</a>
</h3>
<p>
    Нефункциональные требования и архитектура системы повлияют на выбор механизмов реализации вызовов удаленных процедур.
    &nbsp;Ниже приведен обзор возможных компромиссов между имеющимися альтернативами. &nbsp;
</p>
<div align="center">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="85%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <th scope="col" width="20%">
                    Механизм
                </th>
                <th scope="col" width="26%">
                    Применение
                </th>
                <th scope="col" width="54%">
                    Комментарии
                </th>
            </tr>
            <tr>
                <td width="20%">
                    Сообщения
                </td>
                <td width="26%">
                    Асинхронный доступ к серверам предприятия
                </td>
                <td width="54%">
                    Промежуточное программное обеспечение службы сообщений может упростить выполнение задачи
                    программирования приложения за счет поддержки очередей, тайм-аутов и условий
                    восстановления/перезапуска. Промежуточное программное обеспечение службы сообщений можно использовать и
                    в псевдосинхронном режиме. Обычно технология службы сообщений позволяет поддерживать сообщения большого
                    размера. Некоторые подходы RPC могут ограничивать размеры сообщений - в таком случае потребуется
                    дополнительно запрограммировать поддержку больших сообщений.
                </td>
            </tr>
            <tr>
                <td width="20%">
                    JDBC/ODBC
                </td>
                <td width="26%">
                    Вызовы баз данных
                </td>
                <td width="54%">
                    Это не зависящие от баз данных интерфейсы сервлетов Java или прикладных программ, предназначенные для
                    вызова баз данных, которые могут находиться на том же или другом компьютере.
                </td>
            </tr>
            <tr>
                <td width="20%">
                    Стандартные интерфейсы
                </td>
                <td width="26%">
                    Вызовы баз данных
                </td>
                <td width="54%">
                    Многие вендоры баз данных реализовали стандартные интерфейсы прикладных программ для своих баз данных.
                    Эти интерфейсы дают выигрыш в производительности по сравнению с ODBC за счет отказа от переносимости
                    приложений.
                </td>
            </tr>
            <tr>
                <td width="20%">
                    Вызов удаленных процедур
                </td>
                <td width="26%">
                    Для вызова программ на удаленных серверах
                </td>
                <td width="54%">
                    Программировать на уровне RPC не нужно, если у вас есть компоновщик приложений, который сделает это за
                    вас.
                </td>
            </tr>
            <tr>
                <td width="20%">
                    Диалоговый
                </td>
                <td width="26%">
                    Редко применяется в приложениях электронного бизнеса
                </td>
                <td width="54%">
                    Обычно низкоуровневая связь между программами по протоколам типа APPC или Sockets.
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<h3>
    <a id="Summary" name="Summary">Итоги</a>
</h3>
<p>
    Многим системам требуются параллельное поведение и распределенные компоненты. Большинство языков программирования лишь
    в малой степени способно помочь нам в этих вопросах. Мы убедились, что нам необходимы хорошие абстракции, чтобы
    выяснить, насколько велика потребность в параллелизме в приложениях и насколько широки возможности по ее реализации в
    программном обеспечении. Мы также убедились, что хотя параллельное программное обеспечение устроено, естественно,
    сложнее обычного, оно, как ни парадоксально это звучит, позволяет значительно упростить конфигурацию систем, которые
    должны взаимодействовать в параллельном режиме с окружающим миром.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
