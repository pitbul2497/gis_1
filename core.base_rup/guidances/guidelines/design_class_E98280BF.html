<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Проектирование класса</title>
<meta content="Guideline" name="uma.type">
<meta content="design_class" name="uma.name">
<meta content="Проектирование класса" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.914882084937444E-305"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.914882084937444E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="2.914882084937444E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Проектирование класса</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Класс проектирования представляет элемент проектирования, преобразуемый непосредственно в код. В этой рекомендации объясняется, как разработать Класс проектирования.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_class_790117F2.html" guid="{1C78947B-33D4-49AF-9E1F-655E7D74C53F}">Класс пригодности к тестированию</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_class_B33BD5E5.html" guid="{952A9CE9-D5A3-43AC-980D-0B9298F3872E}">Проектирование класса</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Проектировщик</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_capsule_designer_F3E66EDF.html" guid="{86253FE7-0036-4D14-8BD7-C18CE86A5E14}">Проектировщик капсул</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_class__guidelines_for" name="XE_class__guidelines_for"></a> 
<h3>
    <a id="Explanation" name="Explanation">Определение</a>
</h3>
<p>
    <a id="XE_class__definition" name="XE_class__definition"></a><b>Класс проектирования</b> представляет абстракцию одного
    или нескольких классов в реализации системы; точный объект, которому он соответствует, зависит от языка реализации.
    Например, в объектно-ориентированном языке, таком как C++, класс проектирования может соответствовать простому классу.
    В языке Ада класс может соответствовать специальному типу, определенному в видимой части пакета.
</p>
<p>
    Классы определяют <b>объекты</b>, которые, в свою очередь, реализуют варианты использования. Класс основан на
    требованиях, предъявляемых реализациями вариантов использования объектам системы, а также на всех ранее разработанных
    моделях объектов.
</p>
<p>
    Успешность класса во многом зависит от среды реализации. Например, правильный размер класса и его объектов зависит от
    языка программирования. То, что кажется подходящим в языке Ада, может оказаться неудачным в Smalltalk. Классы должны
    отображаться в конкретный феномен в языке реализации, и структура классов должна быть такой, чтобы в результате
    отображения получался хороший код.
</p>
<p>
    Несмотря на то, что особенности языка реализации влияют на модель проектирования, вы должны следить за тем, чтобы
    структура класса была простой для понимания и модификации. Разрабатывать класс следует так, как если бы вы располагали
    классами и инкапсуляцией, пусть и не поддерживаемыми в языке реализации.
</p>
<h3>
    <a id="operations" name="operations">Операции</a>
</h3>
<p>
    Единственный способ, с помощью которого объекты могут получить доступ к атрибутам или взаимосвязям данного объекта или
    повлиять на них, - это воспользоваться его <b>операциями</b>. Операции объекта определяются его классом. Операции
    позволяют выполнять конкретное поведение, которое может повлиять на атрибуты и взаимосвязи объекта и вызвать выполнение
    других операций. Операция соответствует функции-члену в языке C++ и функции или процедуре в языке Ада. Поведение,
    которое вы присваиваете объекту, зависит от его роли в реализациях варианта использования.
</p>
<h4>
    <a id="parameters" name="parameters">Параметры</a>
</h4>
<p>
    В спецификации операции параметры - это <b>формальные параметры</b>. У каждого параметра есть имя и тип. Для указания
    операций и их параметров можно воспользоваться синтаксисом и семантикой языка реализации, так что эти операции и
    параметры уже будут указаны в языке реализации к моменту начала кодирования.
</p>
<p class="exampleheading">
    Пример:
</p>
<p class="example">
    В <b>системе машины для переработки вторсырья</b> объекты класса <b>Receipt Basis</b> следят за тем, сколько предметов
    определенного типа положил клиент. Поведение объекта <b>Receipt Basis</b> включает увеличение числа возвращенных
    объектов. Это действие выполняется операцией <b>insertItem</b>, получающей ссылку на положенный предмет.
</p>
<p class="picturecenter" align="center">
    <img height="44" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_clas3.gif" width="210" />
</p>
<p class="picturetext">
    При указании операций пользуйтесь синтаксисом и семантикой языка реализации.
</p>
<h4>
    <a id="XE_class__operations_on" name="XE_class__operations_on"></a><b><a id="Class Operations" name="Class Operations">Операции классов</a></b>
</h4>
<p>
    Операция почти всегда задает поведение объекта. Операция может также задавать поведение класса - в этом случае она
    называется <b>операцией класса</b>. Это можно смоделировать в UML, задав соответствующую область действия операции.
</p>
<h4>
    <a id="Operation Visibility" name="Operation Visibility">Область видимости операции</a>
</h4>
<p align="left">
    У операции могут быть следующие области видимости:
</p>
<ul>
    <li>
        <b>Общедоступная</b>: операцию видят все элементы модели, кроме самого класса.
    </li>
    <li>
        <b>Защищенная</b>: операцию видят только сам класс, его подклассы и его <b>друзья</b> (в разных языках могут быть
        разные названия)
    </li>
    <li>
        <b>Частная</b>: операцию видят только сам класс и его <b>друзья</b>
    </li>
    <li>
        <b>Реализационная</b>: операция видна только в пределах самого класса.
    </li>
</ul>
<p>
    <b>Общедоступную</b> область видимости следует применять <b>в исключительных случаях</b>, только когда операция
    необходима другому классу.
</p>
<p>
    <b>Защищенная</b> область видимости должна применяться <b>по умолчанию</b>; она защищает операцию от использования
    внешними классами, что способствует слабому связыванию и инкапсуляции поведения.
</p>
<p>
    <b>Частную</b> область видимости следует применять, когда вы хотите предотвратить наследование операции <b>производными
    классами</b>. Это позволяет отделить производные классы от базового и тратить меньше усилий на удаление или исключение
    неиспользуемых наследуемых операций.
</p>
<p>
    <b>Реализационная</b> область видимости <b>наиболее ограничительна</b>; она используется в случаях, когда операцию
    может применять только сам класс. Это <b>разновидность Частной области видимости</b>, вполне достаточной в большинстве
    случаев.
</p>
<h3>
    <a id="States" name="States">Состояния</a>
</h3>
<p>
    Объект может реагировать на сообщение по-разному, в зависимости от того, в каком состоянии он находится; поведение
    объекта в зависимости от состояния определяется на связанной диаграмме состояний. Для каждого возможного состояния
    объекта диаграмма состояний описывает, какие сообщения может принимать объект, какие операции будут выполнены и в какое
    состояние затем перейдет объект. Дополнительная информация приведена в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">Технология:
    диаграмма состояний</a>.
</p>
<h3>
    <a id="Interaction Between Objects" name="Interaction Between Objects">Кооперирования</a>
</h3>
<p>
    Кооперирование - это динамический набор взаимодействий объектов, в котором объекты обмениваются информацией путем
    отправки <b>сообщений</b> друг другу. Отправка сообщения выполняется непосредственно в Smalltalk и посредством вызова
    подпрограммы в Аде. Сообщение отправляется принимающему объекту, запускающему внутреннюю операцию. Сообщение указывает
    имя выполняемой операции и необходимые параметры. При отправке сообщений для всех <b>параметров</b> предоставляются
    <b>фактические параметры</b> (значения формальных <b>параметров</b>).
</p>
<p>
    Пересылки сообщений между объектами в реализации варианта использования переключение управления между объектами по мере
    запуска операций описаны на диаграммах взаимодействия. Информация об этих диаграммах приведена в разделах <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/sequence_diagram_AFA76EBB.html" guid="3.211008403369512E-306">Технология: диаграмма последовательности</a> и <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/communication_diagram_FFFEA1B5.html" guid="4.5194432001390347E-305">Технология: диаграмма связи</a>.
</p>
<h3>
    <a id="XE_class_attribute__definition" name="XE_class_attribute__definition"></a><a id="Attributes" name="Attributes"></a><a id="XE_attribute__definition_for" name="XE_attribute__definition_for">Атрибуты</a>
</h3>
<p>
    Атрибут - это именованное свойство объекта. Имя атрибута - это существительное, описывающее роль атрибута по отношению
    к объекту. У атрибута может быть начальное значение при создании объекта.
</p>
<p>
    Моделировать атрибуты следует только в том случае, если это упростит понимание объекта. Моделировать свойство объекта
    как атрибут следует лишь в том случае, если это свойство <b>только данного объекта</b>. В противном случае, вы должны
    смоделировать свойство с взаимосвязью ассоциации или агрегирования с классом, объекты которого представляют это
    свойство.
</p>
<p class="exampleheading">
    Пример:
</p>
<p class="picturecenter" align="center">
    <img height="63" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_clas4.gif" width="162" />
</p>
<p class="example">
    Пример моделирования атрибута. У каждого члена семьи есть имя и адрес. В данном примере задаются атрибуты <b>мое
    имя</b> и <b>домашний адрес</b>, относящиеся к типам <b>Имя</b> и <b>Адрес</b>, соответственно.
</p>
<p class="picturecenter" align="center">
    <img height="45" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_clas5.gif" width="308" />
</p>
<p class="example">
    В данном примере ассоциация применяется вместо атрибута. Свойство <b>мое имя</b>, скорее всего, уникально у каждого
    члена семьи. Следовательно, его можно смоделировать как атрибут типа <b>Имя</b>. Адрес, напротив, является общим у всех
    членов семьи, поэтому его лучше всего моделировать с помощью ассоциации между классами <b>Член семьи</b> и
    <b>Адрес</b>.
</p>
<p>
    Не всегда просто сразу решить, следует ли моделировать концепцию как отдельный объект или как атрибут другого объекта.
    Добавление ненужных объектов в модель перегружает документацию и повышает объем работы. По этой причине, вы должны
    установить критерии, позволяющие определять важность концепции для системы.
</p>
<ul>
    <li>
        <b>Готовность</b>. Выбор между объектом и атрибутом определяется не важностью концепции в реальной жизни, а
        необходимостью доступа к ней во время выполнения варианта использования. Если доступ к элементу происходит часто,
        смоделируйте его как объект.
    </li>
    <li>
        <b>Изолированность во время выполнения</b>. Когда варианты использования выполняются как объекты, концепции модели
        обрабатываются раздельно.
    </li>
    <li>
        <b>Связи с другими концепциями</b>. Концепции модели тесно связаны с некоторыми другими концепциями и никогда не
        используются отдельно, но всегда опосредованно через объект, как атрибут объекта.
    </li>
    <li>
        <b>Требования со стороны взаимосвязей</b>. Если, по какой-либо причине, вы должны установить взаимосвязи с
        элементом с двух направлений, то проверьте его еще раз, чтобы выяснить, должен ли он быть отдельным объектом. Два
        объекта не могут связывать один и тот же экземпляр типа атрибута.
    </li>
    <li>
        <b>Частота появления</b>. Если элемент существует только во время выполнения варианта использования, не моделируйте
        его как объект. Смоделируйте его как атрибут объекта, выполняющий нужное поведение, или просто укажите его в
        описании соответствующего объекта.
    </li>
    <li>
        <b>Сложность</b>. Если объект становится слишком сложным из-за его атрибутов, перенесите часть атрибутов в другие
        объекты. Следите, однако, за тем, чтобы таких объектов не стало слишком много. С другой стороны, элементы могут
        быть очень простыми. Например, к разряду атрибутов относятся 1) элементы, достаточно простые, чтобы поддерживаться
        непосредственно простейшими типами в языке реализации, например, целые числа в C++, и 2) элементы, достаточно
        простые, чтобы реализовываться с помощью не зависящих от приложений компонентов среды реализации, например,
        <b>String</b> в C++ и Smalltalk-80.
    </li>
</ul>
<p>
    В разных системах концепция может моделироваться по-разному. В одной системе концепция может быть столь важной, что ее
    лучше моделировать как объект. В другой она может играть второстепенную роль, и ее лучше моделировать как атрибут
    объекта.
</p>
<p class="exampleheading">
    Пример:
</p>
<p class="example">
    Например, система, предназначенная для авиационной компании, должна поддерживать вылеты.
</p>
<p class="picturecenter" align="center">
    <img height="75" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_clas6.gif" width="146" />
</p>
<p class="picturetext">
    Система, поддерживающая вылеты. Пусть персоналу аэропорта требуется система, поддерживающая вылеты. Для каждого вылета
    необходимо определить время вылета, рейс и место назначения. Это можно смоделировать как объект класса <b>Вылет</b> с
    атрибутами <b>время вылета</b>, <b>рейс</b> и <b>место назначения</b>.
</p>
<p class="example">
    Если же система разработана для туристического агентства, то ситуация может быть несколько иной.
</p>
<p class="picturecenter" align="center">
    <img height="65" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_clas7.gif" width="391" />
</p>
<p class="picturetext">
    Места назначения рейсов образуют свой собственный объект - <b>Место назначения</b>.
</p>
<p class="example">
    Время вылета, рейс и место назначения, естественно, по-прежнему будут необходимы. Однако требования будут другими,
    поскольку турагентство интересует вылет в заданное место назначения. Следовательно, необходимо создать отдельный объект
    для <b>Места назначения</b>. Объекты <b>Вылет</b> и <b>Место назначения</b>, разумеется, должны быть осведомлены друг о
    друге, для чего между их классами создается ассоциация.
</p>
<p>
    При выборе атрибутов, которые должны быть определены в классе, следует учитывать важность тех или иных концепций.
    Атрибуты класса <b>Автомобиль</b>, без сомнения, будут различными в зависимости от того, являются его объекты частью
    системы регистрации транспортных средств или системы завода по производству автомобилей.
</p>
<p>
    Наконец, правила, определяющие, что следует представлять как объекты, а что - как атрибуты, неабсолютны. Теоретически
    все можно моделировать как объекты, но это слишком обременительно. Простое правило заключается в том, чтобы
    рассматривать объект как нечто, что на определенном этапе используется безотносительно других объектов. Кроме того,
    необязательно моделировать каждое свойство объекта с помощью атрибута - достаточно моделировать лишь те свойства,
    которые необходимы для понимания объекта. Не нужно моделировать детали, слишком тесно связанные с реализацией: их лучше
    оставить разработчику.
</p>
<h4>
    <a id="XE_attribute__class,_definition_for" name="XE_attribute__class,_definition_for"></a><a id="Class_Attributes" name="Class_Attributes"></a>Атрибуты класса
</h4>
<p>
    Атрибут почти всегда задает свойства объекта. Атрибут может также задавать свойства класса - в этом случае он
    называется <b>атрибутом класса</b>. Это можно смоделировать в UML, задав соответствующую область действия атрибута.
</p>
<h4>
    <a id="XE_external_units__modeling_with_attributes" name="XE_external_units__modeling_with_attributes"></a><a id="Modeling_External" name="Modeling_External"></a><a id="XE_attribute__modeling_external_units_with" name="XE_attribute__modeling_external_units_with">Моделирование внешних элементов с атрибутами</a>
</h4>
<p>
    Объект может инкапсулировать элемент, значение которого может изменяться независимо от поведения объекта. Это может
    быть нечто, являющееся на самом деле внешним элементом, но не смоделированное как субъект. Например, пусть границы
    системы выбраны так, что в их пределы попадает оборудование датчика. Датчик можно затем инкапсулировать в объекте, так
    чтобы измеряемое им значение образовывало атрибут. После этого это значение может изменяться непрерывно или
    периодически независимо от того, влияет ли на данный объект какой-либо другой объект в системе.
</p>
<p class="exampleheading">
    Пример:
</p>
<p class="example">
    Термометр можно смоделировать как объект; у объекта будет атрибут, соответствующий температуре, и его значение будет
    изменяться в ответ на изменение температуры окружающей среды. Другие объекты могут запрашивать текущую температуру,
    выполняя операцию над объектом термометра.
</p>
<p class="picturecenter" align="center">
    <img height="45" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_clas8.gif" width="153" />
</p>
<p class="picturetext">
    Значение атрибута <b>температура</b> изменяется спонтанно в объекте <b>Термометр</b>.
</p>
<p>
    Вы по-прежнему можете смоделировать инкапсулированное значение, изменяющееся таким образом, в виде обычного атрибута,
    однако вы должны указать в классе объекта, что оно изменяется <b>спонтанно</b>.
</p>
<h4>
    <a id="Attribute Visibility" name="Attribute Visibility">Область видимости атрибута</a>
</h4>
<p>
    У атрибута могут быть следующие области видимости:
</p>
<ul>
    <li>
        <b>Общедоступная</b>: атрибут видят и изнутри, и снаружи пакета, содержащего класс.
    </li>
    <li>
        <b>Защищенная</b>: атрибут видят только сам класс, его подклассы и его <b>друзья</b> (в разных языках могут быть
        разные названия)
    </li>
    <li>
        <b>Частная</b>: атрибут видят только сам класс и его <b>друзья</b>
    </li>
    <li>
        <b>Реализационная</b>: атрибут видит только сам класс.
    </li>
</ul>
<p>
    <b>Общедоступную</b> область видимости следует применять <b>в исключительных случаях</b>, только когда атрибут напрямую
    доступен другому классу. Определение общедоступной области видимости - это, фактически, краткая запись для определения
    области видимости атрибута как защищенной, частной или реализационной с соответствующими общедоступными операциями по
    извлечению и заданию значения атрибута. Общедоступная область видимости атрибута может использоваться в качестве
    объявления, указывающего генератору кода, что эти операции извлечения и задания должны генерироваться автоматически для
    экономии времени при определении класса.
</p>
<p>
    <b>Защищенная</b> область видимости должна применяться <b>по умолчанию</b>; она защищает атрибут от использования
    внешними классами, что способствует слабому связыванию и инкапсуляции поведения.
</p>
<p>
    <b>Частную</b> область видимости следует применять, когда вы хотите предотвратить наследование атрибута <b>производными
    классами</b>. Это позволяет отделить производные классы от базового и тратить меньше усилий на удаление или исключение
    неиспользуемых наследуемых атрибутов.
</p>
<p>
    <b>Реализационная</b> область видимости <b>наиболее ограничительна</b>; она используется в случаях, когда атрибут может
    применяться только самим классом. Это <b>разновидность Частной области видимости</b>, вполне достаточной в большинстве
    случаев.
</p>
<h3>
    <a id="Internal Structure" name="Internal Structure">Внутренняя структура</a>
</h3>
<p>
    Некоторые классы могут представлять сложные абстракции и имеют сложную структуру. Во время моделирования класса
    проектировщик может представить его внутренние участвующие элементы и их взаимосвязи, чтобы убедиться, что реализатор
    правильно реализует кооперирования в этом классе.
</p>
<p>
    В UML 2.0 классы определяются как <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/structured_class_4BB99B12.html" guid="_yW3E4NnmEdmO6L4XMImrsA">структурированные классы</a>, которые могут иметь внутреннюю структуру и порты. Классы
    могут быть разложены в наборы соединенных частей, также допускающие разложение. Класс может быть инкапсулирован
    посредством передачи связи от внешних источников к портам удаленного подключения, подчиняющимся объявленным
    интерфейсам.
</p>
<p>
    Таким образом, помимо применения диаграмм классов для представления взаимосвязей классов (например, ассоциаций,
    композиций и агрегирований) и атрибутов, проектировщик может воспользоваться составной структурной диаграммой. Эта
    диаграмма позволяет разработчику продемонстрировать, каким образом экземпляры внутренних частей играют свои роли в
    экземпляре заданного класса.
</p>
<p>
    Дополнительная информация по этой теме и примеры диаграмм составных структур приведены в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">Концепция: структурированный класс</a>.
</p></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
