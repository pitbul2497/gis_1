<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Проектирование пакета</title>
<meta content="Guideline" name="uma.type">
<meta content="design_package" name="uma.name">
<meta content="Проектирование пакета" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "3.3691722315666536E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="3.3691722315666536E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Проектирование пакета</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Пакет проектирования - это конструкция, позволяющая разбить модель проектирования на разделы. В этой рекомендации объясняется, как определять и задавать Пакеты проектирования.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_package_8376BC8E.html" guid="{80CC5437-F481-487B-A69B-957D9D236D8D}">Проектирование пакета</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Проектировщик</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_capsule_designer_F3E66EDF.html" guid="{86253FE7-0036-4D14-8BD7-C18CE86A5E14}">Проектировщик капсул</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_design_package__guidelines_for" name="XE_design_package__guidelines_for"></a> 
<h3>
    <a id="Introduction" name="Introduction">Введение</a>
</h3>
<p>
    <a id="XE_design_subsystem__packages_vs._subsystems" name="XE_design_subsystem__packages_vs._subsystems"></a><a id="XE_design_package__subsystems_vs._packages" name="XE_design_package__subsystems_vs._packages"></a>Для упрощения
    модели проектирования ее можно разбить на блоки. Сгруппировав элементы Модели проектирования по пакетам и подсистемам и
    затем указав, как они связаны друг с другом, вы сделаете общую структуру модели проще для понимания. Учтите, что <b><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_subsystem_AB08ECC8.html" guid="_yGBMgNnmEdmO6L4XMImrsA">подсистема проектирования</a></b> моделируется как компонент, реализующий один или
    несколько интерфейсов; дополнительная информация приведена в разделах <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html" guid="{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}">Рабочий продукт: подсистема проектирования</a> и <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html" guid="1.2314266786534317E-305">Рекомендация по рабочему продукту: подсистема проектирования</a>. Пакеты проектирования,
    напротив, предназначены исключительно для группировки.
</p>
<h3>
    <a id="XE_visibility__of_content_in_package" name="XE_visibility__of_content_in_package"></a><a id="XE_design_package__describing_how_packages_depend_on_each_other" name="XE_design_package__describing_how_packages_depend_on_each_other"></a><a id="Package Content Visibility" name="Package Content Visibility">Область видимости содержимого пакета</a>
</h3>
<p>
    Класс, содержащийся в пакете, может быть общедоступным или частным. <a id="XE_public_class__in_package" name="XE_public_class__in_package"></a><b>Общедоступный класс</b> можно связать с любым другим классом. <a id="XE_private_class__in_package" name="XE_private_class__in_package"></a><b>Частный класс</b> можно связать только с
    классами, содержащимися в пакете.
</p>
<p>
    Интерфейс пакета состоит из общедоступных классов пакета. Интерфейс пакета (общедоступные классы) изолирует и реализует
    зависимости от других пакетов. Это позволяет упростить параллельную разработку, поскольку вы можете сравнительно рано
    установить интерфейсы, а разработчикам достаточно знать только об изменениях в интерфейсах других пакетов.
</p>
<h3>
    <a id="XE_design_package__package_partitioning_criteria" name="XE_design_package__package_partitioning_criteria"></a><a id="Package-Partitioning Criteria" name="Package-Partitioning Criteria">Критерии разбиения пакетов на разделы</a>
</h3>
<p>
    Существуют различные причины для разбиения Модели проектирования на разделы:
</p>
<ul>
    <li>
        Пакеты и подсистемы можно использовать в качестве единиц заказа, конфигурации или доставки по окончании разработки
        системы.
    </li>
    <li>
        Выделение ресурсов и уровень компетентности различных коллективов разработки могут потребовать разделения проекта
        между различными группами, находящимися в различных местах. Подсистемы, с их определенными интерфейсами, позволяют
        координированно разделить задание между группами, обеспечив параллельное проектирование и реализацию.
    </li>
    <li>
        Подсистемы позволяют структурировать модель проектирования с учетом пользовательских типов. Многие требования об
        изменениях поступают от пользователей; подсистемы гарантируют, что изменения от конкретного пользовательского типа
        повлияют только на те части системы, которые соответствуют этому пользовательскому типу.
    </li>
    <li>
        В некоторых приложениях определенная информация должна быть доступна только узкому кругу лиц. Подсистемы позволяют
        сохранить секретность там, где она необходима.
    </li>
    <li>
        Если вы создаете систему поддержки, то с помощью подсистем и пакетов вы можете придать ей структуру, схожую со
        структурой поддерживаемой системы. Это позволит синхронизировать обслуживание этих двух систем.
    </li>
    <li>
        <a id="XE_existing_product__representing_with_packages" name="XE_existing_product__representing_with_packages"></a>Подсистемы служат для представления существующих
        продуктов и служб, используемых системой (например, продуктов COTS и библиотек), как разъясняется в нескольких
        следующих разделах.
    </li>
</ul>
<h4>
    <a id="XE_boundary_class__packaging" name="XE_boundary_class__packaging"></a><a id="Packaging Boundary Classes" name="Packaging Boundary Classes">Упаковка пограничных классов</a>
</h4>
<p>
    Когда пограничные классы распределяются по пакетам, существуют две стратегии, которые применимы в этом случае; какую из
    них выбрать, зависит от того, предполагается ли вносить значительные изменения в системные интерфейсы в будущем.
</p>
<ul>
    <li>
        Если системный интерфейс, скорее всего, будет заменен или претерпит серьезные изменения, то интерфейс следует
        отделить от остальной модели проектирования. Изменение пользовательского интерфейса повлияет только на эти пакеты.
        Примером такого серьезного изменения может служить переключение с интерфейса, ориентированного на линию, на
        интерфейс, ориентированный на окна.
    </li>
</ul>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp2.gif" width="234" height="148" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Если главная цель - упростить внесение изменений в интерфейс, то пограничные классы следует поместить в один (или
    несколько) отдельных пакетов.
</p>
<ul>
    <li>
        Если вносить серьезные изменения в интерфейс не планируется, то во главу угла следует поставить изменения в
        системных службах, а не в интерфейсе. Пограничные классы следует упаковать вместе с сущностными и управляющими
        классами, с которыми они функционально связаны. Это позволит легко выяснить, какие пограничные классы будут
        затронуты при изменении какого-либо сущностного или управляющего класса.
    </li>
</ul>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp3.gif" width="257" height="71" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Для того чтобы упростить изменение системных служб, пограничные классы упаковываются вместе с классами, с которыми они
    функционально связаны.
</p>
<p>
    Обязательные пограничные классы, не связанные функционально ни с какими сущностными и управляющими классами, следует
    поместить в отдельные пакеты, вместе с другими пограничными классами из того же интерфейса.
</p>
<p>
    Если пограничный класс связан с необязательной службой, разместите его вместе с остальными классами, обеспечивающими
    работу этой службы, в отдельной подсистеме. Подсистема будет отображена в необязательный компонент, который будет
    предоставляться в случае заказа этой необязательной функциональности.
</p>
<h4>
    <a id="XE_design_package__functionally_related_classes?_finding_packages_for" name="XE_design_package__functionally_related_classes?_finding_packages_for"></a><a id="Packaging Functionally Related Classes" name="Packaging Functionally Related Classes">Упаковка функционально
    связанных классов</a>
</h4>
<p>
    Для каждой группы функционально связанных классов необходим отдельный пакет. Существует несколько практических
    критериев, позволяющих определить, связаны ли функционально два класса. Они перечислены ниже, в порядке убывания
    важности:
</p>
<ul>
    <li>
        Если изменения в поведении или структуре одного класса вынуждают изменения в другом классе, то эти два класса
        функционально связаны.
    </li>
</ul>
<blockquote>
    <p class="exampleheading">
        Пример
    </p>
    <p class="example">
        При добавлении нового атрибута в сущностный класс <b>Заказ</b>, скорее всего, потребуется обновить управляющий
        класс <b>Администратор заказов</b>. Таким образом, эти классы входят в один пакет - <b>Обработка заказов</b>.
    </p>
</blockquote>
<ul>
    <li>
        Выяснить, связан ли функционально один класс с другим, можно, удалив класс - например, сущностный класс - из
        системы и изучив последствия удаления. Все классы, которые станут лишними в результате удаления данного класса,
        связаны с ним так или иначе. Под "лишним" понимается класс, используемый только данным удаленным классом или
        зависящий от него.
    </li>
</ul>
<blockquote>
    <p class="exampleheading">
        Пример
    </p>
    <p class="example">
        Пакет <b>Обработка заказов</b> содержит два управляющих класса <b>Администратор заказов</b> и <b>Регистратор
        заказов</b> и находится в <b>Системе управления складом</b>. Оба управляющих класса моделируют службы обработки
        заказов на складе. Все атрибуты и взаимосвязи заказа хранятся в сущностном классе <b>Заказ</b>, предназначенном
        исключительно для обработки заказов. В случае удаления сущностного класса <b>Заказ</b> классы <b>Администратор
        заказов</b> и <b>Регистратор заказов</b> станут не нужны, поскольку они полезны только при наличии этого класса.
        Следовательно, сущностный класс <b>Заказ</b> следует включить в один пакет с этими двумя управляющими классами.
    </p>
</blockquote>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp4.gif" width="393" height="163" alt="Диаграмма, описанная в тексте." />
</p>
<blockquote>
    <p class="picturetext" align="center">
        <b>Администратор заказов</b> и <b>Регистратор заказов</b> принадлежат тому же пакету, что и <b>Заказ</b>, поскольку
        они станут лишними при удалении класса <b>Заказ</b> из системы.
    </p>
</blockquote>
<ul>
    <li>
        Два объекта могут быть функционально связаны, если они интенсивно обмениваются сообщениями или еще каким-либо
        образом взаимодействуют друг с другом.
    </li>
</ul>
<blockquote>
    <p class="example">
        <b>Пример</b>
    </p>
    <p class="example">
        Управляющий класс <b>Исполнитель задач</b> отправляет и принимает много сообщений от <b>Интерфейса
        транспортера</b>. Это другой признак того, что их нужно включить в один пакет, <b>Обработка задач</b>.
    </p>
</blockquote>
<ul>
    <li>
        Пограничный класс может быть функционально связан с конкретным сущностным классом, если функция пограничного класса
        представляет сущностный класс.
    </li>
</ul>
<blockquote>
    <p class="example">
        <b>Пример</b>
    </p>
    <p class="example">
        Пограничный класс <b>Форма поддона</b> в <b>Системе управления складом</b> представляет экземпляр сущностного
        класса <b>Поддон</b> для пользователя. Каждый <b>Поддон</b> представлен идентификационным номером на экране. В
        случае изменения информации о <b>Поддоне</b>, например, если <b>Поддону</b> присваивается еще и имя, может
        потребоваться изменить и пограничный класс. Таким образом, <b>Форма поддона</b> должна быть включена в тот же
        пакет, что и <b>Поддон</b>.
    </p>
</blockquote>
<ul>
    <li>
        Два класса могут быть функционально связаны, если они взаимодействуют с одним и тем же субъектом или на них влияют
        изменения в субъекте. Если у двух классов нет общего субъекта, то они не должны находиться в одном пакете.
        Разумеется, при наличии серьезных контрдоводов последнее правило можно нарушать.
    </li>
</ul>
<blockquote>
    <p class="example">
        <b>Пример</b>
    </p>
    <p class="example">
        В <b>Системе управления складом</b> есть пакет <b>Обработка задач</b>, включающий, помимо прочего, управляющий
        класс <b>Исполнитель задач</b>. Это единственный пакет, связанный с субъектом <b>Транспортер</b> - физическим
        транспортером поддонов на складе. Субъект взаимодействует с управляющим классом <b>Исполнитель задач</b> через
        пограничный класс <b>Интерфейс транспортера</b>. Таким образом, этот пограничный класс должен быть включен в пакет
        <b>Обработка задач</b>.
    </p>
    <p class="example" align="center">
        <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp5.gif" width="470" height="163" alt="Диаграмма, описанная в тексте." />
    </p>
    <p class="picturetext">
        <b>Интерфейс транспортера</b> и <b>Исполнитель задач</b> входят в один пакет, поскольку на них обоих влияют
        изменения в субъекте <b>Транспортер</b>.
    </p>
</blockquote>
<ul>
    <li>
        Два класса могут быть функционально связаны, если у них есть взаимосвязи друг с другом (ассоциации, агрегирования и
        т.п.). Разумеется, данный критерий нельзя применять автоматически, но он может пригодиться, если все остальные
        критерии не подходят.
    </li>
    <li>
        Класс может быть функционально связан с классом, создающим его экземпляры.
    </li>
</ul>
<p>
    Следующие два критерия позволяют выяснить, когда два класса <b>не</b> следует помещать в один пакет:
</p>
<ul>
    <li>
        Два класса, связанные с разными субъектами, не следует помещать в один пакет.
    </li>
    <li>
        Необязательный и обязательный классы не следует помещать в один пакет.
    </li>
</ul>
<h3>
    <a id="Evaluating Package Cohesion" name="Evaluating Package Cohesion">Оценка уровня сцепленности пакета</a>
</h3>
<p>
    Прежде всего, все элементы в пакете должны быть одинаковой степени обязательности: в обязательном пакете не должно быть
    необязательных элементов модели.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    Одним из атрибутов обязательного сущностного класса <b>Тип изделия</b> является <b>Порог пополнения запаса</b>. Функция
    пополнения запаса, однако, необязательна в системе. По этой причине, класс <b>Изделие</b> следует разбить на два
    сущностных класса, и необязательный класс должен быть связан с обязательным.
</p>
<p>
    Пакет, считающийся обязательным, не может зависеть от необязательного пакета.
</p>
<p>
    Как правило, один пакет не может использоваться двумя различными субъектами. Причина в том, что изменение в поведении
    одного субъекта не должно влиять на другие субъекты. В этом правиле есть исключения, например, для пакетов, образующих
    необязательные службы. Пакеты этого типа не должны разбиваться, независимо от числа использующих их субъектов. Из
    сказанного следует, что вы должны разбить все пакеты и классы, используемые несколькими субъектами, за исключением
    необязательных пакетов.
</p>
<p>
    Все классы в одном пакете должны быть функционально связаны. Если вы следовали критериям из раздела "Найти пакеты из
    функционально связанных классов", то классы в одном пакете будут функционально связаны друг с другом. Однако конкретный
    класс может содержать "слишком много" поведения, либо взаимосвязи, не принадлежащие ему. В этом случае часть класса
    следует удалить, превратив ее в новый класс или перенеся ее в другой класс, возможно из другого пакета.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    Поведение управляющего класса <b>A</b> из одного пакета не должно слишком сильно зависеть от класса <b>B</b> из другого
    пакета. Для того чтобы изолировать поведение, обусловленное классом <b>B</b>, необходимо разбить управляющий класс
    <b>A</b> на два управляющих класса - <b>A'</b> и <b>A"</b>. Поведение, обусловленное классом <b>B</b>, помещается в
    новый управляющий класс <b>A"</b>, который заносится в тот же пакет, что и класс <b>B</b>. Новый класс <b>A"</b> также
    получает взаимосвязь, например обобщение, с исходным объектом <b>A'</b>.
</p>
<p class="example" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp6.gif" width="316" height="206" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Для того чтобы изолировать поведение, обусловленное классом <b>B</b>, неоднородный управляющий класс <b>A</b>
    разбивается на два управляющих класса - <b>A'</b> и <b>A"</b>.
</p>
<h3>
    <a id="Describing Packages Dependendencies" name="Describing Packages Dependendencies">Описание зависимостей
    пакетов</a>
</h3>
<p>
    Если у класса в одном пакете есть ассоциация с классом в другом пакете, то эти пакеты зависят друг от друга.
    Зависимости пакетов моделируются с помощью взаимосвязи зависимости между пакетами. Взаимосвязи зависимости помогают
    оценить последовательность изменений: пакет, от которого зависит много пакетов, труднее изменить, чем пакет, от
    которого не зависит ни один пакет.
</p>
<p>
    Так как во время спецификации пакетов будут обнаружены несколько зависимостей, подобных описанным, эти взаимосвязи
    будут вынуждены изменяться во время работы. Описание взаимосвязи зависимости может содержать информацию о взаимосвязях
    классов, послуживших причиной появления зависимости. Поскольку при этом появляется информация, которую трудно
    обслуживать, это следует делать, только если эта информация ценная и имеет отношение к делу.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    В <b>Системе управления складом</b> есть взаимосвязь зависимости, ведущая от пакета <b>Обработка заказов</b> к пакету
    <b>Обработка предметов</b>. Эта ассоциация появляется, поскольку у сущностного класса <b>Заказ</b> в <b>Обработке
    заказов</b> есть ассоциация с сущностным классом <b>Тип предмета</b> в другом пакете.
</p>
<p class="example" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp7.gif" width="264" height="256" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Пакет <b>Обработка заказов</b> зависит от пакета <b>Обработка предметов</b>, поскольку между двумя классами из этих
    пакетов существует ассоциация.
</p>
<h3>
    <a id="Evaluating Package Coupling" name="Evaluating Package Coupling">Оценка связывания пакетов</a>
</h3>
<p>
    Связывание пакетов - это и хорошо, и плохо: хорошо, поскольку связывание представляет повторное использование, а плохо
    - поскольку связывание представляет зависимости, усложняющие эволюцию системы. Ниже перечислены некоторые общие
    принципы:
</p>
<ul>
    <li>
        Пакеты не должны быть перекрестно связанными (т.е. взаимозависимыми); например, два пакета не должны зависеть друг
        от друга.
    </li>
</ul>
<blockquote>
    <p align="center">
        <img src="./../../../core.base_rup/guidances/guidelines/resources/md_dpkg1.gif" width="300" height="109" alt="Диаграмма, описанная в сопроводительном тексте." />
    </p>
    <p class="picturetext">
        В этих случаях необходимо реорганизовать пакеты, удалив перекрестные зависимости.
    </p>
</blockquote>
<ul>
    <li>
        Пакеты нижних уровней не должны зависеть от пакетов верхних уровней. Пакеты должны зависеть только от пакетов того
        же и следующего нижнего уровня.
    </li>
</ul>
<blockquote>
    <p align="center">
        <img src="./../../../core.base_rup/guidances/guidelines/resources/md_dpkg2.gif" width="200" height="239" alt="Диаграмма, описанная в сопроводительном тексте." />
    </p>
    <p class="picturetext">
        В таких случаях необходимо заново организовать функциональность. Например, можно выразить зависимости в терминах
        интерфейсов и организовать интерфейсы на нижнем уровне.
    </p>
</blockquote>
<ul>
    <li>
        В целом, зависимости не должны перескакивать через уровни, кроме случаев, когда зависимое поведение является общим
        для всех уровней и альтернативой является простой вызов операции удаленного подключения на всех уровнях.
    </li>
    <li>
        Пакеты не должны зависеть от подсистем, а лишь от других пакетов или интерфейсов.
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
