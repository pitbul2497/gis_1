<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Проектирование подсистемы</title>
<meta content="Guideline" name="uma.type">
<meta content="design_subsystem" name="uma.name">
<meta content="Проектирование подсистемы" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.2314266786534317E-305"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.2314266786534317E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="1.2314266786534317E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Проектирование подсистемы</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Подсистема проектирования реализует концепцию Компонента программного обеспечения. В этой рекомендации объясняется, как определять и задавать Подсистемы проектирования.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html" guid="{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}">Проектирование подсистемы</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Проектировщик</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_capsule_designer_F3E66EDF.html" guid="{86253FE7-0036-4D14-8BD7-C18CE86A5E14}">Проектировщик капсул</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_layering__layering_guidelines_for_design_subsystems" name="XE_layering__layering_guidelines_for_design_subsystems"></a><a id="XE_design_subsystem__guidelines_for" name="XE_design_subsystem__guidelines_for"></a> 
<h3>
    <a id="XE_design_subsystem__partitioning_patterns" name="XE_design_subsystem__partitioning_patterns"></a><a id="Subsystem Usage" name="Subsystem Usage">Работа с подсистемой</a>
</h3>
<p>
    <a id="XE_layering__partitioning_patterns" name="XE_layering__partitioning_patterns"></a>Подсистемы могут применяться
    различными взаимно дополняющими способами, чтобы разбить систему на структуры, которые
</p>
<ul>
    <li>
        можно независимо заказывать, настраивать или доставлять
    </li>
    <li>
        можно независимо разрабатывать, пока интерфейсы остаются без изменений
    </li>
    <li>
        можно независимо развертывать в наборе распределенных вычислительных узлов
    </li>
    <li>
        можно независимо изменять без ущерба для других частей системы
    </li>
</ul>
<p>
    Таким образом, подсистемы идеальны для моделирования компонентов - сменных блоков, предназначенных для сборки во время
    разработки на базе компонентов, - которые являются более крупными структурами по сравнению с обычным классом
    проектирования.
</p>
<p>
    Кроме того, подсистемы могут
</p>
<ul>
    <li>
        разбивать систему на структуры, которые могут обеспечить защиту важнейших ресурсов
    </li>
    <li>
        представлять существующие продукты или внешние системы в проектировании.
    </li>
</ul>
<h3>
    <a id="XE_design_subsystem__identifying_subsystems" name="XE_design_subsystem__identifying_subsystems"></a><a id="Identifying Subsystems" name="Identifying Subsystems">Определение подсистем</a>
</h3>
<p>
    Сложный класс анализа отображается в подсистему проектирования, если он осуществляет поведение, за которое не может
    отвечать один класс проектирования, действующий в одиночку. Сложный класс проектирования также может стать подсистемой,
    если его предполагается реализовать в виде набора совместно работающих классов.
</p>
<p>
    Подсистемы также являются хорошим средством определения частей системы, которые должны разрабатываться независимо
    отдельным коллективом. Если элементы проектирования, используемые в совместной работе, могут целиком содержаться в
    пакете вместе со своими кооперированиями, то подсистема может предоставить более сильную форму инкапсуляции по
    сравнению с той, что предоставляется простым пакетом. Содержимое и кооперирования в подсистеме полностью изолированы за
    одним или несколькими интерфейсами, так что клиент подсистемы зависит только от интерфейса. Проектировщик подсистемы,
    таким образом, полностью изолирован от внешних зависимостей; проектировщик (или команда проектировщиков) должен указать
    способ реализации интерфейса, однако он может как угодно изменять внутренний макет подсистемы, не затрагивая при этом
    внешние зависимости. В крупных системах с коллективами, в значительной степени независимыми, такой уровень
    самостоятельности, в сочетании с архитектурными требованиями, устанавливаемыми формальными интерфейсами, служит
    убедительным доводом, чтобы предпочесть подсистемы простым пакетам.
</p>
<p>
    Подсистема проектирования служит для инкапсуляции этих кооперирований таким образом, что клиентам подсистемы не
    требуется ничего знать о внутреннем устройстве подсистемы, даже если они применяют предоставляемые ей службы. Если
    участвующие в совместной работе классы или подсистемы взаимодействуют только друг с другом, чтобы создать заданный
    набор результатов, то совместную работу вместе с ее элементами проектирования следует инкапсулировать в подсистеме.
</p>
<p>
    Это правило применимо и к подмножествам кооперирований. В любом месте системы можно инкапсулировать и упростить
    кооперирование или его часть - это сделает проектирование проще для понимания.
</p>
<h4>
    Советы
</h4>
<div align="center">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="85%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <th id="row0" scope="col" width="35%">
                    <blockquote>
                        <p class="tableheading" align="center">
                            Совет
                        </p>
                    </blockquote>
                </th>
                <td scope="col" headers="row0" width="65%">
                    <p class="tableheading" align="center">
                        Сведения
                    </p>
                </td>
            </tr>
            <tr>
                <th id="row1" width="35%">
                    Стремитесь к оптимальности
                </th>
                <td headers="row1" width="60%">
                    Если конкретное кооперирование (или субкооперирование) представляет необязательное поведение, заключите
                    его в подсистему. Функции, которые можно удалять, обновлять или заменять на альтернативные, следует
                    считать независимыми.
                </td>
            </tr>
            <tr>
                <th id="row2" width="35%" rowspan="2">
                    Учитывайте пользовательский интерфейс системы.
                </th>
                <td headers="row2" width="60%">
                    Если пользовательский интерфейс сравнительно независим от сущностных классов системы (например, они
                    могут изменяться и изменяются независимо друг от друга), создайте подсистемы, интегрированные
                    горизонтально: объедините связанные пограничные классы пользовательского интерфейса в подсистему, а
                    связанные сущностные классы - в другую подсистему.
                </td>
            </tr>
            <tr>
                <td headers="row2" width="65%">
                    Если пользовательский интерфейс и отображаемые им сущностные классы тесно связаны (например, изменение
                    в одном вызывает изменение в другом), создайте подсистемы, интегрированные вертикально: заключите
                    связанные пограничные и сущностные классы в общую подсистему.
                </td>
            </tr>
            <tr>
                <th id="row3" width="35%" rowspan="2">
                    Учитывайте субъекты
                </th>
                <td headers="row3" width="65%">
                    Разделите функции, используемые двумя различными субъектами, так как каждый субъект может независимо
                    изменять свои требования в системе.
                </td>
            </tr>
            <tr>
                <td headers="row3" width="65%">
                    Создавайте подсистемы для инкапсуляции доступа к внешней системе или устройству.
                </td>
            </tr>
            <tr>
                <th id="row5" width="35%">
                    Выясните, нет ли связанных или сцепленных элементов проектирования
                </th>
                <td headers="row5" width="65%">
                    Тесно связанные или сцепленные классы или подсистемы работают совместно, обеспечивая определенный набор
                    служб. Разместите тесно связанные элементы в подсистемах и разделите элементы вдоль линий слабой
                    связанности. В некоторых случаях от слабой связанности можно полностью избавиться, разделив классы на
                    меньшие классы с более тесно сцепленными обязанностями или по-другому разбив подсистемы на разделы.
                </td>
            </tr>
            <tr>
                <th id="row6" width="35%">
                    Обеспечьте взаимозаменяемость
                </th>
                <td headers="row6" width="65%">
                    Если для конкретной функциональной возможности указано несколько уровней обслуживания (например,
                    высокая, средняя и низкая готовность), представьте каждый уровень обслуживания как отдельную
                    подсистему; все эти подсистемы должны реализовывать один и тот же набор интерфейсов. В этом случае
                    подсистемы будут взаимозаменяемы.
                </td>
            </tr>
            <tr>
                <th id="row7" width="35%">
                    Обеспечьте распределенную обработку
                </th>
                <td headers="row7" width="65%">
                    <span                     style="mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE">Хотя
                    у конкретной подсистемы может быть несколько экземпляров, каждый на своем узле, во многих архитектурах
                    распределить один экземпляр по нескольким узлам невозможно. В случаях, когда поведение подсистемы
                    необходимо распределить по узлам, рекомендуется разложить подсистему на меньшие подсистемы (каждая из
                    которых будет представлять отдельный компонент) с более узким набором функций. <span                     style="mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes">&nbsp;</span>
                    Определите, какие функции необходимо разместить на каждом узле, и создайте на каждом узле подсистему,
                    которая будет 'владельцем' этих функций, распределив между этими подсистемами обязанности и связанные
                    элементы исходной подсистемы. <span                     style="mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes">&nbsp;</span>
                    Новые подсистемы будут внутренними по отношению к исходной подсистеме.</span>
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Взяв подсистемы за основу проектирования, обновите соответственно реализации варианта использования.
</p>
<h3>
    <a id="Modeling Subsystems" name="Modeling Subsystems">Моделирование подсистем</a>
</h3>
<p>
    Подсистемы проектирования моделируются с помощью компонентов UML. Эта конструкция предоставляет следующие возможности
    по моделированию:
</p>
<ul>
    <li>
        можно объединять классы, определяя более крупный компонент системы
    </li>
    <li>
        можно отделять видимые интерфейсы от внутренней реализации
    </li>
    <li>
        можно выполнять во время работы среды
    </li>
</ul>
<p>
    Учтите также следующее:
</p>
<ul>
    <li>
        Для каждой подсистемы проектирования необходимо задать имя и краткое описание.
    </li>
    <li>
        Обязанности исходного класса анализа должны быть переданы вновь созданной подсистеме, с документированием этих
        обязанностей с помощью описания подсистемы
    </li>
</ul>
<p>
    Примечание: в UML 2.0 также определен стереотип компонента, который называется &lt;&lt;subsystem&gt;&gt;; это означает,
    что его можно использовать, например, для представления крупномасштабных структур. Подсистема проектирования RUP может
    быть, а может и не быть крупномасштабной структурой; с точки зрения RUP, в обоих случаях она является подсистемой
    проектирования. Решить этот вопрос должен архитектор программного обеспечения (например, выбрать, помечать ли
    компоненты, состоящие из других компонентов, как относящиеся к стереотипу &lt;&lt;subsystem&gt;&gt;).
</p>
<h3>
    <a id="Subsystems That Represent Existing Products" name="Subsystems That Represent Existing Products">Подсистемы,
    представляющие существующие продукты</a> <a href="#Top"><img height="20" alt="В начало страницы"     src="./../../../core.base_rup/resources/top.gif" width="26" border="0" /></a>
</h3>
<p>
    Если существующий продукт экспортирует интерфейсы, т.е. операции (а также, возможно, <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/reception_E5EE6A47.html" guid="_yS_Rg9nmEdmO6L4XMImrsA"><b>приемы</b></a>), но в остальном оставляет все подробности реализации скрытыми, то его
    можно смоделировать как подсистему в логической панели. &nbsp;Примерами используемых системой продуктов, которые можно
    представить с помощью подсистемы, могут служить:
</p>
<ul>
    <li>
        Программное обеспечение связи (промежуточное программное обеспечение).
    </li>
    <li>
        Поддержка доступа к базам данных (поддержка отображения RDBMS).
    </li>
    <li>
        Продукты для конкретных приложений.
    </li>
</ul>
<p>
    Некоторые существующие продукты, например наборы типов и структур данных (стеки, списки, очереди), лучше представлять в
    виде пакетов, поскольку они предоставляют не только поведение, и важно и полезно именно содержимое пакета, а не сам
    пакет, который служит просто контейнером. &nbsp;
</p>
<p>
    Общие утилиты, такие как библиотеки математических функций, можно представлять в виде подсистем, если они просто
    экспортируют интерфейсы, однако оправданность такого представления зависит от того, как проектировщик трактует природу
    моделируемых объектов. &nbsp;Подсистемы - это объектно-ориентированные конструкции (так как они являются моделируемыми
    компонентами): у подсистемы могут быть экземпляры (если это указано проектировщиком). UML предоставляет другой способ
    моделировать группы глобальных переменных и процедур в <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/utility_5BFC0972.html" guid="_ybVVMNnmEdmO6L4XMImrsA">утилите</a>.
    Утилита относится к стереотипу класса - у нее не может быть экземпляров. &nbsp;
</p>
<p>
    При определении подсистемы, которая будет представлять продукт, определите также один или несколько интерфейсов для
    представления интерфейсов продукта.
</p>
<h3>
    <a id="Subsystem Dependency Restrictions" name="Subsystem Dependency Restrictions">Ограничения на зависимость
    подсистем</a> <a href="#Top"><img height="20" alt="В начало страницы" src="./../../../core.base_rup/resources/top.gif" width="26"     border="0" /></a>
</h3>
<p>
    Подсистемы проектирования (моделируемые как компоненты UML) отличаются от пакетов по своей семантике: подсистема
    предоставляет поведение через один или несколько интерфейсов, которые она реализует. Пакеты не предоставляют поведение;
    они просто служат контейнерами объектов, предоставляющих поведение.
</p>
<p>
    Причина, по которой следует применять подсистему, а не пакет, заключается в том, что подсистемы инкапсулируют свое
    содержимое, предоставляя поведение только через свои интерфейсы. Преимущество такого подхода в том, что, в отличие от
    пакета, содержимое и внутреннее поведение подсистемы можно беспрепятственно изменять, пока ее интерфейсы остаются без
    изменений. Подсистемы предоставляют также 'сменный элемент проектирования': любые два компонента
    &lt;&lt;realization&gt;&gt;, реализующие одинаковые интерфейсы (или компонент &lt;&lt;specification&gt;&gt;),
    взаимозаменяемы.
</p>
<p>
    Для того чтобы обеспечить взаимозаменяемость подсистем в модели, необходимо установить следующие два правила:
</p>
<ul>
    <li>
        Подсистема должна минимизировать открытую часть своего содержимого. В идеале, в подсистеме не должно быть ни одного
        элемента с 'общедоступной' областью видимости, так чтобы ни один элемент вне подсистемы не зависел от наличия
        конкретного элемента внутри подсистемы. Некоторые исключения приведены ниже: 
        <ul>
            <li>
                В некоторых технологиях внешние объекты подсистемы нельзя моделировать как интерфейс UML. Например,
                интерфейс Java моделируется как стереотипный класс.
            </li>
            <li>
                Для проектирования подсистемы может потребоваться открыть классы, а не интерфейсы UML. Например, с помощью
                класса "delegate" или "access" можно скрыть сложную совместную работу других классов. Хотя можно
                воспользоваться и обычным пакетом, применение подсистемы позволит акцентировать намерение инкапсулировать
                поведение и скрыть внутренние подробности.
            </li>
        </ul>
    </li>
    <li style="LIST-STYLE-TYPE: none">
        <br />
         Когда внешние объекты подсистемы не являются интерфейсами UML, часто бывает полезно составить диаграмму (например,
        под названием "Вид снаружи"), на которой будут показаны видимые элементы подсистемы.
    </li>
    <li>
        Подсистема должна определять свои зависимости от интерфейсов подсистемы (и общедоступных видимых элементов
        подсистемы в вышеописанных исключительных случаях). Кроме того, некоторые подсистемы могут совместно использовать
        набор общих интерфейсов или определений классов. В этом случае такие подсистемы 'импортируют' содержимое пакетов с
        общими элементами. Такой подход более распространен для пакетов на нижних уровнях архитектуры, чтобы обеспечить
        согласованность общих определений классов, передаваемых между подсистемами.
    </li>
</ul>
<p>
    Ниже приведен пример зависимостей подсистемы и пакета:
</p>
<p align="center">
    <img alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_dsub2.jpg" />
</p>
<p class="picturetext">
    Зависимости подсистемы и пакета в модели проектирования
</p>
<h3>
    <a id="Subsystem Specification and Realization" name="Subsystem Specification and Realization">Спецификация и
    реализация подсистем</a><a href="#Top"><img height="20" alt="В начало страницы" src="./../../../core.base_rup/resources/top.gif"     width="26" border="0" /></a>
</h3>
<h4>
    <a id="Definition" name="Definition">Определение</a><a href="#Top"><img height="20" alt="В начало страницы"     src="./../../../core.base_rup/resources/top.gif" width="26" border="0" /></a>
</h4>
<p>
    Стандарт UML ([<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04" guid="7.755968586980351E-308">UML04</a>]) гласит:
</p>
<blockquote>
    <p>
        Существует некоторое количество стандартных стереотипов UML, применимых к компоненту. Например, стереотипы
        &lt;&lt;specification&gt;&gt; и &lt;&lt;realization&gt;&gt; предназначены для моделирования компонентов с
        различными определениями спецификации и реализации, причем у одной спецификации может быть несколько реализаций.
    </p>
    <p>
        Компонент со стереотипом &lt;&lt;specification&gt;&gt; задает домен объектов, не определяя их физическую
        реализацию. Он будет содержать только предоставляемые и обязательные интерфейсы и не предназначен для того, чтобы в
        его определении были реализующие классы и подкомпоненты.
    </p>
    <p>
        Компонент со стереотипом &lt;&lt;realization&gt;&gt; задает домен объектов, а также задает их физическую
        реализацию. Например, у компонента со стереотипом &lt;&lt;realization&gt;&gt; будут только те реализующие классы и
        подкомпоненты, которые реализуют поведение, заданное отдельным компонентом &lt;&lt;specification&gt;&gt;.
    </p>
</blockquote>
<p>
    Разделение спецификации и реализации, по существу, позволяет задавать два отдельных описания подсистемы. Спецификация
    выступает в роли договора, определяющего все, что клиенту необходимо знать для работы с подсистемой. Реализация - это
    подробный внутренний макет, инструктирующий реализатора. Если вы хотите поддерживать несколько реализаций, создайте
    отдельные подсистемы "реализации" и проведите линию реализации от каждой подсистемы реализации к подсистеме
    спецификации.
</p>
<h4>
    <a id="When and how to use" name="When and how to use">Когда и как использовать</a>
</h4>
<p>
    Если внутреннее состояние и поведение подсистемы сравнительно просты, то может оказаться достаточно указать подсистему
    посредством ее открытых интерфейсов, диаграмм состояния, описывающих поведение, и текста описания.
</p>
<p>
    Если внутреннее состояние и поведение более сложные, то с помощью классов анализа можно указать подсистему на высоком
    уровне абстракции. В случае больших систем, состоящих из других систем, спецификация подсистемы может также включать
    варианты использования. См. раздел <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/whitepapers/developing_large-scale_systems_with_the_rational_unified_process_7AA2AF65.html" guid="1.768223108034868E-305">Разработка крупномасштабных систем в Rational Unified Process</a>.
</p>
<p>
    Предоставление подробной спецификации отдельно от реализации особенно полезно в следующих случаях:
</p>
<ul>
    <li>
        У реализации подсистемы сложное внутреннее состояние или поведение - и спецификацию необходимо выразить как можно
        проще, чтобы клиентам было удобно ей пользоваться;
    </li>
    <li>
        Подсистема является многоразовым "компонентом сборки", используемым в различных системах (см. раздел <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/component_A2E2B3B1.html" guid="3.524150980437479E-305">Концепция: компонент</a>);
    </li>
    <li>
        Внутренние структуры подсистемы будут разрабатываться отдельной организацией;
    </li>
    <li>
        Необходимо создать несколько реализаций подсистемы;
    </li>
    <li>
        Подсистему предполагается заменить на другую версию, имеющую значительные внутренние отличия, без изменения внешне
        видимого поведения.
    </li>
</ul>
<p>
    Обслуживание отдельной спецификации, однако, требует усилий, поскольку необходимо убедиться, что реализация подсистемы
    совместима со спецификацией. Критерии относительно того, когда и в каких случаях следует создавать отдельные
    кооперирования и классы спецификации и реализации, должны быть определены в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рабочий продукт: рекомендации по проекту</a>.
</p>
<h4>
    <a id="Dependencies" name="Dependencies">Зависимости</a>
</h4>
<p>
    Спецификация должна определять свои зависимости. Это интерфейсы и видимые элементы из других подсистем и пакетов,
    которые должны быть доступны во всех совместимых реализациях подсистемы.
</p>
<p>
    У реализации могут быть дополнительные зависимости, введенные проектировщиком или реализатором. Например, возможно, что
    для упрощения реализации применяется компонент утилиты, однако это та подробность, которую не следует раскрывать перед
    клиентами. Эти дополнительные зависимости следует захватить на отдельной диаграмме как часть процедуры реализации.
</p>
<h4>
    <a id="Relationship to Implementation" name="Relationship to Implementation">Отношение к реализации</a>
</h4>
<p>
    Полная спецификация определяет все, что необходимо знать клиенту для работы с подсистемой. Это означает уточнение
    открытых интерфейсов и всех общедоступных видимых элементов, так чтобы они в точности соответствовали коду. Классы
    анализа, введенные с целью указать поведение подсистемы, должны оставаться на высоком уровне абстракции, поскольку
    предполагается, что они независимы от реализаций подсистем.
</p>
<p>
    Элементы реализации подсистемы должны точно соответствовать коду.
</p>
<p>
    Продолжение этой темы см. в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/mapping_from_design_to_code_D1454680.html" guid="1.424219730601675E-305">Технология: от проектирования к коду</a>.
</p>
<h3>
    <a id="UML_1x_Representation" name="UML_1x_Representation">Представление UML 1.x</a>
</h3>
<h4>
    Моделирование
</h4>
<p>
    Подсистемы проектирования можно моделировать как компоненты UML 2.0 или как подсистемы UML 1.5. Эти конструкции
    предоставляют практически эквивалентные возможности по моделированию, такие как модульность, инкапсуляция и экземпляры,
    выполнимые во время работы среды.
</p>
<p>
    Ниже приведены некоторые дополнительные сведения об этих опциях моделирования:
</p>
<ul>
    <li>
        Подсистемы UML 1.5 явно включают понятия "спецификации" и "реализации" (определенные выше в разделе <a href="#Subsystem Specification and Realization">Спецификация и реализация подсистемы</a>). Компоненты UML 2.0
        поддерживают понятие спецификации (в форме одного или нескольких предоставляемых и обязательных интерфейсов) и
        реализации (внутренняя реализация, состоящая из одного или нескольких классов и подкомпонентов, реализующих ее
        поведение).
    </li>
    <li>
        Подсистемы UML 1.5 раньше были пакетами. У компонентов UML 2.0 есть пакетные возможности, что означает, что они
        могут содержать и импортировать потенциально большой набор элементов модели.
    </li>
</ul>
<p>
    Однако эти понятия взаимозаменяемы. Решение о том, следует ли представлять подсистемы проектирования как подсистемы UML
    1.5 или как компоненты UML 2.0, должно быть отражено в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Рекомендации по проекту</a> для вашего проекта.
</p>
<p>
    Если инструмент визуального моделирования поддерживает пакеты UML 1.5, но не подсистемы UML 1.5, то для обозначения
    подсистемы можно воспользоваться пакетом со стереотипом &lt;&lt;subsystem&gt;&gt;.
</p>
<h4>
    Ограничения на зависимость подсистем
</h4>
<p>
    Ограничения на зависимость и обсуждения, приведенные в разделе <a href="#Subsystem Dependency Restrictions">Ограничения на зависимость подсистем</a>, применимы и к подсистемам
    проектирования, моделируемым как подсистемы UML 1.5.
</p>
<p>
    Ниже приведен пример зависимостей подсистемы и пакета в UML 1.5:
</p><br />
<br />
<p align="center">
    <img height="240" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_dsub1.gif" width="370" />
</p>
<p class="picturetext">
    Зависимости подсистемы и пакета в модели проектирования<br />
    <br />
</p>
<h4>
    Спецификация и реализация подсистемы
</h4>Стандарт UML 1.5 гласит: 
<blockquote>
    <p>
        Содержимое подсистемы подразделяется на два подмножества: 1) элементы спецификации и 2) элементы реализации.
        Элементы спецификации, совместно с операциями и приемами подсистемы, предоставляют абстрактную спецификацию
        поведения, предлагаемого элементами реализации. Совокупность элементов реализации моделирует внутреннее устройство
        поведенческого блока физической системы.
    </p>
</blockquote>
<p>
    Разделение спецификации и реализации, по существу, позволяет задавать два отдельных описания подсистемы. Спецификация
    выступает в роли договора, определяющего все, что клиенту необходимо знать для работы с подсистемой. Реализация - это
    подробный внутренний макет, инструктирующий реализатора.
</p>
<p>
    Одна из возможностей при моделировании спецификаций и реализаций, при отсутствии прямой поддержки со стороны среды
    моделирования, заключается в том, чтобы поместить два пакета, спецификацию и реализацию, внутрь каждой подсистемы.
</p>
<p>
    Одна из причин применения спецификаций - поддержка множественных реализаций. В UML 1.x непосредственная поддержка этой
    функциональной возможности отсутствовала. Если вы хотите поддерживать несколько реализаций с помощью подсистем UML 1.5,
    создайте отдельные подсистемы "реализации" и проведите линию реализации от каждой подсистемы реализации к подсистеме
    спецификации.
</p>
<p>
    В целом, вся информация о спецификации и реализации, приведенная для UML 2.0, применима и здесь (объяснение см. в
    разделах <a href="#When and How to Use">Когда и как использовать</a>, <a href="#Dependencies">Зависимости</a> и
    <a href="#Relationship to Implementation">Отношение к реализации</a>).
</p>
<h4>
    Дополнительная информация
</h4>
<p>
    Дополнительная информация приведена в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html" guid="4.792914878943572E-306">Различия между UML 1.x и UML 2.0</a>.<br />
    <br />
</p></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
