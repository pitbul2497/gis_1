<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Анализ классов эквивалентности</title>
<meta content="Guideline" name="uma.type">
<meta content="equivalence_class_analysis" name="uma.name">
<meta content="Анализ классов эквивалентности" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "3.8675740383428907E-305"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "3.8675740383428907E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="3.8675740383428907E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Анализ классов эквивалентности</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Анализ классов эквивалентности - это метод для минимизации количества тестовых сценариев. В этой рекомендации описан данный метод и его способы его применения.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_workload_analysis_model_E86A32FF.html" guid="{008164B1-3AC3-47E8-9F93-EE4C36B58A97}">Модель анализа нагрузки</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/identify_test_ideas_395DAB3B.html" guid="{6FAD9DF9-DE4E-4BA5-9B9B-482A2366D1B9}">Определение идеи тестирования</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_case_8AFEC963.html" guid="{D525758B-EBA2-4F59-9BA6-226820C27ADD}">Тестовый набор</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_ideas_list_2A0F8E03.html" guid="{45219F27-0F84-4FD5-A7BC-73C19226303B}">Тест - Список идей</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_runtime_observation_amp;_analysis__concept" name="XE_runtime_observation_&_analysis__concept"></a> 
<h3>
    <a id="Introduction" name="Introduction">Введение</a>
</h3>
<p>
    Обычно для системы (за исключением самых простых приложений) невозможно протестировать все логически возможные входные
    комбинации. Поэтому одна из важнейших задач для разработчиков - выбрать для тестирования те комбинации, где с
    наибольшей вероятностью можно найти большинство ошибок.
</p>
<p>
    Тестирование, основанное на анализе классов эквивалентности (синонимы: <i>разбиение на области эквивалентности</i>,
    <i>анализ области</i>) - это анализ тестирования методом "черного ящика". Цель анализа - сократить до минимума общее
    число циклов тестирования и обнаружить при этом максимальное возможное количество ошибок [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#MYE79" guid="7.755968586980351E-308">MYE79</a>]. Этот метод позволяет разделить ряд входных и выходных данных на конечное
    число <i><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/equivalence_class_9F855392.html" guid="_yHz8QNnmEdmO6L4XMImrsA">классов
    эквивалентности</a></i> и выбрать характерное тестовое значение для каждого класса. Результаты тестирования
    характерного значения класса считаются "эквивалентными" другим значениям того же класса. Если при тестировании
    характерного значения ошибки не были найдены, предполагается, что все другие "эквивалентные" значения также не будут
    содержать ошибки.
</p>
<p>
    Преимущество анализа классов эквивалентности в том, что он позволяет придерживаться выборочной стратегии и сокращать
    объем комбинаторного взрыва потенциально необходимых тестов. Это метод позволяет вывести логические критерии выбора
    отдельных тестов из всех возможных тестов. Ниже перечислены области, где требуется проведение большого количества
    тестов, и где применение классов эквивалентности могло бы облегчить работу:
</p>
<ol>
    <li>
        Комбинации независимых переменных
    </li>
    <li>
        Зависимые переменные, основанные на иерархических отношениях
    </li>
    <li>
        Зависимые переменные, основанные на временных отношениях
    </li>
    <li>
        Кластерные отношения, основанные на моделях рынка
    </li>
    <li>
        Моделируемые составные отношения
    </li>
</ol>
<h3>
    <a id="Strategies" name="Strategies">Стратегии</a>
</h3>
<p>
    Существуют разные стратегии и методы для проведения тестирования с разбиением на классы эквивалентности. Некоторые
    примеры приведены ниже:
</p>
<h4>
    <a id="EquivalenceClassPartition" name="EquivalenceClassPartition">Разбиение на классы эквивалентности</a>
</h4>
<p>
    Теория разбиения на классы эквивалентности, предложенная Гленфордом Майерсом (Glenford Myers) [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#MYE79" guid="7.755968586980351E-308">MYE79</a>], направлена на сокращение общего числа необходимых тестовых сценариев путем
    разбиения входных условий на конечное число классов эквивалентности. Создается два типа классов: допустимые входные
    данные программы рассматриваются как <i>допустимый класс эквивалентности</i>, а все остальные входные данные заносятся
    в <i>недопустимый класс эквивалентности</i>.
</p>
<p>
    Ниже приведены рекомендации по определению классов эквивалентности:
</p>
<ol>
    <li>
        Если входное условие указывает диапазон значений (например, программа "принимает значения от 10 до 100"), то
        определяются один допустимый класс эквивалентности (от 10 до 100) и два недопустимых (меньше 10 и больше 100).
    </li>
    <li>
        Если входное условие указывает набор значений (например, "ткань может быть разных цветов: красного, белого,
        черного, зеленого, коричневого"), то определяются один допустимый класс (с допустимыми значениями) и один
        недопустимый (со всеми недопустимыми значениями). Каждое значение допустимого класса нужно обрабатывать отдельно.
    </li>
    <li>
        Если входное условие содержит выражение долженствования (например, "строка ввода должна содержать прописные
        символы"), то определяются один допустимый класс (прописные символы) и один недопустимый класс (все остальные
        варианты ввода кроме прописных символов).
    </li>
    <li>
        Все действия, выполненные "задолго" до выполнения задачи, считаются классом эквивалентности. Все действия,
        выполненные незадолго до завершения программы, считаются еще одним классом. Все действия, выполненные
        непосредственно перед запуском программой другой операции, также считаются отдельным классом.
    </li>
    <li>
        Если программа настроена на работу с памятью объемом от 64 Мб до 256 Мб, то этот диапазон считается классом
        эквивалентности. Любой другой объем, больше, чем 256 Мб или меньше, чем 64 Мб, считается недопустимым классом.
    </li>
    <li>
        Разбиение выходных событий на классы связано с входными данными программы. Несмотря на то, что некоторым входным
        классам эквивалентности могут соответствовать выходные события того же типа, рекомендуется входные классы
        рассматривать отдельно.
    </li>
</ol>
<h4>
    <a id="BoundaryValueAnalysis" name="BoundaryValueAnalysis">Анализ граничных значений</a>
</h4>
<p>
    Для каждого класса эквивалентности предполагается, что граничные условия позволяют с большей вероятностью найти ошибки,
    чем остальные условия. Граничными условиями считаются ближайшие значения, стоящие с обеих сторон крайних значений,
    определяющих границы класса.
</p>
<p>
    При тестировании граничных условий из тестируемого диапазона выбираются следующие значения: минимальное значение (min),
    значение, на одно больше минимального (min+), значение, на одно меньше максимального (max-), и максимальное значение
    (max). В этом случае разработчики выбирают несколько тестовых сценариев для каждого класса эквивалентности. При
    относительно небольшом количестве тестов велика вероятность обнаружения ошибок. Разработчикам не приходится тестировать
    огромное количество значений, для которых результаты тестирования незначительно отличаются друг от друга.
</p>
<p>
    Рекомендации по выбору граничных значений:
</p>
<ol>
    <li>
        Если допустимое значение плавающей переменной составляет от <code>-1.0</code> до <code>1.0</code>, протестируйте
        значения <code>-1.0</code>, <code>1.0</code>, <code>-1.001</code> и <code>1.001</code>.
    </li>
    <li>
        Если диапазон допустимых значений входных данных составляет целое число от <code>10</code> до <code>100</code>,
        протестируйте <code>9</code>, <code>10</code>, <code>100</code>, <code>101</code>.
    </li>
    <li>
        Если программа настроена на работу с прописными символами, протестируйте граничные значения для A и Z.
        Протестируйте <code>@</code> и <code>[</code>, потому что в коде ASCII символ <code>@</code> предшествует A, а
        символ <code>[</code> следует сразу за Z.
    </li>
    <li>
        Если входные или выходные данные программы представляют собой упорядоченный набор, протестируйте первый и последний
        элементы набора.
    </li>
    <li>
        Если сумма входных данных выражена числом (<code>n</code>), протестируйте программу, где сумма равна
        <code>n-1</code>, <code>n</code> или <code>n+1</code>.
    </li>
    <li>
        Если программа поддерживает список, протестируйте значения из этого списка. Все остальные значения считаются
        недопустимыми.
    </li>
    <li>
        При считывании из файла или записи в файл протестируйте первый и последний символы файла.
    </li>
    <li>
        Наименьшая денежная единица - один цент или его эквивалент. Если программа поддерживает некий диапазон от a до b,
        протестируйте a <code>-0.01</code> и b <code>+0.01</code>.
    </li>
    <li>
        Если для переменной указано несколько диапазонов значений, каждый диапазон считается отдельным классом. Если
        подмножества значений из этих диапазонов не пересекаются, протестируйте крайние значения, а также граничные
        значения над верхней границей и под нижней границей.
    </li>
</ol>
<h4>
    <a id="SpecialValues" name="SpecialValues">Специальные значения</a>
</h4>
<p>
    После применения двух указанных выше стратегий анализа граничных значений рекомендуется исследовать программу на
    наличие "специальных значений", с помощью которых можно обнаружить множество ошибок. Некоторые примеры приведены ниже:
</p>
<ol>
    <li>
        В случае с целыми числами нужно обязательно протестировать ноль, если он входит в допустимый класс эквивалентности.
    </li>
    <li>
        При тестировании времени необходимо для каждого элемента (час, минута и секунда) протестировать значения 59 и 0,
        независимо от ограничения, установленного для входной переменной. Помимо граничных значений входной переменной
        необходимо всегда тестировать значения -1, 0, 59 и 60.
    </li>
    <li>
        При тестировании даты (год, месяц и день) необходимо добавить тестовые сценарии, например, для количества дней в
        конкретном месяце, количества дней в феврале в високосном году или количества дней в невисокосном году.
    </li>
</ol>
<h4>
    <a id="CategoryPartition" name="CategoryPartition">Метод "Разбиение на категории"</a>
</h4>
<p>
    <a href="#OstrandBalcer">Остранд и Болсер</a> (Ostrand and Balcer) [16] разработали метод разбиения, который позволяет
    испытателям анализировать спецификацию системы, создавать тестовые сценарии и управлять ими. Если большинство стратегий
    сфокусированы на работе с исходным кодом, метод Остранда и Болсера также предполагает использование данных спецификации
    и проектирования.
</p>
<p>
    Главное преимущество этого метода в том, что он позволяет обнаруживать ошибки еще до создания кода, потому что
    источником ввода является спецификация, и тестирование основано на ее анализе. Недоработки в спецификациях можно
    обнаружить на ранних стадиях, часто до ее реализации в коде.
</p>
<p>
    Ниже перечислены шаги для применения метода "разбиение на категории":
</p>
<ol>
    <li>
        Проанализируйте спецификацию: разложите набор функций системы на функциональные единицы, которые можно
        протестировать независимо друг от друга как с помощью спецификации, так и реализации.<br />
         Далее:<br />
        <br />
         
        <ol>
            <li>
                Определите параметры и условия среды, от которых зависит выполнение функции. Параметры - это входные данные
                функциональной единицы. Условия среды - это состояния системы, от которых зависит выполнение функциональной
                единицы.
            </li>
            <li>
                Определите характеристики параметров и условий среды.
            </li>
            <li>
                Разбейте характеристики на категории, от которых зависит поведение системы.<br />
                <br />
            </li>
        </ol>На этой стадии будут обнаружены неоднозначные, противоречащие и недостающие элементы описания поведения
        системы.<br />
        <br />
    </li>
    <li>
        Разделите категории на варианты. Варианты - это ситуации, которые могут неожиданно возникнуть. В каждом варианте
        содержится тот же тип данных, что и в категории.<br />
        <br />
    </li>
    <li>
        Определите ограничения и отношения между вариантами. Варианты из разных категорий взаимосвязаны, и это нужно
        учитывать при составлении тестового сценария. Ограничения предотвращают возникновение противоречий между вариантами
        с разными параметрами или из разных сред.<br />
        <br />
    </li>
    <li>
        Опираясь на информацию о категориях, вариантах и ограничениях, разработайте тестовые сценарии. Если при
        использовании какого-то варианта возникает ошибка, не добавляйте его к другим вариантам при составлении сценария.
        Если вариант можно полноценно протестировать за один тест, значит это частный случай варианта или специальное
        значение.
    </li>
</ol>
<h3>
    <a id="FurtherReading" name="FurtherReading">Дополнительная информация и ссылки</a>
</h3>
<ol>
    <li>
        Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., New York, 1979.
    </li>
    <li>
        White L. J. and Cohen E. I., A domain strategy for computer program testing, IEEE Transaction on Software
        Engineering, Vol. SE-6, No. 3, 1980.
    </li>
    <li>
        Lori A. Clarke, Johnhette Hassell, and Debra J Richardson, A Close Look at Domain Testing, IEEE Transaction on
        Software Engineering, 8-4, 1992.
    </li>
    <li>
        Steven J. Zeil, Faten H. Afifi and Lee J. White, Detection of Linear Detection via Domain Testing, ACM Transaction
        on Software Engineering and Methodology, 1-4, 1992.
    </li>
    <li>
        BingHiang Jeng, Elaine J. Weyuker, A Simplified Domain-Testing Strategy, ACM Transaction on Software Engineering
        and Methodology, 3-3, 1994.
    </li>
    <li>
        Paul C. Jorgensen, Software Testing - A Craftsman's Approach, CRC Press LLC, 1995.
    </li>
    <li>
        Martin R. Woodward and Zuhoor A. Al-khanjari, Testability, fault, and the domain-to-range ratio: An eternal
        triangle, ACM Press New York, NY, 2000.
    </li>
    <li>
        Dick Hamlet, On subdomains: Testing, profiles, and components, SIGSOFT: ACM Special Interest Group on Software
        Engineering, 71-16, 2000.
    </li>
    <li>
        Cem Kaner, James Bach, and Bret Pettichord, Lessons learned in Software Testing, John Wiley & Sons, Inc., New
        York, 2002.
    </li>
    <li>
        Andy Podgurski and Charles Yang, Partition Testing, Stratified Sampling, and Cluster Analysis, SIGSOFT: ACM Special
        Interest Group on Software Engineering, 18-5, 1993.
    </li>
    <li>
        Debra J. Richardson and Lori A. Clarke, A partition analysis method to increase program reliability, SIGSOFT: ACM
        Special Interest Group on Software Engineering, 1981.
    </li>
    <li>
        Lori A. Clarke, Johnette Hassell, and Debra J Richardson, A system to generate test data and symbolically execute
        programs, IEEE Transaction on Software Engineering, SE-2, 1976.
    </li>
    <li>
        Boris Beizer, Black-Box Testing - Techniques for Functional testing of Software and System, John Wiley & Sons,
        Inc., 1995.
    </li>
    <li>
        Steven J. Zeil, Faten H. Afifi and Lee J. White, Testing for Liner Errors in Nonlinear computer programs, ACM
        Transaction on Software Engineering and Methodology, 1-4, 1992.
    </li>
    <li>
        William E. Howden, Functional Program Testing, IEEE Transactions on Software Engineering, Vol. SE-6, No. 2, 1980.
    </li>
    <li>
        <a id="OstrandBalcer" name="OstrandBalcer">Thomas J. Ostrand and Marc J. Balcer</a>, The Category-Partition method
        for specifying and generating functional tests, Communications of ACM 31, 1988.
    </li>
    <li>
        Cem Kaner, Jack Falk and Hung Quoc Nguyen, Testing Computer Software, John Wiley & Sons, Inc., 1999.
    </li>
</ol>
<p>
    &nbsp;
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
