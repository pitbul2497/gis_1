<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Обобщение</title>
<meta content="Guideline" name="uma.type">
<meta content="generalization" name="uma.name">
<meta content="Обобщение" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.839540980397304E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="1.839540980397304E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Обобщение</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Обобщение - это отношение между классами, которое отражает свойства, общие для разных классов. В этой рекомендации описываются способы работы с этим отношением.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Модель проектирования</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/class_design_98F20FF9.html" guid="{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}">Проектирование классов</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Проектировщик</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_capsule_designer_F3E66EDF.html" guid="{86253FE7-0036-4D14-8BD7-C18CE86A5E14}">Проектировщик капсул</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_use-case-generalization__guidelines_for" name="XE_use-case-generalization__guidelines_for"></a><a id="XE_generalization__guidelines_for" name="XE_generalization__guidelines_for"></a> 
<h3>
    <a id="Generalization" name="Generalization">Обобщение</a>
</h3>
<p>
    Многие вещи в реальной жизни обладают общими. Например, и кошки, и собаки - животные. У объектов также могут быть общие
    свойства, которые можно выделить с помощью обобщения между их классами. Выделение общих свойств в отдельные классы
    упростит процесс изменения системы и управление ею в будущем.
</p>
<p>
    Обобщение подразумевает, что один класс наследует свойство другого класса. Наследующий класс называется потомком.
    Класс, свойства которого наследуют, называется предком. Наследование означает, что определение предка, включая все его
    свойства (атрибуты, отношения или операции его объектов) также верно и для объектов потомка. Графически обобщение
    изображается в виде стрелки, направленной от потомка к предку.
</p>
<p>
    Обобщение можно выполнять в несколько стадий, что позволяет моделировать сложные многоуровневые иерархии наследования.
    Общие свойства располагаются в верхних уровнях иерархии, а специальные - в нижних. Другими словами, с помощью обобщения
    можно моделировать концепции более общего характера.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    В системе по переработке отходов все классы (Консервная банка, Бутылка и Ящик) описывают разные типы отходов. Они
    обладают двумя общими свойствами - высотой и массой. С помощью атрибутов и операций эти свойства можно оформить в виде
    отдельного класса Отходы. Классы Консервная банка, Бутылка и Ящик унаследуют свойства этого класса.
</p>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_gene2.gif" width="400" height="275" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Классы Консервная банка, Бутылка и Ящик обладают общими свойствами - высотой и массой. Каждый из этих классов
    представляет собой частный случай общей концепции Отходы.
</p>
<h3>
    <a id="XE_multiple_inheritance" name="XE_multiple_inheritance"></a><a id="XE_multiple_inheritance__guidelines_for" name="XE_multiple_inheritance__guidelines_for"></a><a id="XE_inheritance__multiple_inheritance" name="XE_inheritance__multiple_inheritance"></a><a id="Multiple Inheritance" name="Multiple Inheritance">Множественное
    наследование</a>
</h3>
<p>
    Класс может наследовать из нескольких других классов путем множественного наследования. Однако обычно у класса бывает
    только один предок.
</p>
<p>
    При использовании множественного наследования будьте готовы к следующим потенциальным проблемам:
</p>
<ul>
    <li>
        Если класс наследует свойства нескольких классов, проверьте имена отношений, операций и атрибутов предков. Если
        некоторые предки названы одинаковым именем, необходимо дать дополнительное описание в классе-потомке, например,
        указав имя для определения источника наследования.
    </li>
    <li>
        Если используется повторяющееся наследование, один и тот же предок наследуется потомком более одного раза. В этом
        случае иерархия наследования будет иметь форму ромба, как показано на следующем рисунке.
    </li>
</ul>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_gene3.gif" width="362" height="218" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Множественное и повторяющееся наследование. Класс Окно с полосой прокрутки и вложенным окном наследует свойства класса
    Окно более чем один раз.
</p>
<p>
    Здесь может возникнуть вопрос "Сколько копий атрибутов класса Окно добавлено в класс Окно с полосой прокрутки и
    вложенным окном?". При использовании повторяющегося наследования необходимо иметь четкое определение его семантики. В
    большинстве случаев семантика определяется языком программирования, который поддерживает повторяющееся наследование.
</p>
<p>
    Обычно правила языков программирования, касающиеся множественного наследования, очень сложны, и для правильного
    использования этих правил необходимо их очень хорошо понимать. Поэтому множественное наследование рекомендуется
    применять только при необходимости и с большой внимательностью.
</p>
<h3>
    <a id="XE_concrete_classes__guidelines_for" name="XE_concrete_classes__guidelines_for"></a><a id="Abstract and Concrete Classes" name="Abstract and Concrete Classes">Абстрактные и конкретные классы</a> <a id="XE_abstract_classes__guidelines_for" name="XE_abstract_classes__guidelines_for"></a>
</h3>
<p>
    Класс, не имеющий экземпляров, и существующий только для наследования другими классами, называется абстрактным классом.
    Классы, имеющие экземпляры, называются конкретными классами. Обратите внимание, что действующий абстрактный класс
    должен иметь по крайней мере одного потомка.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    Сайт Палитра в системе управления складом товаров служит абстрактным сущностным классом, который обладает свойствами,
    общими для различный типов сайтов Палитра. Свойства этого класса наследуются конкретными классами (Приемный пункт,
    Оборудование и Помещение), каждый из которых представляет собой сайт Палитра. Все эти объекты обладают общим свойством
    - содержат одну или несколько палитр.
</p>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_gene4.gif" width="370" height="208" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Класс-предок, в данном случае сайт Палитра, является абстрактным и не имеет собственных экземпляров.
</p>
<h3>
    <a id="Use" name="Use">Использование</a>
</h3>
<p>
    Поскольку каждый стереотип классов имеет свое назначение, наследование между классами разных стереотипов не имеет
    смысла. Например, если пограничный класс унаследует свойства сущностного класса, то превратится в некий гибрид. Поэтому
    обобщение применяется только между классами одного стереотипа.
</p>
<p>
    Обобщение позволяет установить два вида отношений между классами:
</p>
<ul>
    <li>
        Отношение подтипов - потомок является подтипом предка. Отношение подтипов означает, что потомок наследует структуру
        и поведение предка и является его типом. То есть, потомок - это подтип, который может полностью заменить предка в
        любой ситуации.
    </li>
    <li>
        Отношение подклассов - потомок является подклассом (не подтипом) предка. Отношение подклассов означает, что потомок
        наследует структуру и поведение предка и не является типом предка.
    </li>
</ul>
<p>
    Для создания таких отношений нужно выделить свойства, общие для нескольких классов, поместить их в отдельные классы и
    установить наследование от этих новых классов. Другой способ - создать новые классы, конкретизируя свойства более общих
    классов, и установить наследование, чтобы новые классы наследовали свойства более общих классов.
</p>
<p>
    Если эти два варианта совпадают, будет нетрудно правильно установить наследование между классами. Однако в некоторых
    случаях эти варианты не совпадают. Тогда нужно очень тщательно следить, чтобы структура наследования оставалась ясной и
    четкой. По крайней мере нужно знать назначение каждого экземпляра наследования в модели.
</p>
<h3>
    <a id="XE_inheritance__to_support_polymorphism" name="XE_inheritance__to_support_polymorphism"></a><a id="XE_generalization__inheritance_to_support_polymorphism" name="XE_generalization__inheritance_to_support_polymorphism"></a><a id="Inheritance to Support Polymorphism" name="Inheritance to Support Polymorphism">Наследование и поддержка полиморфизма</a>
</h3>
<p>
    Отношение подтипов означает, что потомок является подтипом, который может полностью заменить всех своих предков в любой
    ситуации. Отношение подтипов - это частный случай полиморфизма. Оно является важным свойством, позволяющим создавать
    все клиенты (объекты, которые используют предка) без учета потенциальных потомков этого предка. В результате
    объекты-клиенты становятся более общими и пригодными для повторного использования. Когда клиент использует
    действительный объект, он будет работать определенным образом, и объект будет всегда выполнять свою задачу. При наличии
    отношения подтипов система всегда позволяет вносить изменения в набор подтипов.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    В системе управления складом товаров класс Интерфейс Оборудование определяет базовый набор функций для связи со всеми
    типами транспортного оборудования, например, кранами и грузовиками. Этот класс определяет, помимо прочего, операцию
    executeTransport.
</p>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_gene5.gif" width="387" height="193" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Классы Интерфейс Грузовик и Интерфейс Кран наследуют свойства класса Интерфейс Оборудование. Таким образом, объекты
    обоих классов будут отвечать на сообщение executeTransport. Эти объекты могут в любое время заменить Интерфейс
    Оборудование и будут при этом обладать его поведением. Другие объекты (клиенты) могут послать сообщение в объект
    Интерфейс Оборудование, не обладая информацией, откуда придет ответ - от Интерфейса Грузовик или от Интерфейса Кран.
</p>
<p class="picturetext">
    Класс Интерфейс Оборудование может быть абстрактным, то есть может не иметь собственные экземпляры. В этом случае он
    может только определять сигнатуру операции executeTransport, а классы-потомки будут ее реализовывать.
</p>
<p>
    В некоторых объектно-ориентированных языках программирования, например, в C++, иерархия классов используется как
    иерархия типов, вынуждая создавать подтипы в модели проектирования с помощью наследования. В других языках, например, в
    Smalltalk-80, при компиляции не используется контроль типов. Если объекты не могут ответить на полученное сообщение,
    они выдают сообщение об ошибке.
</p>
<p>
    Однако обобщение можно использовать для установления отношений подтипов и в языках без контроля типов. В некоторых
    случаях обобщение нужно использовать независимо от того, поддерживает ли его язык программирования. Это делается для
    упрощения модели объекта и исходного кода и удобства их обслуживания. В целом, решение о том, применять ли
    наследование, в большой степени зависит от специфики языка программирования.
</p>
<h3>
    <a id="XE_inheritance__to_support_implementation_reuse" name="XE_inheritance__to_support_implementation_reuse"></a><a id="XE_generalization__inheritance_to_support_implementation_reuse" name="XE_generalization__inheritance_to_support_implementation_reuse"></a><a id="Inheritance to Support Implementation Reuse" name="Inheritance to Support Implementation Reuse">Наследование для
    поддержки повторного использования реализации</a>
</h3>
<p>
    Отношение подклассов составляет основу концепции повторного использования при обобщении. При создании подклассов
    необходимо определить, какие части реализации будут повторно использоваться наследуемыми свойствами, определенными в
    других классах. Отношения подклассов экономят усилия и позволяют повторно использовать код при реализации классов.
</p>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    В библиотеке классов Smalltalk-80 класс Dictionary наследует свойства класса Set.
</p>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_gene6.gif" width="302" height="141" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Причина этого обобщения в том, что класс Dictionary может повторно использовать некоторые общие методы и способы
    хранения из реализации класса Set. Хотя класс Dictionary можно рассматривать как класс Set (содержащий пары
    ключ-значение), Dictionary не является подтипом Set, потому что в Dictionary нельзя добавлять объекты любых типов, а
    только пары ключ-значение. Объекты, использующие Dictionary, не обладают информацией, что этот класс является классом
    Set.
</p>
<p>
    Создание подклассов часто приводит к возникновению непоследовательности наследования в иерархиях, из-за чего структуру
    наследования трудно понять и использовать. Поэтому наследование только в целях повторного использования следует
    применять тогда, когда в инструкциях по работе с языком программирования не указаны другие способы. Работа с повторным
    использованием такого типа достаточно сложна. Любые изменения класса Set могут повлечь значительные изменения всех
    классов, наследующих его свойства. Учтите это и устанавливайте наследование только от стабильных классов. Наследование
    фактически остановит реализацию класса Set, потому что для его изменения придется приложить слишком много усилий.
</p>
<h3>
    <a id="XE_programming_languages__designing_inheritance" name="XE_programming_languages__designing_inheritance"></a><a id="XE_inheritance__in_programming_languages" name="XE_inheritance__in_programming_languages"></a><a id="XE_generalization__inheritance_in_programming_languages" name="XE_generalization__inheritance_in_programming_languages"></a><a id="Inheritance in Programming Languages" name="Inheritance in Programming Languages">Наследование в языках программирования</a>
</h3>
<p>
    Использование отношений обобщения при проектировании сильно зависит от семантики и соответствующих рекомендаций языка
    программирования. Объектно-ориентированные языки поддерживают наследование между классами, а остальные языки - нет. При
    работе с моделью проекта необходимо учитывать характеристики языка программирования. Если язык не поддерживает
    наследование или множественное наследование, необходимо смоделировать наследование при реализации. В таком случае это
    лучше сделать в модели проекта и не использовать обобщение для описания структур наследования. Моделирование структур
    наследования с помощью обобщения, а затем моделирование наследования при реализации может разрушить проект.
</p>
<p>
    Если язык не поддерживает наследование или множественное наследование, необходимо смоделировать наследование при
    реализации. В таком случае это лучше сделать в модели проекта и не использовать обобщение для описания структур
    наследования. Моделирование структур наследования с помощью обобщения, а затем моделирование наследования в реализации
    может разрушить проект.
</p>
<p>
    Во время моделирования возможно потребуется изменить свойства интерфейсов и других объектов. Наследование рекомендуется
    моделировать одним из следующих способов:
</p>
<ol>
    <li>
        Направляя сообщения от потомка к предку.
    </li>
    <li>
        Копируя код предка в каждом потомке. В этом случае класс предка не создается.
    </li>
</ol>
<p class="exampleheading">
    Пример
</p>
<p class="example">
    В этом примере потомки направляют сообщения своему предку через ссылки, которые являются экземплярами ассоциаций.
</p>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_gene7.gif" width="346" height="206" alt="Диаграмма, описанная в тексте." />
</p>
<p class="picturetext">
    Поведение, общее для объектов Консервная банка, Бутылка и Ящик, оформляется в отдельный класс. Объекты с таким же
    поведением при необходимости его выполнения посылают сообщение в объект Отходы.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
