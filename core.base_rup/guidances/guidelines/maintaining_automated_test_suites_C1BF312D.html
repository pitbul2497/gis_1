<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Сопровождение автоматизированных комплектов тестов</title>
<meta content="Guideline" name="uma.type">
<meta content="maintaining_automated_test_suites" name="uma.name">
<meta content="Сопровождение автоматизированных комплектов тестов" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.0721213907815595E-305"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.0721213907815595E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="2.0721213907815595E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Сопровождение автоматизированных комплектов тестов</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Принципы проектирования и управления при сопровождении комплектов тестов.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_suite_DA8938D2.html" guid="{33DE37A2-ECFE-483B-934B-629F5802F87C}">Комплект тестов</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/implement_developer_test_66FE6BEE.html" guid="{862F3EC5-70C3-4D9C-BF0E-EF93AE1BF936}">Реализация теста разработчика</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/structure_the_test_implementation_AAB73625.html" guid="{ED9DF0C0-744A-443A-AEBA-604382E05A5F}">Создание реализация теста</a>
</li>
<li>
<a href="./../../../core.base_rup/capabilitypatterns/improve_test_assets_1C99FFB9.html" guid="{CD77CBDA-CC13-4593-BB81-41AF3FF7A84C}">Улучшение ресурсов тестирования</a>
</li>
<li>
<a href="./../../../core.base_rup/capabilitypatterns/improve_test_assets_BA3D58B2.html" guid="_D2HUJUdWEdqMoerwwyqMKQ">Улучшение ресурсов тестирования</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_test__developer_testing__maintaining_automated_tests" name="XE_test__developer_testing__maintaining_automated_tests"></a><a id="XE_developer_testing__automated_tests__maintanence_of" name="XE_developer_testing__automated_tests__maintanence_of"></a> 
<h3>
    <a id="Introduction" name="Introduction">Введение</a>
</h3>
<p>
    Тесты могут выходить из строя. Выход из строя вызывается изменением их среды. Например, таким изменением может быть
    перенос на другую операционную систему. Однако наиболее часто причиной является такое изменение диагностируемого кода,
    что тест <i>корректно</i> сообщает об ошибка в разрабатываемом ПО. Предположим, что вы работаете над версией 2.0
    приложения для электронных банковских услуг. В версии 1.0 для входа в систему использовался следующий метод:
</p>
<blockquote>
    <p align="left">
        <font size="+0">public boolean login (String username);</font>
    </p>
</blockquote>
<p>
    Для версии 2.0 отдел маркетинга потребовал реализовать защиту на основе пароля. Поэтому метод был заменен следующим:
</p>
<blockquote>
    <p align="left">
        <font size="+0">public boolean login (String username<i><b>, String password</b></i>);</font>
    </p>
</blockquote>
<p>
    Все тесты, использующие функцию входа в систему, выйдут из строя. Более того, они даже не будут скомпилированы. Т.к.
    без входа в систему большинство тестируемых функций не доступны, потребуется внести изменения почти во все тесты. Таких
    тестов может быть сотни или даже тысячи.
</p>
<p>
    Очевидно, для исправления тестов нужно воспользоваться утилитой глобального поиска и замены, указав ей заменять все
    вхождения login(<i>что-то</i>) на login(<i>что-то</i>, "dummy password"). Укажите этот пароль ("dummy password") для
    всех учетных записей, используемых для тестирования, и тесты снова будут работать.
</p>
<p>
    После дополнительных раздумий отдел маркетинга просит запретить пароли с пробелами, для чего вы снова прибегаете к
    услугам утилиты глобального поиска и замены.
</p>
<p>
    Однако на такие изменения все-равно требуется определенное время, особенно когда изменения в тестах не такие
    примитивные. Существует альтернатива.
</p>
<p>
    Предположит, что сначала тесты вообще не обращались к методу <font size="+0">login</font> проекта. Вместо этого
    использовалась библиотечная функция, выполняющая все действия, необходимые для входа в систему. Изначально эта функция
    выглядела так:
</p>
<blockquote>
<pre>
public boolean testLogin (String username) {
  return product.login(username);
}
</pre>
</blockquote>
<p>
    После изменений для версии 2.0 она изменяется и становится такой:
</p>
<blockquote>
<pre>
public Boolean testLogin (String username) {
  return  product.login(username<b>
<i>
, "dummy password"</i></b>);
}
</pre>
</blockquote>
<p>
    Вместо изменения тысяч тестов нужно изменить только одну функцию.
</p>
<p>
    В идеале, такие такая структуризация должна была бы выполняться при первом написании тестов. Однако на практике все
    предвидеть невозможно - вы можете не осознавать потребность в вспомогательном методе <font size="+0">testLogin</font>
    до первого изменения функции <font size="+0">login</font> Поэтому очень часто такие вспомогательные методы "выносятся"
    в библиотеку из существующих тестов по мере необходимости. Проводить такую реорганизацию <i>очень важно</i>, даже если
    вы отстаете от запланированного графика. В противном случае вы потратите больше времени на сопровождение написанного в
    плохом стиле комплекта тестов. Выигранное таким образом время лучше потратить на написание новых тестов.
</p>
<p>
    <b>Примечание</b>: тесты самого метода <font size="+0">login</font> по-прежнему должны вызывать его непосредственно.
    Поэтому, после изменения этого метода, его тесты все же придется обновлять описанным вначале способом (если тесты
    метода <font size="+0">login</font> не сообщают об ошибках после изменения способа вызова метода, то, наверное, это
    плохие тесты).
</p>
<h3>
    <a id="AbstractionManagesComplexity" name="AbstractionManagesComplexity">Абстрагирование помогает в работе со сложными
    системами</a>
</h3>
<p>
    В предыдущем разделе показан пример абстрагирования от конкретного приложения и его преимущества. Естественно,
    возможности абстрагирования этим примером не ограничиваются. Скорее всего большинство тестов начинаются общей
    последовательности вызовов методов: вход в систему, поучение некоего состояния, и только потом переход к тестируемой
    части приложения. Только после этого начинается уникальная часть теста. Все подготовительные операцию могут и должны
    быть вынесены в отдельный метод с осмысленным именем, например, <font size="+0">readyAccountForWireTransfer</font>. Это
    позволяет сохранить некоторое время при написании новых тестов одного типа, кроме того, это упрощает понимание теста.
</p>
<p>
    Легкость понимания тестов очень важна. Часто со старыми тестами бывает так, что никто не знает, что конкретно они
    делают и почему. Поэтому, когда их работа нарушается, обычно исправляются наиболее простым способом, что часто приводит
    к ухудшению их способности к обнаружению дефектов. Они вообще могут перестать выполнять свою работу.
</p>
<h3>
    <a id="AnotherExample" name="AnotherExample">Другой пример</a>
</h3>
<p>
    Предположим, что вы тестируете компилятор. Некоторые из классов, написанных в самом начале, определяют его внутреннее
    дерево разбора и сопровождающие его преобразования. Создано несколько тестов, строящих деревья и тестирующих эти
    преобразования. Например, один из таких тестов:
</p>
<blockquote>
<pre>
/*
 * В выражении
 *   while (i&lt;0) { f(a+i); i++;}
 * нельзя выносить расчет "a+i" из цикла, т.к.
 * в нем содержится переменная, изменяемая в цикле.
 */
loopTest = new LessOp(new Token("i"), new Token("0"));
aPlusI = new PlusOp(new Token("a"), new Token("i"));
statement1 = new Statement(new Funcall(new Token("f"), aPlusI));
statement2 = new Statement(new PostIncr(new Token("i"));
loop = new While(loopTest, new Block(statement1, statement2));
expect(false, loop.canHoist(aPlusI))
</pre>
</blockquote>
<p>
    Код этого теста достаточно тяжело проанализировать человеку, который его не писал. Проходит время. В проект вносятся
    изменения, требующие обновления тестов. На этом этапе инфраструктура проекта намного шире, чем на момент написания
    теста. В частности, код преобразования строки в дерево разбора был вынесен в отдельную функцию. На этом этапе написание
    теста заново с нуля вполне оправдано:
</p>
<blockquote>
<pre>
loop=Parser.parse("while (i&lt;0) { f(a+i); i++; }");
// Получение указателя на компонент "a+i" цикла.
aPlusI = loop.body.statements[0].args[0];
expect(false, loop.canHoist(aPlusI));
</pre>
</blockquote>
<p>
    Такой тест выглядит намного понятнее, что скорее всего позволит сэкономить время в будущем. В данном случае намного
    эффективнее было бы вообще отложить написание тестов до завершения создания анализатора.
</p>
<p>
    Однако у такого подхода есть побочный эффект: тесты будут обнаруживать дефекты как в коде преобразования (в
    соответствии с назначением), так и в кода синтаксического анализатора (случайно). Это может осложнить локализацию
    ошибки и отладку. С другой стороны, обнаружение ошибки, пропущенной тестами самого анализатора, лучше, чем сохранение
    этой ошибки в конечном продукте.
</p>
<p>
    Дефект в коде преобразования может скрываться дефектом в анализаторе. Вероятность этого очень мала и она перекрывается
    выигрышем от упрощения сопровождения сложных тестов.
</p>
<h3>
    <a id="FocusingImprovement" name="FocusingImprovement">Концентрация на тестируемой ветви алгоритма</a>
</h3>
<p>
    В большом комплекте тестов всегда имеются долго не меняющиеся тесты. они соответствуют стабильным частям приложения.
    Остальные же тесты изменяются часто. Они соответствуют частям приложения, поведение которых часто меняется. Эти тесты
    обычно более интенсивно используют вспомогательные библиотеки. Каждый такой тест отвечает за определенную ветвь в
    алгоритме часто изменяющиеся части приложения. Вспомогательные библиотеки позволяют сосредоточиться на тестировании
    целевых ветвей алгоритма, минимизируя влияние изменений в нетестируемых ветвях.
</p>
<p>
    Например, для теста, проверяющего правило, запрещающее выносить расчет определенных выражений из цикла, рассмотренного
    выше, минимизируется влияние изменений в алгоритма создания деревьев разбора. Однако он остается восприимчивым к
    изменениям в структуре дерева разбора цикла <font size="+0">while</font> (из-за непосредственного обращения к нему для
    получения поддерева для a+i). Если такая структура часто изменяется, тест можно сделать еще более высокоуровневым путем
    вынесения кода получения поддерева в отдельную функцию<font size="+0">fetchSubtree</font> :
</p>
<blockquote>
<pre>
loop=Parser.parse("while (i&lt;0) { f(a+i); i++; }");
<b>
<i>
aPlusI = fetchSubtree(loop, "a+i");</i></b>

expect(false, loop.canHoist(aPlusI));
</pre>
</blockquote>
<p>
    Теперь тест восприимчив только к двум вещам: определению языка (например, доступность операции инкрементирования <font     size="+0">++</font>) и проверяемым правилам оптимизации циклов.
</p>
<h3>
    <a id="ThrowingAwayTests" name="ThrowingAwayTests">Одноразовость тестов</a>
</h3>
<p>
    Даже после абстрагирования с помощью вспомогательных библиотек остается вероятность нарушения работы теста, вызванного
    изменениями в частях приложения, проверка которых не входит в цели теста. Нет гарантии того, что исправляя тест вы не
    скроете дефекты, появившиеся в результате изменений. Тест исправляется для того, чтобы он обнаружил все возможные
    дефекты в данной ветви алгоритма. Однако затраты на последовательные исправления могут не стоить вероятности нахождения
    возможных дефектов. Часто бывает проще переписать тест заново.
</p>
<p>
    Большинство людей не решается отказываться от тестов - по крайней мере до того момента, когда они на столько
    погружаются в рутинные задачи по их сопровождению, что отказываются <i>сразу от всех</i> тестов. Поэтому лучше
    принимать решения тщательно для каждого теста отдельно. При решении учитывайте ответы на следующие вопросы:
</p>
<ol>
    <li>
        Как много времени уйдет на качественное исправление теста, в т.ч. использование вспомогательных библиотек?
    </li>
    <li>
        На что еще это время можно было бы потратить?
    </li>
    <li>
        Какова вероятность того, что этот тест поможет обнаружить серьезные дефекты в будущем? Какие результаты он и
        связанные с ним тесты показали за время своего существования?
    </li>
    <li>
        Сколько времени пройдет до следующего нарушения работы теста?
    </li>
</ol>
<p>
    Ответы на эти вопросы будут приблизительными или даже догадками. Но проход по этим вопросам все же лучше, чем
    исправление всех тестов подряд.
</p>
<p>
    Другой причиной отказа от тестов может быть их избыточность. Например, на ранних этапах разработки могут использоваться
    много простых тестов, проверяющих правильность создания деревьев разбора (например, метод <font size="+0">LessOp</font>
    и т.д.). Затем, во время разработки анализатора, создаются тесты, проверяющие анализатор. Т.к. анализатор использует
    функции, создающие деревьев разбора, тесты также будут (посредственно) тестировать эти функции. Если изменения в коде
    нарушают тесты создания деревьев разбора, отказ от этих тестов будет вполне оправданным. Естественно, для новых ветвей
    в алгоритме создания деревьев разбора понадобятся новые тесты. Их можно реализовать напрямую (если эти ветви трудно
    протестировать с задействованием анализатора) или посредственно (если их такая реализация возможна и более простая в
    сопровождении).
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
