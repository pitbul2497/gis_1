<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Диаграмма конечных состояний</title>
<meta content="Guideline" name="uma.type">
<meta content="statechart_diagram" name="uma.name">
<meta content="Диаграмма конечных состояний" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.4528459404144188E-304"]}, {view: "view:_bbrmwN7BEdmsEI4YDGX2ag", path: ["_bbrmwN7BEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "1.4528459404144188E-304"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="1.4528459404144188E-304"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Диаграмма конечных состояний</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Диаграмма конечных состояний - это графическая нотация для изображения спецификаций конечных автоматов, применяемых для моделирования динамического поведения элементов модели. В этой рекомендации описана сама нотация и приведены примеры ее применения.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Модель проектирования</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/capsule_design_BF66E39A.html" guid="{F13C1161-7F17-45E3-A8B7-03944A1FA6E4}">Проектирование капсул</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/class_design_98F20FF9.html" guid="{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}">Проектирование классов</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html" guid="{CAA385CA-2BA2-40F2-8FE3-E21089D02119}">Проектирование подсистемы</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/use_case_design_92D13EEE.html" guid="{76E2B93D-051C-4B8C-BEA1-B40A40CBD986}">Проектирование прецедентов</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_software_architect_DB0BF177.html" guid="{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}">Разработчик архитектуры</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_state_machine__guidelines_for" name="XE_state_machine__guidelines_for"></a> 
<h3>
    <a id="Explanation" name="Explanation">Объяснение</a>
</h3>
<p>
    Конечный автомат - это средство моделирования динамического поведения элемента модели, а точнее, аспектов поведения
    системы, управляемых событиями (см. <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/events_and_signals_734567DC.html" guid="1.800598287887014E-305">Концепции:
    события и сигналы</a>). Конечный автомат хорошо моделирует поведение, зависящее от состояния, то есть когда само
    поведение определяется состоянием, в котором находится элемент модели. Элементы модели, поведение которых не зависит от
    состояния, не требуют привлечения понятия конечного автомата для описания их поведения. Обычно такие элементы - это
    пассивные классы, которые отвечают в основном за работу с данными. Конечный автомат должен использоваться для
    моделирования поведения активного класса, который работает с событиями вызова и сигналами и реализует переходы между
    состояниями конечного автомата класса.
</p>
<p>
    Конечный автомат - это набор состояний, связанных переходами. Состояние объекта определяется тем, что он выполняет
    какую-либо задачу или ожидает события. Переход - это отношение между двумя состояниями. Он инициируется по какому-либо
    событию, при этом выполняются какие-либо действия или вычисления, и результатом его является другое конечное состояние.
    На рисунке 1 показаны элементы конечного автомата.
</p>
<p align="center">
    <img height="278" alt="Схема с нотацией конечного автомата." src="./../../../core.base_rup/guidances/guidelines/resources/md_state1.gif" width="511" />
</p>
<p class="picturetext" align="center">
    Рис. 1. Нотация конечного автомата.
</p>
<p>
    Простой редактор может рассматриваться как конечный автомат с состояниями <b>Пусто</b>, <b>Ожидание команды</b> и
    <b>Ожидание текста</b>. Переходы конечного автомата вызывают события <b>Загрузить файл</b>, <b>Вставить текст</b>,
    <b>Вставить символ</b> и <b>Сохранить и завершить работу</b>. Конечный автомат редактора показан на рисунке 2.
</p>
<p class="picturecenter" align="center">
    <img height="263" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_stad2.gif" width="437" />
</p>
<p class="picturetext" align="center">
    Рис. 2. Конечный автомат для простого редактора.
</p>
<h3>
    <a id="States" name="States">Состояния</a>
</h3>
<p align="left">
    Состояние объекта определяется тем, что он выполняет какую-либо задачу или ожидает события. Объект может находиться в
    состоянии в течение определенного отрезка времени. Состояние имеет следующие свойства:
</p>
<div align="center">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="65%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <th scope="row" width="40%">
                    Имя
                </th>
                <td width="60%">
                    Строка, отличающая состояние среди других состояний. Состояние также может не иметь имени.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    Действия при входе и выходе
                </th>
                <td width="60%">
                    Действия, выполняемые при входе в состояние и выходе из него.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    Внутренние переходы
                </th>
                <td width="60%">
                    Переходы, которые обрабатываются без изменения состояния.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    Подсостояния
                </th>
                <td width="60%">
                    Внутренняя структура состояния, включая последовательно или параллельно выполняющиеся подсостояния.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    Отложенные события
                </th>
                <td width="60%">
                    Список событий, которые не обрабатываются в этом состоянии, но ожидают обработки в очереди, которая
                    будет выполнена при переходе в другое состояние.
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Как показано на рисунке, для конечного автомата можно определить два особых состояния. Начальное состояние указывает
    состояние конечного автомата по умолчанию при его создании или начальное подсостояние. Оно изображается черным кружком.
    Конечное состояние указывает на завершение выполнения конечного автомата или содержащего состояния. Оно изображается
    черным кружком внутри черной окружности. Начальное и конечное состояния - это псевдосостояния. Ни одно из них не может
    иметь признаков обычного состояния, за исключением имени. Переход из начального состояния в конечное может быть
    полноценным переходом, включающим сторожевое условие и действие, но не может иметь событие триггера.
</p>
<h3>
    <a id="Transitions" name="Transitions">Переходы</a>
</h3>
<ul>
    <li>
        <a href="#Event Triggers">Событие триггера</a>
    </li>
    <li>
        <a href="#Guard Conditions">Сторожевые условия</a>
    </li>
    <li>
        <a href="#Actions">Действия</a>
    </li>
    <li>
        <a href="#Entry and Exit Actions">Действия при входе и выходе</a>
    </li>
    <li>
        <a href="#Internal Transitions">Внутренние переходы</a>
    </li>
    <li>
        <a href="#Deferred Events">Отложенные события</a>
    </li>
</ul>
<p>
    Переход - это отношение между двумя состояниями, указывающее, что объект в первом состоянии выполнит определенные
    действия и перейдет в другое состояние, когда произойдет какое-либо событие и будут выполнены указанные условия. Если
    происходит изменение состояния, то говорят, что переход осуществился. Пока переход не осуществился, объект находится в
    исходном состоянии, потом он переходит в целевое состояние. Переход имеет следующие свойства:
</p>
<div align="center">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="85%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <th scope="row" width="40%">
                    Исходное состояние
                </th>
                <td width="60%">
                    Состояние, из которого выполняется переход. Объект осуществляет переход из исходного состояния тогда,
                    когда он получает событие триггера перехода и выполняется сторожевое условие, если оно указано.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    <b>Событие триггера</b>
                </th>
                <td width="60%">
                    Событие, инициирующее осуществление перехода, если объект находится в исходном состоянии и выполнено
                    сторожевое условие.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    <b>Сторожевое условие</b>
                </th>
                <td width="60%">
                    Булевское выражение, которое вычисляется в момент срабатывания триггера для перехода. Если выражение
                    истинно, то переход может осуществляться, если ложно - то не может. Если это событие не инициирует
                    никакой другой переход, оно просто аннулируется.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    Действие
                </th>
                <td width="60%">
                    Атомарная вычислительная процедура, которая может быть прямо выполнена с объектом - владельцем
                    конечного автомата, и косвенным образом с другими объектами, видимыми объекту.
                </td>
            </tr>
            <tr>
                <th scope="row" width="40%">
                    Целевое состояние
                </th>
                <td width="60%">
                    Состояние, которое будет активным после завершения перехода.
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Переход может иметь несколько источников, и в этом случае он представляет соединение нескольких параллельных состояний,
    и несколько целевых состояний, и в этом случае он представляет разветвление в несколько параллельных состояний.
</p>
<h4>
    <a id="Event Triggers" name="Event Triggers">Событие триггера</a>
</h4>
<p>
    В контексте конечного автомата событие - это реализация воздействия, которое может инициировать переход в другое
    состояние. События могут иметь тип сигнала, вызова, интервала времени или изменения состояния. Сигнал или вызов могут
    иметь параметры, значения которых могут применяться для перехода, в том числе такие как сторожевое условие или
    действие. Переход может также осуществляться и не по триггеру. Такие переходы, называемые переходами завершения,
    инициируются неявно, когда задача исходного состояния выполнена.
</p>
<h4>
    <a id="Guard Conditions" name="Guard Conditions">Сторожевые условия</a>
</h4>
<p>
    Сторожевое условие проверяется в случае срабатывания триггера для перехода. При этом переход может осуществляться в
    разные целевые состояния, если сторожевые условия не перекрываются. Сторожевое условие проверяется только один раз для
    перехода в момент возникновения события. Это булевское выражение, которое может ссылаться на состояние объекта.
</p>
<h4>
    <a id="Actions" name="Actions">Действия</a>
</h4>
<p>
    Действие - это атомарная вычислительная процедура. Это означает, что событие не может прервать ее, и она будет
    выполнена до конца. Этим она отличается от задачи, которую могут прерывать другие события. Действия могут включать
    вызовы операций (владельца конечного автомата и прочих видимых объектов), создание или уничтожение другого объекта или
    отправку сигнала другому объекту. В случае отправки сигнала к имени сигнала добавляется приставка - ключевое слово
    'send'.
</p>
<h4>
    <a id="Entry and Exit Actions" name="Entry and Exit Actions">Действия при входе и выходе</a>
</h4>
<p>
    Действия при входе и выходе задают действия, которые выполняются всякий раз при входе в состояние и выходе из него,
    соответственно. Действия при входе и выходе позволяют осуществить это, не задавая явно всякий раз действия при входе в
    состояние и выходе из него. Действия при входе и выходе не могут иметь аргументов или сторожевых условий. Действия при
    входе в основное состояние конечного автомата элемента модели могут иметь параметры, которые получает автомат при
    создании элемента.
</p>
<h4>
    <a id="Internal Transitions" name="Internal Transitions">Внутренние переходы</a>
</h4>
<p>
    Внутренние переходы позволяют обработать события в рамках состояния, не выполняя переход в другое состояние и тем самым
    избегая обработки действий при входе и выходе. Внутренние переходы могут иметь события с параметрами и сторожевые
    условия и фактически представляют собой обработчики прерываний.
</p>
<h4>
    <a id="Deferred Events" name="Deferred Events">Отложенные события</a>
</h4>
<p>
    Отложенные события - это события, которые будут обработаны при входе в состояние, для которого отложенное событие будет
    активным. При входе в такое состояние событие срабатывает и может вызвать переход, как если бы оно только что возникло.
    Реализация отложенных событий требует наличия внутренней очереди событий. Если приходит отложенное событие, оно
    помещается в очередь. События из очереди обрабатываются при входе в состояние, в котором они не помечены как
    отложенные.
</p>
<h3>
    <a id="Substates" name="Substates">Подсостояния</a>
</h3>
<p>
    Простое состояние не имеет внутренней структуры. Состояние, имеющее структуру вложенных состояний, называется
    составным. Вложенность состояний может быть многоуровневой. Вложенный конечный автомат может иметь не более одного
    начального состояния и одно конечное состояние. Подсостояния позволяют упростить сложный одноуровневый конечный
    автомат, подчеркивая, что некоторые состояния могут иметь место только в каком-либо контексте (вмещающее состояние).
</p>
<p align="center">
    <img height="279" alt="Диаграмма с подсостояниями." src="./../../../core.base_rup/guidances/guidelines/resources/md_state2.gif" width="449" />
</p>
<p class="picturetext" align="center">
    Рис. 3. Подсостояния.
</p>
<p>
    Источник, внешний по отношению к составному состоянию, может инициировать переход, относящийся к составному состоянию
    или его подсостоянию. В случае составного состояния вложенный конечный автомат должен иметь начальное состояние,
    которому передается управление после входа в составное состояние и после обработки его действия при входе, если оно
    задано. В случае подсостояния управление передается ему после обработки действия при входе в вмещающее состояние, если
    оно задано, и после обработки действия при входе в вложенное состояние, если оно задано.
</p>
<p>
    Переход, выводящий из составного состояния, может иметь источником составное состояние или подсостояние. В любом случае
    сначала выполняется выход из вложенного состояния ( с выполнением действия при выходе, если оно задано), а затем -
    выход из вмещающего состояния ( с выполнением действия при выходе, если оно задано). Переход, источником которого
    является составное состояние, фактически прерывает задачу вложенного конечного автомата.
</p>
<h3>
    <a id="History States" name="History States">Хронологические состояния</a>
</h3>
<p>
    Если не оговорено иначе, то при входе в составное состояние работа вложенного конечного автомата начинается из
    начального состояния (если только переход не выполняется напрямую для подсостояния). Хронологические состояния
    позволяют повторно войти в подсостояние, которое было активным при выходе из составного состояния. Пример
    хронологических состояний приведен на Рис. 3.
</p>
<p align="center">
    <img height="211" alt="Диаграмма с хронологическими состояниями." src="./../../../core.base_rup/guidances/guidelines/resources/md_state3.gif" width="412" />
</p>
<p class="picturetext" align="center">
    Рис. 4. Хронологическое состояние.
</p>
<h3>
    <a id="Common Modeling Techniques" name="Common Modeling Techniques">Общие методики моделирования</a>
</h3>
<p>
    Конечный автомат чаще всего используется для моделирования поведения объекта в течение всего его существования. Это
    особенно хорошо применимо для объектов, поведение которых зависит от состояния. Объекты, для которых применим конечный
    автомат, это классы, подсистемы, варианты использования и интерфейсы (для проверки состояний, которые может иметь
    объект, реализующий интерфейс). В системах реального времени конечный автомат применяется также для капсул и протоколов
    (для проверки состояний, которые может иметь объект, реализующий протокол).
</p>
<p>
    Конечный автомат применяется не для всех объектов. Если поведение объекта очень простое, например, он используется для
    хранения данных, то его поведение не зависит от состояния и его конечный автомат не представляет интереса.
</p>
<p>
    Моделирование существования объекта подразумевает три аспекта: события, на которые может отвечать объект, ответ на
    такие события и влияние прошлого на текущее поведение. Моделирование существования объекта также подразумевает задание
    порядка, в котором объект может отвечать на события, начиная с времени создания объекта и заканчивая временем его
    разрушения.
</p>
<p>
    Для того чтобы смоделировать существование объекта, выполните следующее:
</p>
<ul>
    <li>
        Определите контекст конечного автомата: класс, вариант использования или вся система. 
        <ul>
            <li>
                Если контекст - это класс или вариант использования, то соберите данные о соседних классах, включая
                родительские классы и классы, связанные ассоциациями или зависимостями. Эти объекты будут кандидатами для
                действий и могут также участвовать в сторожевых условиях.
            </li>
            <li>
                Если контекст - это вся система, то ограничьте анализ каким-либо одним аспектом системы и рассмотрите
                существование объекта в этом аспекте. Рассмотрение в рамках существования системы как целого не позволит
                выделить значимые особенности.
            </li>
        </ul>
    </li>
    <li>
        Установите начальное и конечное состояние для объекта. Если эти состояния содержат дополнительные условия, примите
        их во внимание.
    </li>
    <li>
        Определите события, на которые будет отвечать объект. Их можно выделить в интерфейсах объекта. Для систем реального
        времени события также определяются из протоколов объекта.
    </li>
    <li>
        Начиная с исходного и заканчивая конечным состоянием, определите основные состояния, в которых может находиться
        объект. Соедините эти состояния переходами с соответствующими событиями-триггерами. Добавьте другие переходы.
    </li>
    <li>
        Определите действия при входе и выходе.
    </li>
    <li>
        Расширьте или упростите конечный автомат с помощью подсостояний.
    </li>
    <li>
        Убедитесь, что все события, вызывающие переходы конечного автомата, отвечают событиям, заданным в интерфейсах
        объекта. Также проверьте, что все события интерфейсов находят отражение в конечном автомате. Для систем реального
        времени события также просмотрите протоколы капсулы. Наконец, проанализируйте участки, в которых требуется
        игнорировать события (например, поместить их в очередь).
    </li>
    <li>
        Убедитесь, что все действия конечного автомата поддерживаются отношениями, методами и операциями вмещающего
        объекта.
    </li>
    <li>
        Пройдите по состояниям конечного автомата, сравнивая их с ожидаемой последовательностью событий и ответов. Найдите
        недоступные состояния и состояния, из которых система не может выйти.
    </li>
    <li>
        При реструктуризации конечного автомата убедитесь, что семантика не меняется.
    </li>
</ul>
<h3>
    <a id="Hints and Tips" name="Hints and Tips">Полезные советы</a>
</h3>
<ul>
    <li>
        Если есть такая возможность, используйте визуальное представление конечного автомата вместо детального описания
        кода перехода. Например, не следует выполнять переход для нескольких сигналов, вместо этого спроектируйте поток
        так, чтобы управление осуществлялось по-разному в зависимости от сигнала. Используйте отдельные переходы,
        срабатывающие по отдельным сигналам. Не используйте условные выражения в логике переходов, которые усложняют
        поведение.
    </li>
    <li>
        Называйте состояния в соответствии с тем, что имеет место в этом состоянии. Помните, что состояние - это не момент
        во времени, а интервал, в течение которого конечный автомат ожидает возникновения события. Например, название
        'waitingForEnd' будет лучше, чем 'end', а 'timingSomeTask' - лучше, чем 'timeout'. Не называйте состояния так, как
        если бы они были действиями.
    </li>
    <li>
        Все состояния и переходы должны иметь уникальные имена, это упрощает отладку кода.
    </li>
    <li>
        Старайтесь меньше использовать переменные состояний (атрибуты, применяемые для управления поведением), и не
        используйте их вместо создания новых состояний. Переменные состояний можно использовать в тех случаях, когда
        состояний мало, поведение не зависит или почти не зависит от состояний, и практически не встречается поведение,
        параллельное с объектом, содержащим состояние или независимое от него. Если поведение сложное, зависящее от
        состояния, с вариантами параллельного выполнения, или если события могут возникать вне объекта, содержащего
        конечный автомат, рассмотрите возможность применения кооперирования между двумя или более активными объектам
        (возможно, с определением композиции). В системах реального времени сложное, &nbsp; параллельное и зависящее от
        состояния поведение следует моделировать капсулами, содержащими вложенные капсулы.
    </li>
    <li>
        Если диаграмма содержите более чем 5 ± 2 состояний, рассмотрите возможность применения подсостояний. Опирайтесь на
        здравый смысл: десять состояний с абсолютно предсказуемым поведением могут не представлять никакой проблемы, но два
        состояния с полусотней переходов между ними очевидно следует пересмотреть. Добейтесь того, чтоб конечный автомат
        был полностью понятным.
    </li>
    <li>
        Назовите переходы по причинам, их вызывающим, или по тому, что происходит при переходе. Выберите названия, которые
        делают схемы более понятными.
    </li>
    <li>
        Если вы видите вершину с вариантами выбора, то следует рассмотреть возможность передачи ответственности за этот
        выбор другому компоненту, чтобы объект мог с ним работать как с набором сигналов, а не как со списком
        сообщение-&gt;данные &gt; x. При этом отправитель или другой промежуточный субъект будут принимать решение и
        отправлять сигнал с решением, отраженным явно в названии сигнала, например, сигналы isFull и isEmpty вместо
        сигнала, передающего сообщение с данными.
    </li>
    <li>
        Дайте осмысленное описание вариантам выбора, например 'isThereStillLife' или 'isItTimeToComplain'.
    </li>
    <li>
        В рамках объекта старайтесь называть варианты выбора уникальными именами.
    </li>
    <li>
        Существуют ли недопустимо длинные фрагменты кода в переходах? Вместо них рассмотрите применение функций с общими
        фрагментами кода. Переход должен быть написан почти как псевдокод высокого уровня, и в нем следует применять те же
        правила относительно длины функций, как и в C++. Переход более чем с 25 строками кода будет уже считаться слишком
        длинным.
    </li>
    <li>
        Функции должны быть названы согласно тому, что они делают.
    </li>
    <li>
        Особое внимание обращайте на действия при входе и выходе. При внесении изменений часто забывают соответственно
        изменять код действия при входе и выходе.
    </li>
    <li>
        Действия при выходе часто реализуют функции, связанные с безопасностью. Например, выход из состояния нагрева
        предусматривает выключение нагревателя, и действие должно проверить, что он выключен.
    </li>
    <li>
        Обычно подсостояния должны содержать два или более состояний, если только вы не создаете абстрактный конечный
        автомат, который далее будет уточняться производными классами содержащего элемента.
    </li>
    <li>
        В действиях и переходах вместо условной логики применяется точки выбора. Точки выбора хорошо заметны, в то время
        как условная логика скрыта в коде.
    </li>
    <li>
        Не применяйте сторожевые условия 
        <ul>
            <li>
                Если событие вызывает несколько переходов, то невозможно предсказать, какое сторожевое условие будет
                вычислено первым. Результаты могут быть непредсказуемыми.
            </li>
            <li>
                Может быть выполнено более чем одно сторожевое условие, но возможен только один переход. Какой именно
                переход осуществится, предсказать невозможно.
            </li>
            <li>
                Сторожевые условия не являются наглядными, их трудно увидеть.
            </li>
        </ul>
    </li>
    <li>
        Не применяйте конечные автоматы, похожие на диаграммы потоков. 
        <ul>
            <li>
                Это может указывать на попытку моделирования несуществующей абстракции, например: 
                <ul>
                    <li>
                        применение активного класса там, где лучше подходит пассивный класс или класс данных
                    </li>
                    <li>
                        моделирование класса данных с помощью класса данных и активного класса, которые очень тесно связаны
                        (то есть класс данных применяется для передачи типов данных, а активный класс содержит данные,
                        которые следовало бы придать классу данных).
                    </li>
                </ul>
            </li>
            <li>
                Неверное применение конечного автомата можно обнаружить по следующим признакам: 
                <ul>
                    <li>
                        сообщения, отправляемые самому объекту, чаще всего просто для повторного использования кода
                    </li>
                    <li>
                        малое число состояний, большое число точек выбора
                    </li>
                    <li>
                        иногда это может быть конечный автомат без циклов. Такие конечные автоматы встречаются в
                        приложениях управления процессом или контроля последовательности событий, но их наличие в анализе
                        обычно указывает, что конечный автомат используется вместо диаграммы потока.
                    </li>
                </ul>
            </li>
            <li>
                Если обнаружена такая ситуация, выполните следующее: 
                <ul>
                    <li>
                        Рассмотрите возможность разделения активного класса на несколько единиц с более четко обозначенными
                        функциями
                    </li>
                    <li>
                        Перенесите часть функций в класс данных, который связан с проблемным активным классом.
                    </li>
                    <li>
                        Перенесите часть поведения в функции активного класса.
                    </li>
                    <li>
                        Создайте более осмысленные сигналы, вместо того чтобы опираться на данные.
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3>
    <a id="Designing Abstract State Machines" name="Designing Abstract State Machines">Проектирование с абстрактными
    конечными автоматами</a>
</h3>
<p>
    Абстрактный конечный автомат - это конечный автомат, который должен быть детализирован перед тем, как его можно будет
    использовать. Абстрактные конечные автоматы могут использоваться для определения шаблонного поведения, которое будет
    уточняться в последующих элементах модели.
</p>
<p align="center">
    <img height="201" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_cpsl2.gif" width="167" />
</p>
<p class="picturetext" align="center">
    Рис. 5. Абстрактный конечный автомат.
</p>
<p>
    Рассмотрим абстрактный конечный автомат на рис. 5. Этот простой конечный автомат представляет очень абстрактный уровень
    поведения (автоматизации управления) многих типов элементов в системах, управляемых событиями. Хотя на таком уровне
    типы элементов имеют общие свойства, их фактическое поведение может сильно различаться в зависимости от назначения.
    Поэтому такой конечный автомат будет скорее всего реализован как абстрактный класс, который будет корневым для более
    специализированных активных классов
</p>
<p>
    Определим два таких уточнения абстрактного конечного автомата, используя наследование. Эти два уточнения, R1 и R2,
    показаны на рис. 6. Для ясности элементы, унаследованные из родительского класса, показаны серым.
</p>
<p align="center">
    <img height="204" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_cpsl3.gif" width="391" />
</p>
<p class="picturetext" align="center">
    Рис. 6. Два уточнения конечного автомата с рис. 5.
</p>
<p>
    Эти два уточнения различаются в том, как они реализуют рабочее состояние и как они расширяют исходный переход "start".
    Такое уточнение возможно только при знании деталей, недоступных при определении абстрактного класса.
</p>
<h3>
    <a id="Chain States" name="Chain States">Цепочки состояний</a>
</h3>
<p>
    Способность "продолжить" и входящие, и исходящие переходы очень важна для уточнения, описанного выше. Может показаться,
    что для такой семантики достаточно будет входных точек и конечных состояний в сочетании с переходами продолжения. К
    сожалению, этого недостаточно в ситуации, когда требуется расширить несколько различных переходов.
</p>
<p>
    Фактически для шаблона абстрактного поведения требуется выделить сегменты перехода, выполняющиеся в рамках одного
    этапа. Это означает, что переходы, входящие в иерархические состояния, разбиваются на две части: входную, которая
    заканчивается на границе состояния, и расширение, которое продолжается внутри состояния. Точно также исходящие
    переходы, осуществляемые в рамках иерархического состояния, разбиваются на часть, которая завершается на границе
    вмещающего состояния, и часть, которая выполняется от границы вплоть до целевого состояния. Этот эффект моделируется в
    UML так называемыми <b>цепочечными состояниями</b>. Для этого применяется стереотип (&lt;&lt;chainState&gt;&gt;)
    концепции состояния UML. Это состояние, предназначенное только для представления перехода в виде цепочки автоматических
    (осуществляемых без триггеров) переходов. Цепочечное состояние не имеет внутренней структуры, для него не заданы
    действия при входе и выходе или внутренняя задача. Никакие его переходы не осуществляются по триггерам. Оно может иметь
    любое число входящих переходов. Оно может иметь исходящий переход без события-триггера, который осуществляется
    автоматически, когда это состояние активируется входящим переходом. Цель этого состояния - связать в цепочку входящий
    переход с отдельным исходящим переходом. В цепочке между входящими переходами и исходящим переходом первые соединены с
    другим состоянием внутри вмещающего состояния, а последний - с другим состоянием вне вмещающего состояния. Цель
    создания цепочечного состояния заключается в том, чтобы отделить внутреннюю спецификацию вмещающего состояния от его
    окружения, это вопрос инкапсуляции.
</p>
<p>
    Фактически цепочечное состояние представляет собой "проходное состояние", которое позволяет перевести один переход в
    другой. Если продолжение перехода не определено, то переход останавливается внутри цепочечного состояния, и для
    продолжения требуется осуществить какой-либо переход в вмещающем состоянии.
</p>
<p>
    Пример конечного автомата на рис. 7 иллюстрирует цепочечные состояния и их обозначения. Цепочечные состояния
    представлены на диаграмме конечного автомата белыми кружками внутри соответствующего иерархического состояния. Эти
    обозначения напоминают похожие обозначения для начального и конечного состояний. Кружки - это стереотипные значки для
    цепочечных состояний, и они обычно рисуются рядом с границей для наглядности. Одним из вариантом было бы рисовать их на
    границе вмещающего состояния.
</p>
<p align="center">
    <img height="152" alt="Диаграмма, описанная в тексте." src="./../../../core.base_rup/guidances/guidelines/resources/md_cpsl4.gif" width="391" />
</p>
<p class="picturetext" align="center">
    Figure 7. Цепочки состояний и цепочечные переходы.
</p>
<p>
    Цепочечный переход в данном примере включает три сегмента e1/a11-/a12-/a13. Когда приходит сигнал e1, осуществляется
    переход e1/a11, выполняется его действие a11, после чего достигается цепочечное состояние c1. После этого выполняется
    переход из c1 в c2 и затем, так как c2 - это тоже цепочечное состояние, переход из c2 в S21. Если состояния на этих
    путях также имеют действия при входе и выходе, то последовательность выполнения принимает следующий вид:
</p>
<ul>
    <li>
        действие при выходе из S11
    </li>
    <li>
        действие a11
    </li>
    <li>
        действие при выходе из S1
    </li>
    <li>
        действие a12
    </li>
    <li>
        действие при входе в S2
    </li>
    <li>
        действие a13
    </li>
    <li>
        действие при входе в S21
    </li>
</ul>
<p>
    Все это выполняется в рамках одного целостного этапа.
</p>
<p>
    Это можно сравнить с семантикой выполнения действий при прямом переходе e2/a2:
</p>
<ul>
    <li>
        действие при выходе из S11
    </li>
    <li>
        действие при выходе из S1
    </li>
    <li>
        действие a2
    </li>
    <li>
        действие при входе в состояние S2
    </li>
    <li>
        действие при входе в состояние S21
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
